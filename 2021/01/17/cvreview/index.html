

<!DOCTYPE html>
<html lang="en" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="black">
  <meta name="description" content="">
  <meta name="author" content="Chenlu Miao">
  <meta name="keywords" content="">
  <title>CV Couse Review - Explorer</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/atom-one-dark.min.css" />
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.6.2/gitalk.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Explorer</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-01-17 11:29" pubdate>
      January 17, 2021 am
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      113
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-post-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-post-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">CV Couse Review</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：January 17, 2021 am
                
              </p>
            
            <div class="markdown-body" id="post-body">
              <a id="more"></a>
<h1 id="Gestalt-Laws"><a href="#Gestalt-Laws" class="headerlink" title="Gestalt Laws"></a>Gestalt Laws</h1><blockquote>
<ol>
<li>知觉恒常性</li>
<li>Law of Proximity接近原则：接近/邻近的物体会被认为是一个整体</li>
<li>Law of Similarity相似原则： 在观察对象时容易把相似的物体分成一组</li>
<li>Law of Closure 闭合原则：视觉系统自动尝试将敞开的图形关闭起来，从而将其感知为完整的物体而不是分散的碎片</li>
<li>Law of Symmetry对称原则: 观察对象时容易将对象视为对称且围绕一个中心</li>
<li>Law of Continuity连续原则: 视觉倾向于感知连续的形式而不是离散的碎片</li>
<li><p>Law of Common Fate共同命运原则: 对象容易被视为行进在光滑路径上的线条</p>
</li>
<li><p>图形与背景法则：大脑将视觉区域分为主体和背景，主体包括一个场景中占据我们主要注意力的所有元素，其余则是背景</p>
</li>
</ol>
</blockquote>
<h1 id="Marr视觉表示的三个阶段"><a href="#Marr视觉表示的三个阶段" class="headerlink" title="Marr视觉表示的三个阶段"></a>Marr视觉表示的三个阶段</h1><blockquote>
<ul>
<li><p>Primal Sketch：处理输入的原始图像，抽取基本特征（角点、边缘、纹理、线条、边界etc.), 这些特征的集合称为基元图</p>
</li>
<li><p>2.5D Sketch：在<strong><em>以观测者为中心</em></strong>的坐标系中，由输入图像和基元图恢复场景可见部分的深度、法线方向、轮廓etc，这些信息包含了深度信息，但不是真正的物体三维表示，因此，称为二维半图</p>
</li>
<li><p>3D Model：在以物体为中心的坐标系中，由输入图像、基元图、二维半图，恢复表示识别三维物体</p>
</li>
</ul>
</blockquote>
<h1 id="二值图像"><a href="#二值图像" class="headerlink" title="二值图像"></a>二值图像</h1><h2 id="几何特性"><a href="#几何特性" class="headerlink" title="几何特性"></a>几何特性</h2><ul>
<li>面积</li>
<li>区域中心</li>
<li>方向</li>
<li>伸长率</li>
<li>密集度：$C=\frac{A}{p^2}$ （A面积，p周长)</li>
<li>形态比：区域的最小外接矩阵的长和宽之比</li>
<li>欧拉数：连通分量数-洞数</li>
</ul>
<h2 id="投影计算"><a href="#投影计算" class="headerlink" title="投影计算"></a>投影计算</h2><p><img src="image-20200113084909391.png" srcset="/img/loading.gif" alt="image-20200113084909391" style="zoom:50%;" /></p>
<p>对角线投影</p>
<p><img src="image-20200113085123216.png" srcset="/img/loading.gif" alt="image-20200113085123216" style="zoom:50%;" /></p>
<h2 id="连通区域"><a href="#连通区域" class="headerlink" title="连通区域"></a>连通区域</h2><h3 id="连通区域分量标记算法-贯序"><a href="#连通区域分量标记算法-贯序" class="headerlink" title="连通区域分量标记算法[贯序]"></a>连通区域分量标记算法[贯序]</h3><p>(1)从左至右，从上到下扫描图像</p>
<p>(2)如果象素点值为1，则(分4种情况) </p>
<ul>
<li><p>如果上面点和左面点有且仅有一个标记，则复制这一标记 </p>
</li>
<li><p>如果两点有相同标记，复制这一标记 </p>
</li>
<li><p>如果两点有不同标记，则复制上点的标记且将两个标记输入<u>等价表</u>中作为等价标记 </p>
</li>
<li><p>否则给这一个像素点分配一新的标记并将这一标记输入等价表 </p>
</li>
</ul>
<p>(3)如果需要考虑更多点，则返回(2) </p>
<p>(4)在等价表的每一等价集中找到最低的标记 </p>
<p>(5)扫描图像，用等价表中的最低标记取代每一标记 </p>
<h3 id="区域边界跟踪算法"><a href="#区域边界跟踪算法" class="headerlink" title="区域边界跟踪算法"></a>区域边界跟踪算法</h3><p><img src="image-20200113090028440.png" srcset="/img/loading.gif" alt="image-20200113090028440" style="zoom: 33%;" /></p>
<p><img src="image-20200113090211674.png" srcset="/img/loading.gif" alt="image-20200113090211674" style="zoom: 33%;" /></p>
<h1 id="边缘"><a href="#边缘" class="headerlink" title="边缘"></a>边缘</h1><h2 id="模板卷积"><a href="#模板卷积" class="headerlink" title="模板卷积"></a>模板卷积</h2><p><img src="image-20200113091426426.png" srcset="/img/loading.gif" alt="image-20200113091426426" style="zoom:50%;" /></p>
<h2 id="Origin-of-Edges"><a href="#Origin-of-Edges" class="headerlink" title="Origin of Edges"></a>Origin of Edges</h2><h3 id="四种最主要的不连续"><a href="#四种最主要的不连续" class="headerlink" title="四种最主要的不连续"></a>四种最主要的不连续</h3><p><img src="image-20200113091858321.png" srcset="/img/loading.gif" alt="image-20200113091858321" style="zoom:50%;" /></p>
<h2 id="边缘检测的基本思想"><a href="#边缘检测的基本思想" class="headerlink" title="边缘检测的基本思想"></a>边缘检测的基本思想</h2><p>函数导数反映图像灰度变化显著程度——边缘所在位置：一阶导数的局部极大值&amp;二阶导数的过零点</p>
<h2 id="基于一阶的边缘检测"><a href="#基于一阶的边缘检测" class="headerlink" title="基于一阶的边缘检测"></a>基于一阶的边缘检测</h2><ul>
<li><p>梯度</p>
</li>
<li><p>Roberts交叉算子</p>
</li>
<li>Sobel算子</li>
<li>Prewitt算子，运算较快</li>
<li>均值差分</li>
</ul>
<h2 id="基于二阶的边缘检测"><a href="#基于二阶的边缘检测" class="headerlink" title="基于二阶的边缘检测"></a>基于二阶的边缘检测</h2><blockquote>
<p> 图像灰度二阶导数的过零点对应边缘点. </p>
</blockquote>
<ul>
<li>Laplacian算子</li>
<li>LoG算子</li>
</ul>
<blockquote>
<p>LoG=Laplacian of Gaussian</p>
<p>平滑去噪和边缘检测是一对矛盾，应用高斯函数的一阶导数，可以在两者之间获得一个较好的平衡。高斯滤波+拉普拉斯边缘检测</p>
</blockquote>
<h2 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h2><ul>
<li><p>高斯滤波器平滑图像</p>
</li>
<li><p>一阶偏导有限差分计算梯度幅值和方向</p>
</li>
<li><p>对梯度幅值进行NMS（非极大值抑制）</p>
<p>简化的NMS步骤</p>
<ul>
<li><p>方向角离散化（360°分为8个扇区，对称扇区标号相同）</p>
</li>
<li><p>在离散后的梯度方向上找到幅值最大的点保留，其余点置零</p>
</li>
</ul>
</li>
<li><p>双阈值算法检测和连接边缘（取高低阈值T1,T2）</p>
</li>
</ul>
<p>高的阈值是将要提取轮廓的物体与背景区分开来：阈值太高，部分轮廓丢失</p>
<p>低的阈值是用来平滑边缘的轮廓：阈值太低，假边缘</p>
<p>两个阈值：T1, T2 。 大于T1的称为强边界，T1和T2之间的称为弱边界</p>
<h1 id="局部特征local-feature"><a href="#局部特征local-feature" class="headerlink" title="局部特征local feature"></a>局部特征local feature</h1><h2 id="Harris-Corner-detection"><a href="#Harris-Corner-detection" class="headerlink" title="Harris Corner detection"></a>Harris Corner detection</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote>
<p>在图像I(x,y)对指定大小窗口进行各个方向的平移，观测窗口内图像的相似程度</p>
<ul>
<li><p>Flat: 窗口内图像基本无变化</p>
</li>
<li><p>Edge: 沿Edge平移窗口时，窗口内图像无变化</p>
</li>
<li><p>Corner: 各方向平移时都有较大变化</p>
</li>
</ul>
</blockquote>
<h3 id="推导公式"><a href="#推导公式" class="headerlink" title="推导公式"></a>推导公式</h3><p>$E(u,v)=\sum_{x,y}w(x,y)(I(x+u,y+v)-I(x,y))^2$</p>
<p>$=\sum_{x,y}w(x,y)(uI_x+vI_y)^2$</p>
<p>$=\sum_{x,y}w(x,y)(u^2I_x^2+2uvI_xI_y+v^2I_y^2)$</p>
<script type="math/tex; mode=display">=\sum_{x,y}w(x,y)\left[\begin{matrix}u&v\end{matrix}\right]\left[\begin{matrix}I_x^2& I_xI_y\\ I_xI_y& I_y^2\end{matrix}\right]\left[\begin{matrix}u\\v\end{matrix}\right]</script><script type="math/tex; mode=display">E=\left[\begin{matrix}u&v\end{matrix}\right]M\left[\begin{matrix}u\\v\end{matrix}\right]</script><script type="math/tex; mode=display">M=\sum_{x,y}w(x,y)\left[\begin{matrix}I_x^2& I_xI_y\\ I_xI_y& I_y^2\end{matrix}\right]</script><h3 id="理解两个特征值的含义，以及他们与harris角点的关系"><a href="#理解两个特征值的含义，以及他们与harris角点的关系" class="headerlink" title="理解两个特征值的含义，以及他们与harris角点的关系"></a>理解两个特征值的含义，以及他们与harris角点的关系</h3><p><img src="image-20200113100604320.png" srcset="/img/loading.gif" alt="image-20200113100604320" style="zoom: 33%;" /></p>
<p><img src="image-20200113100715105.png" srcset="/img/loading.gif" alt="image-20200113100715105" style="zoom: 33%;" /></p>
<p><img src="image-20200113100804511.png" srcset="/img/loading.gif" alt="image-20200113100804511" style="zoom: 33%;" /></p>
<h3 id="论述对旋转不变性、灰度仿射不变性、尺度不变性的情况"><a href="#论述对旋转不变性、灰度仿射不变性、尺度不变性的情况" class="headerlink" title="论述对旋转不变性、灰度仿射不变性、尺度不变性的情况"></a>论述对旋转不变性、灰度仿射不变性、尺度不变性的情况</h3><ul>
<li><p><img src="image-20200113101000307.png" srcset="/img/loading.gif" alt="image-20200113101000307" style="zoom: 33%;" /></p>
</li>
<li></li>
</ul>
<p><img src="image-20200113101208188.png" srcset="/img/loading.gif" alt="image-20200113101208188" style="zoom:33%;" /></p>
<ul>
<li><p><img src="image-20200113101233647.png" srcset="/img/loading.gif" alt="image-20200113101233647" style="zoom:33%;" /></p>
</li>
</ul>
<h2 id="SIFT"><a href="#SIFT" class="headerlink" title="SIFT"></a>SIFT</h2><h2 id="1-简略的计算步骤"><a href="#1-简略的计算步骤" class="headerlink" title="1. 简略的计算步骤"></a>1. 简略的计算步骤</h2><ol>
<li><p>尺度空间极值检测：搜索所有尺度上的图像位置。通过高斯微分函数来识别潜在的对于尺度和旋转不变的兴趣点。</p>
</li>
<li><p>关键点定位：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。</p>
</li>
<li><p>方向确定：基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。</p>
</li>
<li><p>关键点描述：在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变化</p>
</li>
</ol>
<h2 id="2-为什么使用梯度信息而不直接使用像素值"><a href="#2-为什么使用梯度信息而不直接使用像素值" class="headerlink" title="2. 为什么使用梯度信息而不直接使用像素值"></a>2. 为什么使用梯度信息而不直接使用像素值</h2><blockquote>
<p>梯度可以表示边缘信息，并且在光照变化时有抵抗能力</p>
</blockquote>
<h2 id="3-各种不变性的解释"><a href="#3-各种不变性的解释" class="headerlink" title="3. 各种不变性的解释"></a>3. 各种不变性的解释</h2><p><strong>1.  平移不变：</strong>SIFT是局部特征，只提取关键点点附近矩形区域的sample，所以该物体移动到任何地方提取的feature都是类似的。同时因为是划grid去提取，即便关键点稍微偏移一下feature也基本没有变化，有点类似于HOG或者CNN的pooling。</p>
<p><strong>2.  旋转不变：</strong>在计算grid里面的梯度bin前需要旋转到主方向，因此有了一定的旋转不变性。而且旋转的时候每一个关键点周围的点也会跟着旋转，不会影响SIFT向量。</p>
<p><strong>3. 光照不变</strong>： 计算feature vector的时候进行了归一化、卡阈值之后又一次归一化，抵消了部分光照的影响。</p>
<p><strong>4. 尺度不变：</strong>金字塔模型，对每一种尺度都能进行检测。通过前一步算LoG得到的尺度来确定计算feature的范围，所以特征对应了一个尺度。所以原本不同尺度的图片能转换到相似的尺度提取相似的特征</p>
<h2 id="3-SIFT步骤"><a href="#3-SIFT步骤" class="headerlink" title="3. SIFT步骤"></a>3. SIFT步骤</h2><p>SIFT[scale-invariant feature transform]特征是图像的局部特征，其对旋转、尺度缩放、亮度变化保持不变性，对视角变化、仿射变换、噪声也保持一定程度的稳定性；</p>
<p>SIFT算法可以分解为四步</p>
<ol>
<li><p>尺度空间极值检测：搜索所有尺度上的图像位置。通过高斯微分函数来识别潜在的对于尺度和旋转不变的兴趣点。</p>
</li>
<li><p>关键点定位：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。</p>
</li>
<li><p>方向确定：基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。</p>
</li>
<li><p>关键点描述：在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变化</p>
</li>
</ol>
<h3 id="A-尺度空间极值检测"><a href="#A-尺度空间极值检测" class="headerlink" title="A. 尺度空间极值检测"></a>A. 尺度空间极值检测</h3><script type="math/tex; mode=display">G(x,y)=\frac{1}{2\pi \sigma ^2}e^{-\frac{(x-m/2)^2+(y-n/2)^2}{2\sigma ^2}}</script><p>尺度空间理论的基本思想是：在图像信息处理模型中引入一个被视为尺度的参数，通过连续变化尺度参数获得多尺度下的尺度空间表示序列，对这些序列进行尺度空间主轮廓的提取，并以该主轮廓作为一种特征向量，实现边缘、角点检测和不同分辨率上的特征提取等。</p>
<p>尺度空间可以用高斯金字塔表示，Tony Lindeberg指出尺度规范化的LoG(Laplacion of Gaussian)算子具有真正的尺度不变性，Lowe使用高斯差分金字塔近似LoG算子，在尺度空间检测稳定的关键点。</p>
<p>尺度空间方法将传统的单尺度图像信息处理技术纳入尺度不断变化的动态分析框架中，更容易获取图像的本质特征。尺度空间中各尺度图像的模糊程度逐渐变大，能够模拟人在距离目标由近到远时目标在视网膜上的形成过程。</p>
<h4 id="尺度空间的表示"><a href="#尺度空间的表示" class="headerlink" title="尺度空间的表示"></a>尺度空间的表示</h4><p><img src="image-20191219104245912.png" srcset="/img/loading.gif" alt="image-20191219104245912" style="zoom:40%;" /></p>
<p>一个图像的尺度空间，$L(x,y,\sigma)$定义为一个变化尺度[变化的是$\sigma$]的高斯函数$G(x,y,\sigma)$与原图像$I(x,y)$的卷积</p>
<script type="math/tex; mode=display">L(x,y,\sigma)=G(x,y,\sigma)*I(x,y)</script><script type="math/tex; mode=display">G(x,y)=\frac{1}{2\pi \sigma ^2}e^{-\frac{(x-m/2)^2+(y-n/2)^2}{2\sigma ^2}}</script><p><br/></p>
<p><strong><em>构建高斯金字塔</em></strong></p>
<ul>
<li>对图像做不同尺度的高斯模糊[调整$\sigma$]</li>
<li>对图像做降采样</li>
</ul>
<p><img src="image-20191219105034161.png" srcset="/img/loading.gif" alt="image-20191219105034161" style="zoom:40%;" /></p>
<p><img src="image-20191223164353053.png" srcset="/img/loading.gif" alt="image-20191223164353053" style="zoom:50%;" /></p>
<p>图像的金字塔模型是指，将原始图像不断降阶采样，得到一系列大小不一的图像，由大到小，从下到上构成的塔状模型。原图像为金子塔的第一层，每次降采样所得到的新图像为金字塔的一层(每层一张图像)，每个金字塔共n层。</p>
<p><img src="image-20191219105337581.png" srcset="/img/loading.gif" alt="image-20191219105337581" style="zoom:50%;" /></p>
<p>为了让尺度体现其连续性，高斯金字塔在简单降采样的基础上加上了高斯滤波。</p>
<p>将图像金字塔每层的一张图像使用不同参数[$\sigma$]做高斯模糊，使得金字塔的每层含有多张高斯模糊图像，将金字塔每层多张图像合称为一组(Octave)，金字塔每层只有一组图像，每组含有多张(也叫层Interval)图像。另外，降采样时，高斯金字塔上一组图像的初始图像(底层图像)是由前一组图像的倒数第三张图像隔点采样得到的。</p>
<p><strong><em>构建高斯差分金字塔</em></strong></p>
<p>2002年Mikolajczyk在详细的实验比较中发现尺度归一化的高斯拉普拉斯函数$\sigma ^2\nabla^2G $ 的极大值和极小值能够产生最稳定的图像特征，这和其它的特征提取函数，例如：梯度，Hessian或Harris角特征类似。</p>
<p>而Lindeberg早在1994年就发现<strong><em>高斯差分函数</em></strong>（Difference of Gaussian ，简称DOG算子）与尺度归一化的高斯拉普拉斯函数非常近似。</p>
<script type="math/tex; mode=display">\frac{\partial G}{\partial \sigma}=\frac{-2\sigma^2+x^2+y^2}{2\pi \sigma^5}e^{-(x^2+y^2)/{2\sigma^2}}</script><script type="math/tex; mode=display">\nabla^2G=\frac{\partial^2 G}{\partial x^2}+\frac{\partial^2 G}{\partial y^2}=\frac{-2\sigma^2+x^2+y^2}{2\pi \sigma^6}e^{-(x^2+y^2)/{2\sigma^2}}</script><script type="math/tex; mode=display">\Rightarrow \frac{\partial G}{\partial \sigma}=\sigma \nabla^2G</script><script type="math/tex; mode=display">\sigma\nabla^2G=\frac{\partial G}{\partial \sigma}\approx \frac{G(x,y,k\sigma)-G(x,y,\sigma)}{k\sigma-\sigma}</script><p>因此<script type="math/tex">G(x,y,k\sigma)-G(x,y,\sigma)\approx (k-1)\sigma ^2\nabla ^2 G</script></p>
<p><img src="image-20191219110027492.png" srcset="/img/loading.gif" alt="image-20191219110027492" style="zoom:50%;" /></p>
<script type="math/tex; mode=display">\begin{aligned}D(x,y,\sigma)=&(G(x,y,k\sigma)-G(x,y,\sigma))*I(x,y)\\=&L(x,y,k\sigma)-L(x,y,\sigma)\end{aligned}</script><p>为了在每组中检测S个尺度的极值点，则DOG金字塔每组需S+2层图像，而DOG金字塔由高斯金字塔相邻两层相减得到，则高斯金字塔每组需S+3层图像</p>
<p><img src="image-20191223164421850.png" srcset="/img/loading.gif" alt="image-20191223164421850" style="zoom:50%;" /></p>
<p><strong><em>空间极值点检测</em></strong></p>
<p>关键点是由DOG空间的局部极值点组成的，关键点的初步探查是通过同一组内各DoG相邻两层图像之间比较完成的。为了寻找DoG函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度域的相邻点大或者小。中间的检测点和它同尺度的8个相邻点和上下相邻尺度对应的9×2个点共26个点比较，以确保在尺度空间和二维图像空间都检测到极值点。</p>
<p><img src="image-20191219112644432.png" srcset="/img/loading.gif" alt="image-20191219112644432" style="zoom:40%;" /></p>
<h3 id="B-关键点定位"><a href="#B-关键点定位" class="headerlink" title="B. 关键点定位"></a>B. 关键点定位</h3><ul>
<li>Discard points with DOG value <strong><em>below threshold</em></strong> (low contrast)</li>
<li><p>However, points along edges may have high contrast in one direction but low in another </p>
</li>
<li><p>Compute principal curvatures from eigenvalues of 2x2 Hessian matrix, and <strong><em>limit ratio</em></strong> (Harris approach): </p>
</li>
</ul>
<p><img src="image-20191219113121266.png" srcset="/img/loading.gif" alt="image-20191219113121266" style="zoom:50%;" /></p>
<h3 id="C-方向确定"><a href="#C-方向确定" class="headerlink" title="C. 方向确定"></a>C. 方向确定</h3><ul>
<li>Take 16x16 square window around detected feature </li>
<li>Compute edge orientation (angle of the gradient - 90) for each pixel </li>
<li>Throw out weak edges (threshold gradient magnitude) </li>
<li>Create histogram of surviving edge orientations </li>
</ul>
<p><img src="image-20191219113757045.png" srcset="/img/loading.gif" alt="image-20191219113757045" style="zoom:50%;" /></p>
<p>方向直方图的峰值则代表了该特征点处邻域梯度的方向，以直方图中最大值作为该关键点的<strong><em><u>主方向</u></em></strong>。</p>
<p>为了增强匹配的鲁棒性，只保留峰值大于主方向峰值80％的方向作为该关键点的辅方向。因此，对于同一梯度值的多个峰值的关键点位置，在相同位置和尺度将会有多个关键点被创建但方向不同。仅有15％的关键点被赋予多个方向，但可以明显的提高关键点匹配的稳定性。</p>
<h3 id="D-关键点特征描述"><a href="#D-关键点特征描述" class="headerlink" title="D. 关键点特征描述"></a>D. 关键点特征描述</h3><p>通过以上步骤，对于每一个关键点，拥有三个信息：</p>
<p><strong><em><u>（位置，尺度，方向）</u></em></strong>。</p>
<p>接下来就是为每个关键点建立一个<strong><em>描述符</em></strong>，用一组向量将这个关键点描述出来，使其不随各种变化而改变，比如光照变化、视角变化等等。这个描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述符应该有较高的独特性，以便于提高特征点正确匹配的概率。</p>
<p>SIFI 描述子h(x, y,θ)是对特征点附近邻域内高斯图像梯度统计结果的一种表示，它是一个三维的阵列，但通常将它表示成一个矢量。矢量是通过对三维阵列按一定规律进行排列得到的。特征描述子与特征点所在的尺度有关，因此，对梯度的求取应在特征点对应的高斯图像上进行。</p>
<p><img src="image-20191223164625763.png" srcset="/img/loading.gif" alt="image-20191223164625763" style="zoom: 33%;" /></p>
<p>为了保证特征矢量具有<strong><em>旋转不变性</em></strong>，需要以特征点为中心，将特征点附近邻域内图像梯度的位置和方向旋转一个方向角θ，即将原图像x轴转到与主方向相同的方向。</p>
<p>旋转公式</p>
<script type="math/tex; mode=display">\left[\begin{matrix}x'\\y'\end{matrix} \right]=\left[\begin{matrix}cos\theta & -sin\theta\\ sin\theta & cos\theta\end{matrix}\right]</script><script type="math/tex; mode=display">W=\left[\begin{matrix}0&w_{12}&w_{13}\\  w_{21}&0&w_{23}\\ w_{31}&w_{32}&0\end{matrix}\right]</script><p>然后</p>
<ul>
<li>Divide the 16x16 window into a 4x4 grid of cells (2x2 case shown below) </li>
<li>Compute an orientation histogram for each cell </li>
<li>16 cells * 8 orientations = 128 dimensional descriptor </li>
</ul>
<p><img src="image-20191223170837231.png" srcset="/img/loading.gif" alt="image-20191223170837231" style="zoom:50%;" /></p>
<p><strong><em><u>在最后，对特征向量进行归一化处理，去除光照变化的影响</u>。</em></strong></p>
<h1 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h1><h2 id="Hough变换"><a href="#Hough变换" class="headerlink" title="Hough变换"></a>Hough变换</h2><p><a href="https://sikasjc.github.io/2018/04/20/Hough/#introduction-介绍" target="_blank" rel="noopener">excellent article</a></p>
<h3 id="用来解决什么问题"><a href="#用来解决什么问题" class="headerlink" title="用来解决什么问题"></a>用来解决什么问题</h3><blockquote>
<p>Hough变换是基于voting原理对参数估计方法，是一种重要的形状检测技术</p>
</blockquote>
<h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote>
<p>图像中每一点对参数组合进行表决，赢得多数票的参数组合为胜者(结果) </p>
</blockquote>
<h3 id="具体原理"><a href="#具体原理" class="headerlink" title="具体原理"></a>具体原理</h3><p>但是在直角坐标系下的表示形式，存在无法表示垂直于x轴的直线的问题，此时$a=\infty$</p>
<p>$y=ax+b$改写成极坐标形式$r=xcos\theta+ysin\theta$</p>
<p>即$y=-\frac{cos\theta}{sin\theta}x+\frac{r}{sin\theta}$</p>
<p>当$\theta\in[0,180]$和$r\in\mathbf{R}$或者当$\theta\in[0,360]$和$r\ge 0$时， 极坐标系中所有的直线都可以用这种形式表示。</p>
<p>Hough空间因此具有这两个维度: $\theta$和r, 并且极坐标系下直线由Hough空间的单个点表示，对应于唯一的一组参数$(\theta_0,r_0)$</p>
<p>与直角坐标系相同，极坐标系下的多点，对应于Hough空间中的多个曲线，若存在过这些点的一条直线，则Hough空间中的曲线必然相交于一点。</p>
<p><img src="image-20200113114634265.png" srcset="/img/loading.gif" alt="image-20200113114634265" style="zoom:50%;" /></p>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><h4 id="A-4步"><a href="#A-4步" class="headerlink" title="A. 4步"></a>A. 4步</h4><ol>
<li>适当地量化参数空间(合适的精度即可)</li>
<li>假定参数空间的每一个单元都是一个累加器，把累加器初始化为0</li>
<li>对图像空间的每一点，在其所满足的参数方程对应的累加器上+1</li>
<li>累加器阵列的最大值对应模型的参数</li>
</ol>
<h4 id="B-圆弧检测6步"><a href="#B-圆弧检测6步" class="headerlink" title="B. 圆弧检测6步"></a>B. 圆弧检测6步</h4><ol>
<li>量化关于a,b的参数空间到合适精度</li>
<li>假定参数空间的每一个单元都是一个累加器，把累加器初始化为0</li>
<li>计算图像空间中边缘的梯度幅值和角度</li>
<li>对图像空间的每一点，在其所满足的参数方程对应的累加器上+1</li>
<li>累加器阵列的最大值对应图像空间中圆心</li>
<li>得到圆心坐标之后，可以反求r</li>
</ol>
<h1 id="Image-Stitching"><a href="#Image-Stitching" class="headerlink" title="Image Stitching"></a>Image Stitching</h1><h2 id="RANSAC-random-sample-consensus"><a href="#RANSAC-random-sample-consensus" class="headerlink" title="RANSAC random sample consensus"></a>RANSAC random sample consensus</h2><h3 id="A-可以解决什么样的问题"><a href="#A-可以解决什么样的问题" class="headerlink" title="A. 可以解决什么样的问题"></a>A. 可以解决什么样的问题</h3><p>模型参数的fitting</p>
<p>采用迭代的方式从一组包含outliers的数据中估算数学模型的参数。</p>
<h3 id="B-核心思想"><a href="#B-核心思想" class="headerlink" title="B. 核心思想"></a>B. 核心思想</h3><p>核心思想是随机性和假设性。</p>
<p>随机性是根据正确数据出现的概率去随机选取抽样数据</p>
<h3 id="C-优点"><a href="#C-优点" class="headerlink" title="C. 优点"></a>C. 优点</h3><p>是大范围模型匹配问题的一个普遍意义上的方法，且运用简单，计算快。<br><strong>缺点：</strong>只能计算outliers不多的情况（投票机制可以解决outliers高的情况） </p>
<h3 id="D-基本步骤"><a href="#D-基本步骤" class="headerlink" title="D. 基本步骤"></a>D. 基本步骤</h3><p><img src="image-20191223172555445.png" srcset="/img/loading.gif" alt="image-20191223172555445" style="zoom:50%;" /></p>
<p>给定的参数是：</p>
<ul>
<li>n: 点的数量</li>
<li>k: 迭代的次数</li>
<li>t: 可以被认为是内点的范围</li>
<li>d: 被认为fit well的model需要的内点数</li>
</ul>
<ol>
<li>在数据中随机均匀地选择几个点设置为hypothetical inliers</li>
<li>计算拟合inliers的模型</li>
<li>把其他没有选择的点带入模型，计算其是否为内点</li>
<li>记录内点数量</li>
<li>重复上述步骤k次</li>
<li>比较各次拟合模型的内点数量, 选择内点数量最多的模型</li>
</ol>
<h2 id="E-outlier点比例给定的情况下，则k次采样后计算成功的概率是"><a href="#E-outlier点比例给定的情况下，则k次采样后计算成功的概率是" class="headerlink" title="E. outlier点比例给定的情况下，则k次采样后计算成功的概率是"></a>E. outlier点比例给定的情况下，则k次采样后计算成功的概率是</h2><p><img src="3FDE0E014928B8766B47FD4B2409A849.png" srcset="/img/loading.gif" alt="3FDE0E014928B8766B47FD4B2409A849" style="zoom: 40%;" /></p>
<h2 id="F-步骤"><a href="#F-步骤" class="headerlink" title="F. 步骤"></a>F. 步骤</h2><ol>
<li>detect key points </li>
<li>build the SIFT descriptors </li>
<li>Match SIFT descriptors</li>
<li>Fitting the transformation(RANSAC计算Homography矩阵，进行变换)</li>
<li>image Blending </li>
</ol>
<h1 id="物体识别"><a href="#物体识别" class="headerlink" title="物体识别"></a>物体识别</h1><h2 id="Visual-Recognition"><a href="#Visual-Recognition" class="headerlink" title="Visual Recognition"></a>Visual Recognition</h2><h3 id="基本任务可以分为哪几大类"><a href="#基本任务可以分为哪几大类" class="headerlink" title="基本任务可以分为哪几大类"></a>基本任务可以分为哪几大类</h3><blockquote>
<ol>
<li>图片分类 </li>
<li>检测和定位物体/图片分割 </li>
<li>估计语义和几何属性 </li>
<li>对人类活动和事件进行分类 </li>
</ol>
</blockquote>
<h3 id="都具有哪些挑战因素"><a href="#都具有哪些挑战因素" class="headerlink" title="都具有哪些挑战因素"></a>都具有哪些挑战因素</h3><blockquote>
<p>视角变换<br>光线变化<br>尺度变化<br>物体形变<br>物体遮挡<br>背景凌乱<br>内部类别多样</p>
</blockquote>
<h2 id="基于词袋-BoW-bag-of-words-的物体分类"><a href="#基于词袋-BoW-bag-of-words-的物体分类" class="headerlink" title="基于词袋(BoW bag of words)的物体分类"></a>基于词袋(BoW bag of words)的物体分类</h2><h3 id="图像的BoW是指什么意思"><a href="#图像的BoW是指什么意思" class="headerlink" title="图像的BoW是指什么意思"></a>图像的BoW是指什么意思</h3><blockquote>
<p>图像中的单词被定义为一个图像块的特征向量，图像的Bow模型即图像中所有图像块的特征向量得到的直方图</p>
</blockquote>
<h3 id="基本步骤-1"><a href="#基本步骤-1" class="headerlink" title="基本步骤"></a>基本步骤</h3><blockquote>
<ol>
<li>特征提取和表示（grid），每个特征为一个质点 </li>
<li>通过对质点聚类建立字典（k 聚类），得到k个聚类中心，聚类中心就是词袋中的单词，所有聚类中心就是特征直方图的基 </li>
<li>将图片用直方图的基表示出来，这样就可以得到关于图片的特征直方图。该直方图与单词的顺序没有关系，而是每个单词在图片中出现的频率 </li>
<li>将新的图片获取质点，然后映射到直方图上进行聚类</li>
</ol>
</blockquote>
<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><h2 id="A-深度学习"><a href="#A-深度学习" class="headerlink" title="A. 深度学习"></a>A. 深度学习</h2><h3 id="怎么理解被称为end-to-end的学习"><a href="#怎么理解被称为end-to-end的学习" class="headerlink" title="怎么理解被称为end-to-end的学习"></a>怎么理解被称为end-to-end的学习</h3><blockquote>
<p>raw inputs to predictions</p>
<p><strong>一端输入我的原始数据，一端输出我想得到的结果。只关心输入和输出，中间的步骤全部都不管。</strong></p>
</blockquote>
<h3 id="神经网络的学习，数学本质上是求解什么？常用的基本方法？"><a href="#神经网络的学习，数学本质上是求解什么？常用的基本方法？" class="headerlink" title="神经网络的学习，数学本质上是求解什么？常用的基本方法？"></a>神经网络的学习，数学本质上是求解什么？常用的基本方法？</h3><blockquote>
<p>本质：Learning hierarchical representations from data，学习权重</p>
<p>常用的基本方法：梯度下降法</p>
</blockquote>
<h2 id="B-CNN"><a href="#B-CNN" class="headerlink" title="B. CNN"></a>B. CNN</h2><h3 id="理解卷积层和Pooling层的作用"><a href="#理解卷积层和Pooling层的作用" class="headerlink" title="理解卷积层和Pooling层的作用"></a>理解卷积层和Pooling层的作用</h3><blockquote>
<p>卷积层：用于提取图像中的特征</p>
<p>Pooling: make the representations smaller and more manageable without losing too much information.</p>
</blockquote>
<h3 id="计算卷积层中各种weight的数量"><a href="#计算卷积层中各种weight的数量" class="headerlink" title="计算卷积层中各种weight的数量"></a>计算卷积层中各种weight的数量</h3><p>CNN和NN的结构差异</p>
<p><img src="image-20200112171633117.png" srcset="/img/loading.gif" alt="image-20200112171633117" style="zoom:30%;" /></p>
<p><img src="image-20200112171816074.png" srcset="/img/loading.gif" alt="image-20200112171816074" style="zoom:25%;" /></p>
<ul>
<li>算一个neuron在一个固定位置需要学习几个权重</li>
</ul>
<p><img src="image-20200112172217698.png" srcset="/img/loading.gif" alt="image-20200112172217698" style="zoom:40%;" /></p>
<p><img src="image-20200112173516864.png" srcset="/img/loading.gif" alt="image-20200112173516864" style="zoom:40%;" /></p>
<ul>
<li>算output size</li>
</ul>
<div class="note note-warning">
            <p>如果share权重的话，每个neuron只需要learn一个位置权重，其他位置都共享这个权重</p>
          </div>
<p>如果不share权重，每个neuron 需要遍历图像，每个位置都learn一组权重</p>
<p><img src="image-20200112173633424.png" srcset="/img/loading.gif" alt="image-20200112173633424" style="zoom:40%;" /></p>
<ul>
<li>总结</li>
</ul>
<p><img src="image-20200112173720518.png" srcset="/img/loading.gif" alt="image-20200112173720518" style="zoom:40%;" /></p>
<p><img src="image-20200112173924532.png" srcset="/img/loading.gif" alt="image-20200112173924532" style="zoom:40%;" /></p>
<p>详细看一下下边这个例子</p>
<p>pad2补全卷积后的图像到32*32[这块图片上有问题]</p>
<p>所以每个neuron在一个位置需要learn  5*5*3​个权重</p>
<ul>
<li>如果不share权重</li>
</ul>
<blockquote>
<p>那么每个neuron一共要学习 32*32*5*5*3​个权重</p>
<p>一共有30个neuron，则一共要学习 30*32*32*5*5*3​个权重</p>
</blockquote>
<ul>
<li>如果share权重</li>
</ul>
<blockquote>
<p>那么每个neuron一共要学习 5*5*3个权重</p>
<p>一共有30个neuron，则一共要学习 30*5*5*3​个权重</p>
</blockquote>
<p><img src="image-20200113152540199.png" srcset="/img/loading.gif" alt="image-20200113152540199" style="zoom:50%;" /></p>
<h2 id="C-BP-算法"><a href="#C-BP-算法" class="headerlink" title="C. BP 算法"></a>C. BP 算法</h2><h3 id="知道BP算法的作用"><a href="#知道BP算法的作用" class="headerlink" title="知道BP算法的作用"></a>知道BP算法的作用</h3><blockquote>
<p>计算梯度</p>
</blockquote>
<h3 id="理解梯度下降法和BP算法的关系"><a href="#理解梯度下降法和BP算法的关系" class="headerlink" title="理解梯度下降法和BP算法的关系"></a>理解梯度下降法和BP算法的关系</h3><blockquote>
<p>梯度下降 是 找损失函数极小值的一种方法，<br>反向传播 是 求解梯度的一种方法，解释计算神经网络中误差函数梯度的一种方法。</p>
</blockquote>
<h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><p><img src="image-20200112181313333.png" srcset="/img/loading.gif" alt="image-20200112181313333" style="zoom:33%;" /></p>
<p><img src="image-20200112181337922.png" srcset="/img/loading.gif" alt="image-20200112181337922" style="zoom:33%;" /></p>
<p><img src="image-20200112181402139.png" srcset="/img/loading.gif" alt="image-20200112181402139" style="zoom:33%;" /></p>
<p><img src="image-20200112181435613.png" srcset="/img/loading.gif" alt="image-20200112181435613" style="zoom:33%;" /></p>
<p><img src="image-20200112181517866.png" srcset="/img/loading.gif" alt="image-20200112181517866" style="zoom:33%;" /></p>
<p><img src="image-20200112181557691.png" srcset="/img/loading.gif" alt="image-20200112181557691" style="zoom:33%;" /></p>
<p><img src="image-20200112181625197.png" srcset="/img/loading.gif" alt="image-20200112181625197" style="zoom:33%;" /></p>
<p><img src="image-20200112181645783.png" srcset="/img/loading.gif" alt="image-20200112181645783" style="zoom:33%;" /></p>
<p><img src="image-20200112181714819.png" srcset="/img/loading.gif" alt="image-20200112181714819" style="zoom:33%;" /></p>
<h1 id="光流—-gt-运动跟踪"><a href="#光流—-gt-运动跟踪" class="headerlink" title="光流—&gt;运动跟踪"></a>光流—&gt;运动跟踪</h1><p><img src="image-20200112151210825.png" srcset="/img/loading.gif" alt="image-20200112151210825" style="zoom: 33%;" /></p>
<h2 id="A-光流解决的问题"><a href="#A-光流解决的问题" class="headerlink" title="A. 光流解决的问题"></a>A. 光流解决的问题</h2><blockquote>
<p>是空间运动物体在观察成像平面上的像素运动的瞬时速度，是利用图像序列中像素在时间域上的变化以及相邻帧之间的相关性来找到上一帧跟当前帧之间存在的对应关系，从而计算出相邻帧之间物体的运动信息的一种方法.</p>
<p>评估从H到I到像素运动，给出图像H中的一个像素， 找到图像I中相同颜色的相近像素，解决的是像素对应问题</p>
</blockquote>
<h2 id="B-光流的三个基本假设"><a href="#B-光流的三个基本假设" class="headerlink" title="B. 光流的三个基本假设"></a>B. 光流的三个基本假设</h2><ul>
<li>brightness constancy 亮度恒定性</li>
</ul>
<script type="math/tex; mode=display">I(x+u, y+v, t+1) = I(x,y,t)</script><ul>
<li>spatial coherence 空间相干性 相似像素拥有相似运动</li>
<li>small motion 细微运动</li>
</ul>
<h2 id="C-一个点的约束公式会推导optical-flow-equation"><a href="#C-一个点的约束公式会推导optical-flow-equation" class="headerlink" title="C. 一个点的约束公式会推导optical flow equation"></a>C. 一个点的约束公式会推导optical flow equation</h2><script type="math/tex; mode=display">\begin{aligned}0=&I(x+u,y+v)-H(x,y)\\ \approx & I(x,y) +I_x u+I_y v-H(x,y)\\ \approx & (I(x,y)-H(x,y)) +I_x u+I_y v\\ \approx &I_t+uI_x+vI_y \\ \approx &I_t+\nabla I\cdot[u,v]^T\end{aligned}</script><h2 id="D-哪些位置的光流比较可靠？为什么？"><a href="#D-哪些位置的光流比较可靠？为什么？" class="headerlink" title="D. 哪些位置的光流比较可靠？为什么？"></a>D. 哪些位置的光流比较可靠？为什么？</h2><p>尽量避免用边缘上的点计算光流</p>
<p>使用<strong><em><u>纹理复杂区域</u></em></strong>， 梯度比较大且方向不同， 求出来的特征值比较大</p>
<p>不用边缘的原因</p>
<p><img src="D58381987D5E8F2CF1DCC31BE0E96919.png" srcset="/img/loading.gif" alt="D58381987D5E8F2CF1DCC31BE0E96919" style="zoom:50%;" /></p>
<h1 id="相机模型"><a href="#相机模型" class="headerlink" title="相机模型"></a>相机模型</h1><h2 id="A-理解：景深-光圈-焦距-视场"><a href="#A-理解：景深-光圈-焦距-视场" class="headerlink" title="A. 理解：景深/光圈/焦距/视场"></a>A. 理解：景深/光圈/焦距/视场</h2><h3 id="景深depth-of-field"><a href="#景深depth-of-field" class="headerlink" title="景深depth of field"></a>景深depth of field</h3><blockquote>
<p>相机镜头能够取得清晰图像的成像所测定的被摄物体前后范围距离</p>
</blockquote>
<p><img src="image-20200112111521768.png" srcset="/img/loading.gif" alt="image-20200112111521768" style="zoom:30%;" /></p>
<p><img src="image-20200112111758310.png" srcset="/img/loading.gif" alt="image-20200112111758310" style="zoom:30%;" /></p>
<h3 id="视场field-of-view"><a href="#视场field-of-view" class="headerlink" title="视场field of view"></a>视场field of view</h3><blockquote>
<p>镜头能够观察到的最大范围</p>
</blockquote>
<p><img src="image-20200112103140704.png" srcset="/img/loading.gif" alt="image-20200112103140704" style="zoom: 25%;" /></p>
<h3 id="光圈对景深的影响"><a href="#光圈对景深的影响" class="headerlink" title="光圈对景深的影响"></a>光圈对景深的影响</h3><p>镜头光圈：光圈越大，景深越小；光圈越小，景深越大；</p>
<p>镜头焦距镜头焦距越长，景深越小；焦距越短，景深越大;</p>
<ul>
<li>一般说来，在同样的光圈下，焦距越长的镜头其景深就越小，相反则越大。所以广角镜头有很大的景深，超广角镜头在其最大光圈下几厘米外都会有清晰的成像，但长焦镜头或望远镜头则景深很小，有时仅是几厘米景深，拍人像时弄不好就会出现一只眼睛是清晰的而另一只眼睛则虚化了</li>
</ul>
<p>拍摄距离距离越远，景深越大；距离越近，景深越小。</p>
<ul>
<li>而当拍摄时的光圈大小不变，所使用的镜头焦距也不改变时，被摄体越远，画面中的前后清晰范围就越大；反之，被摄体越近，前后的清晰范围也就相对越小。</li>
</ul>
<h3 id="焦距对视场的影响"><a href="#焦距对视场的影响" class="headerlink" title="焦距对视场的影响"></a>焦距对视场的影响</h3><blockquote>
<p>焦距越短，视场角越大</p>
</blockquote>
<h2 id="B-理想的针孔pinhole-camera模型"><a href="#B-理想的针孔pinhole-camera模型" class="headerlink" title="B. 理想的针孔pinhole camera模型"></a>B. 理想的针孔pinhole camera模型</h2><p><img src="image-20200112135340340.png" srcset="/img/loading.gif" alt="image-20200112135340340" style="zoom:30%;" /></p>
<p>这里f,z都是距离</p>
<p>不妨把成像平面放到针孔前</p>
<p><img src="image-20200112112825190.png" srcset="/img/loading.gif" alt="image-20200112112825190" style="zoom:50%;" /></p>
<h3 id="基本投影公式及其其极坐标形式下的透视投影公式"><a href="#基本投影公式及其其极坐标形式下的透视投影公式" class="headerlink" title="基本投影公式及其其极坐标形式下的透视投影公式"></a>基本投影公式及其其极坐标形式下的透视投影公式</h3><blockquote>
<p>We will use the pin-hole model as an approximation</p>
<ul>
<li>Put the optical center(Center Of Projection) at the origin</li>
<li>Put the image plane(Projection Plane) in front of the COP</li>
<li>The camera looks down the negative z axis</li>
</ul>
</blockquote>
<p>这边d是个正数，但是在Z轴负半轴</p>
<script type="math/tex; mode=display">(x,y,z)\rightarrow (-d\frac{x}{z}, -d\frac{y}{z}, -d)</script><p>We get the projection by throwing out the last coordinate: $(x,y,z)\rightarrow (-d\frac{x}{z}, -d\frac{y}{z})$</p>
<p>对于假想的针孔照相机，针孔到屏幕的距离就是焦距</p>
<h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><p>convert to homogeneous coordinates</p>
<script type="math/tex; mode=display">(x,y,z)\Rightarrow \left[\begin{matrix}x \\ y\\z\\1\end{matrix}\right]</script><p>convert from homogeneous coordinates</p>
<script type="math/tex; mode=display">(x,y,z,w)\Rightarrow \left[\begin{matrix}x/w \\ y/w\\z/w\end{matrix}\right]</script><p>透视矩阵</p>
<script type="math/tex; mode=display">\left[\begin{matrix}1&0&0&0\\0&1&0&0\\0&0&1&0\\0&0&-1/d&0\end{matrix}\right]\left[\begin{matrix}x \\ y\\z\\1\end{matrix}\right]=\left[\begin{matrix}x\\y\\z\\-z/d\end{matrix}\right]\Rightarrow (-d\frac{x}{z}, -d\frac{y}{z})</script><h3 id="齐次坐标的好处"><a href="#齐次坐标的好处" class="headerlink" title="齐次坐标的好处"></a>齐次坐标的好处</h3><blockquote>
<p>可以矩阵直接计算平移 旋转 尺度变换</p>
<p>如果不是齐次就没有平移</p>
</blockquote>
<h3 id="Camera-Parameters内参矩阵"><a href="#Camera-Parameters内参矩阵" class="headerlink" title="Camera Parameters内参矩阵"></a>Camera Parameters内参矩阵</h3><p><a href="https://www.jianshu.com/p/7d97fccd79bb" target="_blank" rel="noopener">excellent article</a></p>
<script type="math/tex; mode=display">(f_u,f_v, u_0,v_0)</script><h4 id="第一步：相机坐标系—-gt-成像坐标系-其中f为焦距"><a href="#第一步：相机坐标系—-gt-成像坐标系-其中f为焦距" class="headerlink" title="第一步：相机坐标系—&gt;成像坐标系  其中f为焦距"></a>第一步：相机坐标系—&gt;成像坐标系  其中f为焦距</h4><p><img src="image-20200112112825190.png" srcset="/img/loading.gif" alt="image-20200112112825190" style="zoom:50%;" /></p>
<p><img src="image-20200112140843480.png" srcset="/img/loading.gif" alt="image-20200112140843480" style="zoom:50%;" /></p>
<p>如果不考虑上面S的齐次坐标的话</p>
<script type="math/tex; mode=display">Z^{(c)}\left[\begin{matrix}u^{(c)}\\v^{(c)}\\1\end{matrix}\right]=\left[\begin{matrix}-f&0&0\\0&-f&0\\0&0&1\end{matrix}\right]\left[\begin{matrix}X^{(c)}\\Y^{(c)}\\Z^{(c)}\end{matrix}\right]</script><h4 id="第二步：-物理单位与像素单位变换矩阵"><a href="#第二步：-物理单位与像素单位变换矩阵" class="headerlink" title="第二步： 物理单位与像素单位变换矩阵"></a>第二步： 物理单位与像素单位变换矩阵</h4><p>考虑度量单位（mm-&gt;pixel）的不同， 以及两坐标系原点不同</p>
<p>其中u,v为像素坐标系坐标， x,y为成像坐标系坐标</p>
<p>$k_u,k_v$是一个单位物理长度对应的像素数量</p>
<p>$(u_0,v_0)$是成像坐标系相对于像素坐标系的偏移量</p>
<p><img src="image-20200112141120961.png" srcset="/img/loading.gif" alt="image-20200112141120961" style="zoom:50%;" /></p>
<h4 id="第三步：整合"><a href="#第三步：整合" class="headerlink" title="第三步：整合"></a>第三步：整合</h4><script type="math/tex; mode=display">\left[\begin{matrix}u\\v\\w\end{matrix}\right]=\left[\begin{matrix}k_u&0&u_0\\0&k_v&v_0\\0&0&1\end{matrix}\right]\left[\begin{matrix}-f&0&0\\0&-f&0\\0&0&1\end{matrix}\right]\left[\begin{matrix}X^{(c)}\\Y^{(c)}\\Z^{(c)} \end{matrix}\right]</script><p>最终物体的像素坐标是$(u/w, v/w)$</p>
<p>中间两个矩阵相乘的结果为</p>
<script type="math/tex; mode=display">\left[\begin{matrix}-fk_u&0&u_0\\0&-fk_v&v_0\\0&0&1\end{matrix}\right]=\left[\begin{matrix}-f_u&0&u_0\\0&-f_v&v_0\\0&0&1\end{matrix}\right]</script><p>其中$f_u=fk_u, f_v=fk_v$</p>
<h2 id="C-Distortion畸变"><a href="#C-Distortion畸变" class="headerlink" title="C. Distortion畸变"></a>C. Distortion畸变</h2><p>两种类型：Radial distortion, tangential distortion</p>
<h3 id="Radial-distortion"><a href="#Radial-distortion" class="headerlink" title="Radial distortion"></a>Radial distortion</h3><p>原因：</p>
<blockquote>
<ul>
<li><p>The geometry of the lens</p>
</li>
<li><p>Aperture position</p>
</li>
</ul>
</blockquote>
<p>分类：</p>
<blockquote>
<ul>
<li><p>枕形畸变：中间向外凸起</p>
</li>
<li><p>桶形畸变：中间向内凹陷</p>
</li>
</ul>
</blockquote>
<p><img src="image-20200112124243564.png" srcset="/img/loading.gif" alt="image-20200112124243564" style="zoom:30%;" /></p>
<p><img src="image-20200112124331639.png" srcset="/img/loading.gif" alt="image-20200112124331639" style="zoom:40%;" /></p>
<h3 id="Tangential-Distortion"><a href="#Tangential-Distortion" class="headerlink" title="Tangential Distortion"></a>Tangential Distortion</h3><p>原因</p>
<blockquote>
<p>透镜平面和成像平面不平行引起的畸变</p>
</blockquote>
<h4 id="distortion-parameters"><a href="#distortion-parameters" class="headerlink" title="distortion parameters"></a>distortion parameters</h4><p>$(k_1,k_2,p_1,p_2,k_3)$</p>
<h3 id="外参"><a href="#外参" class="headerlink" title="外参"></a>外参</h3><p><img src="image-20200112130319485.png" srcset="/img/loading.gif" alt="image-20200112130319485"></p>
<p>二维旋转公式比较显然，三维怎么做呢？</p>
<p>先绕X轴旋转，这就相当于在YZ平面内绕原点旋转</p>
<p>然后分别绕Y轴,Z轴旋转。</p>
<p>这就得到了上图中$R_x(\psi), R_y(\varphi), R_z(\theta)$三个旋转矩阵</p>
<p>三个矩阵相乘$R_x(\psi)\cdot R_y(\varphi)\cdot R_z(\theta)$，就得到了最终的旋转矩阵</p>
<p>外参一共有6个$(\psi, \varphi,\theta,t_x,t_y,t_z)$前面三个是旋转参数，后面三个是平移参数</p>
<script type="math/tex; mode=display">\left[\begin{matrix}X\\Y\\Z\end{matrix}\right]=\left[\begin{matrix}R_{3\times 3}&t_{3\times 1}\\0_{1\times 3}&1\end{matrix}\right]\left[\begin{matrix}X_{world}\\Y_{world}\\Z_{world}\end{matrix}\right]</script><h3 id="画图展示内参、外参、畸变参数在成像各阶段中的角色"><a href="#画图展示内参、外参、畸变参数在成像各阶段中的角色" class="headerlink" title="画图展示内参、外参、畸变参数在成像各阶段中的角色"></a>画图展示内参、外参、畸变参数在成像各阶段中的角色</h3><p><img src="image-20200112124739443.png" srcset="/img/loading.gif" alt="image-20200112124739443" style="zoom:50%;" /></p>
<h2 id="D-相机定标-camera-calibration"><a href="#D-相机定标-camera-calibration" class="headerlink" title="D. 相机定标 camera calibration"></a>D. 相机定标 camera calibration</h2><p>Given N correspondences b/w scene and images</p>
<p>Recover the camera parameters</p>
<ul>
<li>Distortion coeffients畸变系数</li>
<li>内参</li>
<li>外参</li>
</ul>
<p><img src="image-20200112144807949.png" srcset="/img/loading.gif" alt="image-20200112144807949" style="zoom: 33%;" /></p>
<h4 id="解决这个问题的基本思想是什么"><a href="#解决这个问题的基本思想是什么" class="headerlink" title="解决这个问题的基本思想是什么"></a>解决这个问题的基本思想是什么</h4><p><img src="image-20200112145958831.png" srcset="/img/loading.gif" alt="image-20200112145958831" style="zoom:50%;" /></p>
<p><img src="image-20200112145742722.png" srcset="/img/loading.gif" alt="image-20200112145742722" style="zoom:40%;" /></p>
<script type="math/tex; mode=display">p_{dst}=Hp_{src}\;\;\;\; p_{src}=H^{-1}p_{dst}</script><p>一共有8个自由度</p>
<p>一个点有(x,y), x对应一个约束，y对应一个约束</p>
<p>求解至少需要4个特征点</p>
<p>Each view:</p>
<blockquote>
<p>Gives 8 equations, because a square can described by 4 points.</p>
</blockquote>
<p>？？？？？</p>
<h1 id="立体视觉"><a href="#立体视觉" class="headerlink" title="立体视觉"></a>立体视觉</h1><h2 id="A-立体视觉三角测量的基本原理"><a href="#A-立体视觉三角测量的基本原理" class="headerlink" title="A. 立体视觉三角测量的基本原理"></a>A. 立体视觉三角测量的基本原理</h2><p><img src="image-20191230163100997.png" srcset="/img/loading.gif" alt="image-20191230163100997" style="zoom:40%;" /></p>
<p><img src="image-20200111190444904.png" srcset="/img/loading.gif" alt="image-20200111190444904" style="zoom:30%;" /></p>
<p><a href="https://blog.csdn.net/Qzx9059/article/details/89204971" target="_blank" rel="noopener">https://blog.csdn.net/Qzx9059/article/details/89204971</a></p>
<p>$x^l$是在左眼坐标系下的坐标， $x^r$是在右眼坐标系下的坐标。向右👉是正方向，$x^r$应该是个负数</p>
<p>用相似做</p>
<p>$\frac{T-x^l+x^r}{Z-f}=\frac{T}{Z}\Rightarrow$</p>
<p>$Z=\frac{fT}{x^l-x^r}$</p>
<h2 id="B-立体视觉的基本步骤"><a href="#B-立体视觉的基本步骤" class="headerlink" title="B. 立体视觉的基本步骤"></a>B. 立体视觉的基本步骤</h2><ul>
<li><p>消除畸变</p>
</li>
<li><p>相机矫正(rectification)</p>
</li>
</ul>
<blockquote>
<p>根据对极几何，左右观测对于同一物体的投影处在同一水平线上</p>
<p>使左右观测所得图像行对齐</p>
</blockquote>
<p><img src="image-20200111192444640.png" srcset="/img/loading.gif" alt="image-20200111192444640" style="zoom:50%;" /></p>
<p><img src="image-20200111192500919.png" srcset="/img/loading.gif" alt="image-20200111192500919" style="zoom:50%;" /></p>
<ul>
<li>stereo matching </li>
</ul>
<blockquote>
<p>匹配：在1D的epipolar line直线上搜索匹配值函数的极值位置</p>
</blockquote>
<p><img src="image-20200111192802246.png" srcset="/img/loading.gif" alt="image-20200111192802246" style="zoom:50%;" /></p>
<div class="hljs"><pre><code class="hljs cpp">FOR each epipolar line
	FOR each pixel in the left image
		compare with every pixel on same epipolar line in right image
  	pick pixel with minimum match cost
		This will never work, so:</code></pre></div>
<ul>
<li>计算深度——Triangulation $Z=\frac{fT}{x^l-x^r}$</li>
</ul>
<h1 id="结构光三维成像原理"><a href="#结构光三维成像原理" class="headerlink" title="结构光三维成像原理"></a>结构光三维成像原理</h1><h2 id="A-结构光成像系统的构成"><a href="#A-结构光成像系统的构成" class="headerlink" title="A. 结构光成像系统的构成"></a>A. 结构光成像系统的构成</h2><ul>
<li><p>结构光投影仪</p>
</li>
<li><p>CCD相机</p>
</li>
<li>深度信息重建系统</li>
</ul>
<h2 id="B-利用结构光获取三位数据的基本原理"><a href="#B-利用结构光获取三位数据的基本原理" class="headerlink" title="B. 利用结构光获取三位数据的基本原理"></a>B. 利用结构光获取三位数据的基本原理</h2><p>一只眼睛一束光</p>
<p><img src="image-20191230182319140.png" srcset="/img/loading.gif" alt="image-20191230182319140" style="zoom:50%;" /></p>
<p>可以得到</p>
<p>$tan\theta=\frac{z}{b+x}$</p>
<p>根据三角形相似</p>
<p>$\frac{x}{x’}=\frac{(b+x)tan\theta}{f}$</p>
<p>解得：$x=\frac{b}{fcot\theta-x’}x’$</p>
<p><br/></p>
<h2 id="C-ICP-algorithm"><a href="#C-ICP-algorithm" class="headerlink" title="C. ICP algorithm"></a>C. ICP algorithm</h2><p><a href="https://www.zhihu.com/question/34170804/answer/121533317" target="_blank" rel="noopener">https://www.zhihu.com/question/34170804/answer/121533317</a></p>
<h3 id="要解决什么问题"><a href="#要解决什么问题" class="headerlink" title="要解决什么问题"></a>要解决什么问题</h3><blockquote>
<p>计算两组数据（两帧图像）间的旋转平移量，使之形成最佳匹配</p>
<p>registeration点云配准问题</p>
</blockquote>
<h3 id="基本步骤-2"><a href="#基本步骤-2" class="headerlink" title="基本步骤"></a>基本步骤</h3><p>输入：点集P, P’ 输出：最佳匹配的旋转平移量$R, t, s.t. \forall i, p_i=Rp_i’+t$</p>
<p>给定两个三维点集X与Y,将Y配准到X：</p>
<p>① 计算Y中的每一个点在X中的对应最近点</p>
<p>② 求使上述对应对点的平均距离最小的刚体变换，获得刚体变换参数（平移参数与旋转参数）；</p>
<p>③ 对Y应用上一步求得的刚体变换（平移与旋转），更新Y；</p>
<p>④ 如果X与Y的对应点对平均距离大于阈值，Goto ①，否则， 停止计算</p>
<h1 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h1><h2 id="1-Covariance"><a href="#1-Covariance" class="headerlink" title="1. Covariance"></a>1. Covariance</h2><p>考虑多维随机变量$\mathbf{x}=(x_1, x_2, \cdots, x_d)$</p>
<p>协方差定义为</p>
<p>$cov(x_i, x_j)=E{[x_i-E(x_i)][x_j-E(x_j)]}=E(x_ix_j)-E(x_i)E(x_j)$</p>
<h4 id="协方差的一些性质"><a href="#协方差的一些性质" class="headerlink" title="协方差的一些性质"></a>协方差的一些性质</h4><ul>
<li><p>Variance as a measure of the deviation from the mean for points in one dimension</p>
</li>
<li><p>Covariance from the mean as a measure of how much the dimensions vary with respect to each other </p>
</li>
<li><p>Covariance is a relationship between the 2 dimensions </p>
</li>
<li><p>The covariance between one dimension and itself is the variance </p>
</li>
</ul>
<h4 id="协方差的含义：符号"><a href="#协方差的含义：符号" class="headerlink" title="协方差的含义：符号"></a>协方差的含义：符号</h4><p>+: <strong><em>B<u>oth dimensions increase or decrease together</u></em></strong> e.g. as the number of hours studied increases, the marks in that subject increase.  </p>
<p>−: <strong><em><u>While one increases the other decreases</u></em></strong> , or vice-versa </p>
<p>0: <strong><em><u>No correlation</u></em></strong> of each other. e.g. heights of students vs the marks obtained in a subject </p>
<h3 id="协方差矩阵covariance-matrix"><a href="#协方差矩阵covariance-matrix" class="headerlink" title="协方差矩阵covariance matrix"></a>协方差矩阵covariance matrix</h3><script type="math/tex; mode=display">c=\left[\begin{matrix}cov(x,x)&cov(x,y)&cov(x,z)\\cov(y,x)&cov(y,y)&cov(y,z)\\cov(z,x)&cov(z,y)&cov(z,z)\end{matrix}\right]</script><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li>这是一个对称矩阵，因为$cov(x,y)=cov(y,x)$</li>
<li>对角线上就是方差</li>
</ul>
<h2 id="2-PCA-principal-component-analysis"><a href="#2-PCA-principal-component-analysis" class="headerlink" title="2. PCA principal component analysis"></a>2. PCA principal component analysis</h2><h2 id="A-基本思想，主要作用"><a href="#A-基本思想，主要作用" class="headerlink" title="A.基本思想，主要作用"></a>A.基本思想，主要作用</h2><p>用于数据降维和去噪。</p>
<p>选择一个新的坐标系进行线性降维，使得第一轴上是最大投影方向，第二轴上是第二大投影方向….以此类推</p>
<h2 id="B-什么样的数据用PCA会比较有效"><a href="#B-什么样的数据用PCA会比较有效" class="headerlink" title="B. 什么样的数据用PCA会比较有效"></a>B. 什么样的数据用PCA会比较有效</h2><blockquote>
<p>多元高斯分布</p>
<p>维度过高但高维信息量低，相关度高的数据</p>
</blockquote>
<h3 id="C-PCA中的一些定义"><a href="#C-PCA中的一些定义" class="headerlink" title="C. PCA中的一些定义"></a>C. PCA中的一些定义</h3><ul>
<li>d-维空间:$\mathbf{x}=(x_1,x_2,\cdots, x_d)$</li>
<li>投影方向:$a_1=(a_1^1,a_1^2,\cdots,a_1^d)$ 其中$a_1^Ta_1=1$</li>
<li>投影值: $z<em>1=a_1^tx=\sum</em>{i=1}^da_1^ix_i$</li>
<li>问题：<ul>
<li>最大化$var(z1)$</li>
<li>求投影方向$arg\;\underset{a}{max}\;var(z_1)$</li>
</ul>
</li>
</ul>
<h3 id="D-PCA求解"><a href="#D-PCA求解" class="headerlink" title="D. PCA求解"></a>D. PCA求解</h3><script type="math/tex; mode=display">\begin{aligned}var(z_1)&=E(z_1^2)-[E(z_1)]^2=E[(\sum_{i=1}^da_1^ix_i)^2]-[E(\sum_{i=1}^da_1^ix_i)]^2\\&=\sum_{i,j=1}^da_1^ia_1^jE(x_ix_j)-\sum_{i,j=1}^da_1^ia_1^jE(x_i)E(x_j)\\&=\sum_{i,j=1}^da_1^ia_1^j[E(x_ix_j)-E(x_i)E(x_j)]\\&=\sum_{i,j=1}^da_1^ia_1^jS_{ij}\quad\quad S_{ij}=E(x_ix_j)-E(x_i)E(x_j)\\&=a_1^TSa_1\quad\quad cov(x_i,x_j)=E(x_ix_j)-E(x_i)E(x_j)\end{aligned}</script><p>我们要最大化$var(z_1)=a_1^TSa_1$  subject to $a_1^Ta_1=1$</p>
<p>可以用拉格朗日乘子法，设$\lambda$为拉格朗日乘子，则转为最大化</p>
<p>$a_1^TSa_1-\lambda(a_1^Ta_1-1)$</p>
<p>对$a_1^T$求微分，得必要条件$Sa_1-\lambda a_1=0\Rightarrow Sa_1=\lambda a_1$</p>
<p>因此</p>
<script type="math/tex; mode=display">var(z_1)=a_1^TSa_1=a_1^T\lambda a_1=\lambda a_1^Ta_1=\lambda</script><p>为了使$var(z_1)$取得最大值，必须用最大特征值对应的特征向量! </p>
<h2 id="Eigenface"><a href="#Eigenface" class="headerlink" title="Eigenface"></a>Eigenface</h2><h3 id="Eigenface是什么"><a href="#Eigenface是什么" class="headerlink" title="Eigenface是什么"></a>Eigenface是什么</h3><blockquote>
<p>使用特征脸进行人脸识别的方法</p>
</blockquote>
<p><img src="image-20191230191544548.png" srcset="/img/loading.gif" alt="image-20191230191544548" style="zoom:50%;" /></p>
<p>步骤</p>
<ul>
<li><p>获得人脸图像的训练集，通常为整个人脸数据库</p>
</li>
<li><p>预处理：确定模版，根据人脸两只眼睛的中心位置，缩放平移旋转，使得所有训练人脸图像与模板对其，根据模版，且出脸部区域。对所有人脸图像做灰度值归一化处理</p>
<p><img src="image-20191230192212662.png" srcset="/img/loading.gif" alt="image-20191230192212662" style="zoom:30%;" /></p>
<p><img src="image-20191230192248291.png" srcset="/img/loading.gif" alt="image-20191230192248291" style="zoom:30%;" /></p>
</li>
<li><p>通过PCA计算获得一组特征向量（特征脸）。通常一百个特征向量就足够</p>
</li>
<li><p>将每幅人脸图像都投影到由该特征脸张成的子空间中，得到在该子空间坐标</p>
</li>
<li><p>对输入的一幅待测图像，归一化后，将其映射到特征脸子空间中。然后用某种距离度量来描述两幅人脸图像的相似性，如欧式距离。</p>
</li>
</ul>
<h3 id="将重构用于人脸检测的原理"><a href="#将重构用于人脸检测的原理" class="headerlink" title="将重构用于人脸检测的原理"></a>将重构用于人脸检测的原理</h3><blockquote>
<p>对于任意待识别样本识别 f </p>
<p>人脸投影到特征人脸空间中，保留了主要特征的信息，所以可以恢复人脸本来的样子</p>
<p>$y_f=A^Tf$    这里的$A^T$是一个将图像投影到特征脸张成空间的转换矩阵</p>
<p>$\hat{f}=Ay_f$     个人觉得$A^T=A^{-1}$，相当于做了一个逆变换</p>
</blockquote>
<h1 id="图像频域与图像分解"><a href="#图像频域与图像分解" class="headerlink" title="图像频域与图像分解"></a>图像频域与图像分解</h1><h2 id="图像的傅立叶变换"><a href="#图像的傅立叶变换" class="headerlink" title="图像的傅立叶变换"></a>图像的傅立叶变换</h2><h3 id="理解变换的基本含义"><a href="#理解变换的基本含义" class="headerlink" title="理解变换的基本含义"></a>理解变换的基本含义</h3><blockquote>
<p>傅里叶变换讲的是任何信号（如图像信号）都可以表示成一系列正弦信号的叠加，在图像领域就是将图像brightness variation 作为正弦变量。傅里叶变化储存每一个频率的magnitude和phase信息，前者代表这个频率上有多少信号，后者间接可代表空间信息。 </p>
</blockquote>
<h3 id="理解图像的低频成分和高频成分"><a href="#理解图像的低频成分和高频成分" class="headerlink" title="理解图像的低频成分和高频成分"></a>理解图像的低频成分和高频成分</h3><blockquote>
<ul>
<li>图像的高频部分是像素值变化剧烈的地方，如图像的边缘和轮廓。</li>
<li>低频部分是变化不剧烈的地方，对应大的色块。</li>
</ul>
<p>我们从近处看图像看到的是高频信息，而远处看到的是低频信息 </p>
</blockquote>
<h2 id="图像分解"><a href="#图像分解" class="headerlink" title="图像分解"></a>图像分解</h2><h3 id="从图像分解角度，理解傅立叶变换的意义"><a href="#从图像分解角度，理解傅立叶变换的意义" class="headerlink" title="从图像分解角度，理解傅立叶变换的意义"></a>从图像分解角度，理解傅立叶变换的意义</h3><blockquote>
<p>$\sum基图像$</p>
</blockquote>
<h3 id="怎么理解拉普拉斯图像金字塔的每一层是带通滤波"><a href="#怎么理解拉普拉斯图像金字塔的每一层是带通滤波" class="headerlink" title="怎么理解拉普拉斯图像金字塔的每一层是带通滤波"></a>怎么理解拉普拉斯图像金字塔的每一层是带通滤波</h3><blockquote>
<p>拉普拉斯金字塔是通过源图像减去先缩小再放大的一系列图像构成的。<strong>下采样的时候丢失了高频信息，而相邻金字塔相减的时候丢失了低频信息，因此只有中间频段的信息保留了下来</strong></p>
<ul>
<li>带通滤波应该是指中间频率通过</li>
<li>低通滤波应该是低频通过</li>
</ul>
</blockquote>
<h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><h2 id="A-基于k-means聚类的图像分割"><a href="#A-基于k-means聚类的图像分割" class="headerlink" title="A. 基于k-means聚类的图像分割"></a>A. 基于k-means聚类的图像分割</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><blockquote>
<p>基于区域间的不连续性(不同区域间)和相似性(同一区域内)</p>
<p>已知观测集$(x<em>{1},x</em>{2},…,x<em>{n})$，其中每个观测都是一个d-维实向量，<em>k</em>-平均聚类要把这n个观测划分到<em>k</em>个集合中(k≤n),使得组内平方和（WCSS within-cluster sum of squares）最小。换句话说，它的目标是找到使得下式满足的聚类$S</em>{i}$</p>
<script type="math/tex; mode=display">arg\underset{s}{min}\underset{i=1}{\overset{k}{\sum}}\underset{x\in S_i}{\sum}\Vert{\mathbf{x}-\mathbf{u_i}}\Vert^2</script><p>其中$\mu <em>{i}$是$S</em>{i}$中所有点的均值</p>
<p><strong>总之：思想是最小化类内距离平方之和</strong></p>
</blockquote>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><img src="image-20200111182152756.png" srcset="/img/loading.gif" alt="image-20200111182152756" style="zoom:50%;" /></p>
<blockquote>
<ol>
<li>随机选择K个聚类中心$c^0$</li>
<li>对图像上所有点，根据其与聚类中心的距离，将其划分到距离最近对应的中心的聚类簇</li>
<li>重新计算每一簇的均值来更新中心（簇内均值）</li>
<li>重复2，3步，直到no points are re-assigned</li>
</ol>
</blockquote>
<h3 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h3><ul>
<li><p>Simple and fast</p>
</li>
<li><p>Easy to implement</p>
</li>
</ul>
<p>Cons</p>
<ul>
<li>Need to choose K </li>
<li><u>Sensitive to outliers</u></li>
</ul>
<p>Usage</p>
<ul>
<li>Rarely used for pixel segmentation</li>
</ul>
<h2 id="B-基于Mean-Shift的图像分割"><a href="#B-基于Mean-Shift的图像分割" class="headerlink" title="B. 基于Mean Shift的图像分割"></a>B. 基于Mean Shift的图像分割</h2><h3 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h3><blockquote>
<p>将聚类看作密度的局部最大值</p>
</blockquote>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><blockquote>
<ol>
<li>Choose kernel and bandwidth</li>
<li><p>For each point</p>
<ul>
<li>center a window on that point</li>
<li>compute the mean of the data in the search window</li>
<li>center the search window at the new mean location</li>
<li>Repeat (b, c) until convergence</li>
</ul>
</li>
<li><p>Assign points that lead to nearby modes to the same cluster</p>
</li>
</ol>
</blockquote>
<h3 id="Pros-1"><a href="#Pros-1" class="headerlink" title="Pros"></a>Pros</h3><ul>
<li><p>Good general-purpose segmentation</p>
</li>
<li><p>Flexible in number and shape of regions</p>
</li>
<li><p><u>Robust to outliers</u></p>
</li>
</ul>
<h3 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h3><ul>
<li>Have to choose kernel size in advance</li>
<li>Not suitable for high-dimensional features</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/19/xv6-lab3/">
                        <span class="hidden-mobile">page tables [os lab3]</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer>
  (function () {
    // 查询存储的记录
    function getRecord(Counter, target) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {target, time: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    }

    // 发起自增请求
    function increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    }

    // 构建自增请求体
    function buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "time": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    }

    // 校验是否为有效的 UV
    function validUV() {
      var key = 'LeanCloud_UV_Flag';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    }

    function addCount(Counter) {
      var enableIncr = 'true' === 'true' && window.location.hostname !== 'localhost';
      var getterArr = [];
      var incrArr = [];

      // 请求 PV 并自增
      var pvCtn = document.querySelector('#leancloud-site-pv-container');
      if (pvCtn || enableIncr) {
        var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
          incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-pv');
          if (ele) {
            ele.innerText = record.time + 1;
            if (pvCtn) {
              pvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#leancloud-site-uv-container');
      if (uvCtn || enableIncr) {
        var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
          var vuv = validUV();
          vuv && incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-uv');
          if (ele) {
            ele.innerText = record.time + (vuv ? 1 : 0);
            if (uvCtn) {
              uvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(uvGetter);
      }

      // 如果是文章，请求文章的浏览数，并自增
      if ('true' === 'true') {
        var viewCtn = document.querySelector('#leancloud-post-views-container');
        if (viewCtn || enableIncr) {
          var target = decodeURI('/2021/01/17/cvreview/');
          var viewGetter = getRecord(Counter, target).then((record) => {
            incrArr.push(buildIncrement(record.objectId))
            if (viewCtn) {
              var ele = document.querySelector('#leancloud-post-views');
              if (ele) {
                ele.innerText = (record.time || 0) + 1;
                viewCtn.style.display = 'inline';
              }
            }
          });
          getterArr.push(viewGetter);
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && increment(Counter, incrArr);
        })
      }
    }

    var app_id = '6ojk1lVz9eq7GQnBo6Q8zR5d-gzGzoHsz'
    var app_key = 'bOrBPlujAz77Ma6N5tY9wWJN'
    var server_url = ''

    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': app_id,
            'X-LC-Key': app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };

      addCount(Counter);
    }

    var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(resp => resp.json())
        .then(({api_server}) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>






  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "CV Couse Review&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  










  <script  src="https://cdn.staticfile.org/mermaid/8.5.0/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  

  

  

  

  

  

  





</body>
</html>
