<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Factory Method 工厂模式</title>
    <link href="/2020/08/14/FactoryMethod/"/>
    <url>/2020/08/14/FactoryMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="Factory-Method属于对象创建模式"><a href="#Factory-Method属于对象创建模式" class="headerlink" title="Factory Method属于对象创建模式"></a>Factory Method属于对象创建模式</h2><p>通过对象创建模式绕开<code>new</code>, 来避免对象创建 (<code>new</code>) 过程中所导致的紧耦合(依赖具体类 )，从而支持对象创建的稳定。他是接口抽象之后的第一步工作。</p><p>典型模式有</p><ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化， 需要创建的对象的具体类型经常变化。</p><p>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种”封装机制”来避免客户程序和这种”具体对象创建工作”的紧耦合？</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使得一个类的实例化延迟（目的：解耦， 手段：虚函数）到子类。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>初始代码，一个文件分割器。</p><p>这个代码会有什么问题呢？要从变化的场景去看。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;FileSplitter* splitter = <span class="hljs-keyword">new</span> FileSplitter();        splitter-&gt;split;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSpitter</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>最开始我们讲过一个原则：面向接口的编程。一个对象的类型应该声明成抽象类或者接口，而不应该声明成具体的类。如果声明成具体的类，就把他定死了，无法应对未来的变化。</p><p>假设我们产生了新的需求：</p><p>需要支持二进制文件，txt文件，图片文件，视频文件的分割</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span> &#123;</span> <span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~ISplitter() &#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySpliter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;  &#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">/*******************问题产生了******************/</span>ISplitter* splitter = <span class="hljs-keyword">new</span> BinarySplitter(); <span class="hljs-comment">//??????怎么又依赖细节了？？？</span>        splitter-&gt;split;    &#125;&#125;</code></pre></div><div class="note note-warning">            <p><code>new</code>不能new抽象类，<code>new</code>只能new具体类。但是我们需要的是多态<code>new</code>。怎么解决呢？</p>          </div><ul><li>开始重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//return new ISplitter(...);//这样也是不对的，因为不能new抽象类</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BinarySplitter();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span> &#123;</span> <span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~ISplitter() &#123;&#125;&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;SplitterFactory factory;ISplitter* splitter = factory.CreateSplitter();        splitter-&gt;split;    &#125;&#125;</code></pre></div><p>但是这种实现根本没有解决问题，<code>ISplitter* splitter = factory.CreateSplitter();</code>依然依赖于具体的类BinarySplitter</p><ul><li>继续重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//抽象类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~ISplitter() &#123;&#125;&#125;;<span class="hljs-comment">//工厂基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~SplitterFactory()&#123;&#125;    &#125;&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;SplitterFactory* factory;<span class="hljs-comment">//多态了</span>ISplitter* splitter = factory-&gt;CreateSplitter();        splitter-&gt;split;    &#125;&#125;</code></pre></div><ul><li>继续完善</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//具体类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySpliter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;  &#125;;<span class="hljs-comment">//具体工厂</span>BinarySplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BinarySplitter();    &#125;&#125;;TxtSplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TxtSplitter();    &#125;&#125;;PictureSplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PictureSplitter();    &#125;&#125;;VideoSplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VideoSplitter();    &#125;&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    SplitterFactory* factory;<span class="hljs-keyword">public</span>:    MainForm(SplitterFactory* factory) &#123;        <span class="hljs-keyword">this</span>-&gt;factory = factory;    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//多态new</span>ISplitter* splitter = factory-&gt;CreateSplitter();        splitter-&gt;split;    &#125;&#125;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200814150354579.png" srcset="/img/loading.gif" alt="image-20200814150354579" style="zoom:50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导 致软件的脆弱。</p></li><li><p>Factory Method模式通过面向对象的手法，将所要创建的具体对 象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。</p></li><li><p>Factory Method模式解决”单个对象”的需求变化。缺点在于要求创建方法/参数相同。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bridge 桥模式</title>
    <link href="/2020/08/11/DesignPatterns/Bridge/"/>
    <url>/2020/08/11/DesignPatterns/Bridge/</url>
    
    <content type="html"><![CDATA[<h2 id="Bridge属于”单一职责”模式"><a href="#Bridge属于”单一职责”模式" class="headerlink" title="Bridge属于”单一职责”模式"></a>Bridge属于”单一职责”模式</h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码， 这时候的关键是划清责任。</p><ul><li><p>典型模式</p><p>• Decorator</p><p>• Bridge</p></li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>由于某些类型的固有的实现逻辑，使得它们具有<u>两个变化的维度， 乃至多个纬度</u>的变化。</p><p>如何应对这种”多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>将抽象部分(业务功能)与实现部分(平台实现)分离，使他们都可以独立地变化</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>一个通信模块Messager。根据平台分为PC, Mobile，派生出两个子类PCMessagerBase, MobileMessagerBase。根据业务分成perfect和lite, 前面的两个子类又派生出PCMessagerLite, PCMessagerPerfect, MobileMessagerLite, MobileMessagerPerfect.</p><p>如果设平台有n中选择，业务有m中，那么类的数目为$1 + n + m * n$</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Message() &#123;&#125;&#125;<span class="hljs-comment">//平台实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;; <span class="hljs-comment">//业务抽象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerLite</span>:</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        PCMessagerBase::Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        PCMessagerBase::WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        PCMessagerBase::DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerPerfect</span>:</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;PCMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        PCMessagerBase::Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;PCMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        PCMessagerBase::WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        PCMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        PCMessagerBase::DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerLite</span>:</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        MobileMessagerBase::Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        MobileMessagerBase::WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        MobileMessagerBase::DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerPerfect</span>:</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;MobileMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        MobileMessagerBase::Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;MobileMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        MobileMessagerBase::WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        MobileMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        MobileMessagerBase::DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;</code></pre></div><p>但是这样设置的类有很多的结构性重复。比如PCMessagerPerfect, MobileMessagerPerfect。</p><ul><li>重构</li></ul><p>将PCMessagerLite, PCMessagerPerfect, MobileMessagerLite, MobileMessagerPerfect的继承改为组合。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Message() &#123;&#125;&#125;<span class="hljs-comment">//平台实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;; <span class="hljs-comment">//业务抽象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerLite</span> &#123;</span>    Messager* messager;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        messager-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        messager-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        messager-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerPerfect</span> &#123;</span>    Messager* messager;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;messager-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messager-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;messager-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messager-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;       messager-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messager-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;</code></pre></div><p>注意，这样修改之后并不是完整的，因为MessagerLite和MessagerPerfect没有了PlaySound, Connect…这些函数</p><ul><li>继续重构</li></ul><p>可以看到平台类在重载PlaySound, PlaySound, WriteText, Connect这几个函数。而业务类在重载Login, SendMessage, SendPicture这几个函数。因此把这两块函数放在一个类里面是不合适的，我们把他们拆分成两个类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Message() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerImp</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~MessageImp() &#123;&#125;&#125;<span class="hljs-comment">//平台实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span>:</span> <span class="hljs-keyword">public</span> MessagerImp &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span>:</span> <span class="hljs-keyword">public</span> MessagerImp &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;; <span class="hljs-comment">//业务抽象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerLite</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;    MessagerImp* messagerImp;<span class="hljs-comment">//...</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        messagerImp-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        messagerImp-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        messagerImp-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerPerfect</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;    MessagerImp* messagerImp;<span class="hljs-comment">//...</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;       messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;</code></pre></div><ul><li>再重构</li></ul><p>可以看到MessageLite和MessagerPerfect这两个类里面都有MessagerImp字段。根据重构的原则，应该将他往上提到Messager类中。</p><p>最终类的数目编程$1+n+m$</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span> &#123;</span><span class="hljs-keyword">protected</span>:    MessagerImp* messagerImp;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Message() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerImp</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~MessageImp() &#123;&#125;&#125;<span class="hljs-comment">//平台实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span>:</span> <span class="hljs-keyword">public</span> MessagerImp &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span>:</span> <span class="hljs-keyword">public</span> MessagerImp &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;; <span class="hljs-comment">//业务抽象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerLite</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        messagerImp-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        messagerImp-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        messagerImp-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerPerfect</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;       messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200811150059187.png" srcset="/img/loading.gif" alt="image-20200811150059187" style="zoom:50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Bridge模式使用”对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓 抽象和实现沿着各自纬度的变化，即”子类化”它们。</p></li><li><p>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。 Bridge模式是比多继承方案更好的解决方法。</p></li><li><p>Bridge模式的应用一般在”两个非常强的变化维度”，有时一个 类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资本论读书摘抄</title>
    <link href="/2020/08/09/Capital/"/>
    <url>/2020/08/09/Capital/</url>
    
    <content type="html"><![CDATA[<h1 id="2020-08-09"><a href="#2020-08-09" class="headerlink" title="2020-08-09"></a>2020-08-09</h1><h4 id="商品-第一卷第一章"><a href="#商品-第一卷第一章" class="headerlink" title="商品 第一卷第一章"></a>商品 第一卷第一章</h4><ul><li><p>商品的两个因素: 使用价值和价值</p></li><li><p>物的有用性成为使用价值。服务是具有使用价值的。</p></li><li><p>由于使用价值才是构成一个社会的财富的物质内容，因此，股票市场的涨跌并不代表一个社会的财富的增加或减少</p></li><li><p>交换价值首先表现为一种使用价值同另一种使用价值相交换的量的关系或比例。</p></li><li><p>由于交换是一个私人劳动向社会劳动的转变过程，这个过程中存在一定的随机性，因此交换价值具有一定的偶然性。但这种偶然性中包含必然性。用马克思身后才发展起来的概率论的术语来说，一个商品或一个使用价值在不同的时间和地点进行交换时，其交换价值是一个随机变量，但这个随机变量有一个确定的，并非偶然的和纯粹相对的期望值，这个期望值就是商品固有的，内在的交换价值。</p></li><li><p>现代庸俗经济学用供求关系和效用来解释交换价值的形成。实际上供求关系和效用只能解释交换价值的随机部分，而不能解释交换价值内在的期望值。按现代庸俗经济学的解释，之所以1夸特小麦=a吨铁，是因为这两者带给交易者的边际效用是相同的。由于边际效用纯属个人的主观感受，因此，如果市场上都按上式进行交易，那就意味着所有的交易者的主观感受完全一致，用概率论的术语说，既然每个人的主观感觉是无限的或是可以无限细分的，因此，发生这种情况的概率为零，即它是几乎不可能的。于是，如果我们观察到某个市场上的交易都在或大多数都在按同一等式进行交换时，效用论要么破产，要么需要假定存在一个不以个人意志为转移的效用期望值，而分析这个期望值是如何存在的，就不得不回到劳动价值学说。</p></li><li><p>商品的交换价值是由外部的别的东西来度量的，而商品的价值则是它本身单纯凝结的人类劳动，后文说明它是由所凝固的劳动时间来度量的。这两个价值的度量单位是不同的。这种不同决定了，在一定的条件下，尤其是资本主义条件下，商品的交换价值与商品的价值是相背离的。</p></li><li><p>劳动与生产资料共同创造财富。社会主义并不反对资本，(资本分为预付来购买生产资料的不变资本和预付来购买劳动的可变资本。但由于现在资本家往往正如马克思在《资本论》中将要指出的那样，并不预购劳动，而是让工人先提供(预付)劳动，再从工人劳动创造的价值中，取出一部分来作为报酬支付给工人。即，资本家往往只需预付不变资本(单个资本家可以贷款或赊欠来一部分不变资本，但这些资本还是来自于资本家，货币资本家)，通过赊欠可变资本，进行生产。所以这里将代表生产资料的不变资本，简称为资本。)而是反对资本与劳动的人为脱节，反对有人通过垄断资本而不劳而获、骄奢淫逸；反对有劳动能力的劳动者为了获得与资本相结合的机会而被迫过着辛劳而悲惨的生活。</p></li><li><p>有人认为，工人的工资是固定的，资本家的利润是不固定的。所以，资本家承担了生产经营过程中的风险，而工人不承担风险，所以资本家应当获得与其所承担的风险相应的剥削收入。但是，一方面，资本家的所得大大超过他所承担的风险；另一方面，工人的劳动是预付的，同样存在风险。被拖欠和无端克扣工资的事经常发生，而且拖欠的工资即使发还也往往是不付利息的。至于最后工资完全泡汤的事也不是没有发生过，部分泡汤的就更多。即使有工资，有时还不够用来治疗职业病。而且资本家的风险是他自己造成的，由他自己负责；而工人的风险则是由资本家造成的，资本家反而应当因此对工人进行补偿。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Decorator</title>
    <link href="/2020/08/07/DesignPatterns/Decorator/"/>
    <url>/2020/08/07/DesignPatterns/Decorator/</url>
    
    <content type="html"><![CDATA[<h2 id="Decorator属于”单一职责”模式"><a href="#Decorator属于”单一职责”模式" class="headerlink" title="Decorator属于”单一职责”模式"></a>Decorator属于”单一职责”模式</h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码， 这时候的关键是划清责任。</p><ul><li><p>典型模式</p><p>• Decorator</p><p>• Bridge</p></li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在某些情况下我们可能会”过度地使用继承来扩展对象的功能”， 由于继承为类型引入的<strong>静态特质</strong>，使得这种扩展方式缺乏灵活性； 并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</p><p>如何使”对象功能的扩展”能够根据需要来动态地实现？同时避免”扩展功能的增多”带来的子类膨胀问题？从而使得任何”功能扩展变化”所导致的影响将为最低？</p><p>所谓静态特质, 比如在CryptoNetworkStream的Read函数中定死了调用NetworkStream::Read(), 而我们重构后的CryptoStream中的Read函数调用stream-&gt;Read(), 支持多态，可以产生变化。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面给出一个Stream代码示例，其继承关系如下所示</p><p><img src="image-20200807143722316.png" srcset="/img/loading.gif" alt="image-20200807143722316" style="zoom:30%;" /></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//业务操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stream</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Stream() &#123;&#125;&#125;;<span class="hljs-comment">//主体类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读文件流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位文件流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写文件流</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读网络流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位网络流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写网络流</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读内存流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位内存流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写内存流</span>    &#125;&#125;;<span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoNetworkStream</span>:</span> <span class="hljs-keyword">public</span> NetworkStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoMemoryStream</span>:</span> <span class="hljs-keyword">public</span> MemoryStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedNetworkStream</span>:</span> <span class="hljs-keyword">public</span> NetworkStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedMemoryStream</span>:</span> <span class="hljs-keyword">public</span> MemoryStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoBufferedFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Read(number);<span class="hljs-comment">//读文件流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Seek(position);<span class="hljs-comment">//定位文件流</span>        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Write(position);<span class="hljs-comment">//写文件流</span>        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//编译时装配</span>    CryptoFileStream* fs1 = <span class="hljs-keyword">new</span> CryptoFileStream();        BufferedFileStream* fs2 = <span class="hljs-keyword">new</span> BufferedFileStream();        CryptoBufferedFileStream* fs3 = <span class="hljs-keyword">new</span> CryptoBufferedFileStream();&#125;</code></pre></div><p>这样设计的代码存在大量的冗余，比如对于不同的stream, 无论是FileStream还是NetworkStream还是MemoryStream, 他们的加密操作都是一样的。</p><ul><li>重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoFileStream</span> &#123;</span>    FileStream* stream;<span class="hljs-comment">//=new FileStream()</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoNetworkStream</span> &#123;</span>    NetworkStream* stream;<span class="hljs-comment">//=new NetworkStream();</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoMemoryStream</span> &#123;</span>    MemoryStream* stream;<span class="hljs-comment">//=new MemoryStream();</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;</code></pre></div><ul><li>继续重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;    Stream* stream;<span class="hljs-comment">//...</span><span class="hljs-keyword">public</span>:    CryptoStream(Stream* stm): stream(stm) &#123;            &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;    Stream* stream; <span class="hljs-comment">//...</span>    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//运行时装配</span>    FileStream* s1 = <span class="hljs-keyword">new</span> FileStream();    CryptoStream* s2 = <span class="hljs-keyword">new</span> CryptoStream(s1);    BufferedStream* s3 = <span class="hljs-keyword">new</span> BufferedStream(s1);    BufferedStream* s4 = <span class="hljs-keyword">new</span> BufferedStream(s2);&#125;</code></pre></div><p>很神奇，CryptoStream既有Stream基类，也有Stream字段。这里还需要继承Stream是因为他定义了基类的接口规范</p><ul><li>继续重构</li></ul><p>CryptoStream, BufferedStream都有Stream这个字段，把他们提到一个中间类中，</p><p>设置一个DecoratorStream中间类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoratorStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">protected</span>:    Stream* stream; <span class="hljs-comment">//...</span>    DecoratorStream(Stream* stm): DecoratorStream(stm) &#123;            &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> DecoratorStream &#123;<span class="hljs-keyword">public</span>:    CryptoStream(Stream* stm): DecoratorStream(stm) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span>:</span> <span class="hljs-keyword">public</span> DecoratorStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//运行时装配</span>    FileStream* s1 = <span class="hljs-keyword">new</span> FileStream();    CryptoStream* s2 = <span class="hljs-keyword">new</span> CryptoStream(s1);    BufferedStream* s3 = <span class="hljs-keyword">new</span> BufferedStream(s1);    BufferedStream* s4 = <span class="hljs-keyword">new</span> BufferedStream(s2);&#125;</code></pre></div><p>新的类关系</p><p><img src="image-20200807143823919.png" srcset="/img/loading.gif" alt="image-20200807143823919" style="zoom:30%;" /></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200807160507597.png" srcset="/img/loading.gif" alt="image-20200807160507597" style="zoom:50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免 了使用继承带来的”灵活性差”和”多子类衍生问题”。</p></li><li><p>Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又 表现为has-a Component的组合关系，即Decorator类又使用了 另外一个Component类。</p></li><li><p>Decorator模式的目的并非解决”多子类衍生的多继承”问题，Decorator模式应用的要点在于解决”主体类在多个方向上的扩展 功能”——是为”装饰”的含义。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="/2020/08/06/DesignPatterns/Principle/"/>
    <url>/2020/08/06/DesignPatterns/Principle/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>变化是复用的天敌！ 面向对象设计最大的优势在于：<u><strong><em>抵御变化</em></strong></u></p>          </div><h4 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 (DIP)"></a>依赖倒置原则 (DIP)</h4><ul><li><p>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。</p></li><li><p>抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。</p></li></ul><p><br></p><h4 id="开放封闭原则-OCP"><a href="#开放封闭原则-OCP" class="headerlink" title="开放封闭原则 (OCP)"></a>开放封闭原则 (OCP)</h4><ul><li><p>对扩展开放，对更改封闭。</p></li><li><p>类模块应该是可扩展的，但是不可修改。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Observer 观察者模式</title>
    <link href="/2020/08/06/DesignPatterns/Observer/"/>
    <url>/2020/08/06/DesignPatterns/Observer/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，我们需要为某些对象建立一种”通知依赖关系” </p><p><u>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密， 将使软件不能很好地抵御变化</u>。</p><p>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>定义对象间的一种<u><strong><em>一对多</em></strong></u>（变化）的依赖关系，以便当一个 对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并<u><strong><em>自动更新</em></strong></u>。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>考虑一个文件分割器程序，将一个大文件分割成几个小文件。</p><p>我们有一个主界面MainForm (在这里是一个观察者), 里面有两个对象，一个是文件路径，一个是分割成的文件都个数。当button click时就会调用filesplitter将文件分割</p><p>代码如下</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;<span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber):    m_filePath(filePath),    m_fileNumber(fileNumber) &#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>        &#125;    &#125;&#125;</code></pre></div><h4 id="需求1：文件分割进度条"><a href="#需求1：文件分割进度条" class="headerlink" title="需求1：文件分割进度条"></a>需求1：文件分割进度条</h4><ul><li>第一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;<span class="hljs-comment">/***增加progress bar***/</span>    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;<span class="hljs-comment">/***增加progres bar***/</span>    ProgressBar* m_progressBar;<span class="hljs-keyword">public</span>:<span class="hljs-comment">/***增加初始化参数***/</span>    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, ProgressBar* progressBar):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_progressBar(progressBar)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span><span class="hljs-comment">/***更新progress bar***/</span>            <span class="hljs-keyword">if</span>(m_progressBar != <span class="hljs-literal">NULL</span>) &#123;                m_progressBar-&gt;setValue((i + <span class="hljs-number">1</span>) / m_fileNumber);            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="note note-warning">            <p>但是这种实现方式违反了<u>依赖倒置原则</u>。FileSplitter依赖ProgressBar 这样一种具体的实现细节，但是进度条的种类和展现形式是变化的，如果我们想将进度条换一种展现形式，比如不断打点，那么就会面临需求变更的困扰。</p>          </div><ul><li>第二种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    <span class="hljs-comment">//ProgressBar* m_progressBar; 这是一个通知控件</span>    IProgress* m_iprogress; <span class="hljs-comment">//抽象通知机制</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, IProgress* iprogress):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_iprogress(iprogress)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">if</span>(m_iprogress != <span class="hljs-literal">NULL</span>) &#123;                <span class="hljs-keyword">float</span> progressValue = m_fileNumber;                progressValue = (i + <span class="hljs-number">1</span>) / progressValue;                m_iprogress-&gt;DoProgress(progressValue); <span class="hljs-comment">//更新进度条</span>            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress&#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressbar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        progressBar-&gt;setValue(value);    &#125;&#125;</code></pre></div><p>C++支持多继承，但是不推荐使用多继承，因为会带来很多耦合的问题。但是有一种情况是推荐使用多继承的，一个主的继承类，其他都是接口  (单继承多实现), 这里就属于这种情况</p><ul><li>再修改一下</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    <span class="hljs-comment">//ProgressBar* m_progressBar; 这是一个通知控件</span>    IProgress* m_iprogress; <span class="hljs-comment">//抽象通知机制</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, IProgress* iprogress):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_iprogress(iprogress)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">float</span> progressValue = m_fileNumber;            progressValue = (i + <span class="hljs-number">1</span>) / progressValue;            onProgress(progressValue);        &#125;    &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span>(m_iprogress != <span class="hljs-literal">NULL</span>) &#123;        m_iprogress-&gt;DoProgress(value);<span class="hljs-comment">//更新进度条</span>        &#125;    &#125;&#125;</code></pre></div><h4 id="需求2-多观察者"><a href="#需求2-多观察者" class="headerlink" title="需求2: 多观察者"></a>需求2: 多观察者</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    List&lt;IProgress*&gt; m_iprogressList; <span class="hljs-comment">//抽象通知机制, 支持多个观察者</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber):    m_filePath(filePath),    m_fileNumber(fileNumber) &#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIProgress</span><span class="hljs-params">(IProgress* iprogress)</span> </span>&#123;        m_iprogressList.add(iprogress);    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeIProgress</span><span class="hljs-params">(IProgress* iprogress)</span> </span>&#123;        m_iprogressList.remove(iprogress);    &#125;            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">float</span> progressValue = m_fileNumber;            progressValue = (i + <span class="hljs-number">1</span>) / progressValue;            onProgress(progressValue);        &#125;    &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        List&lt;IProgress*&gt;::iterator it = m_iprogressList.begin();        <span class="hljs-keyword">while</span>(it != m_iprogressList.end()) &#123;            (*it)-&gt;DoProgress(value);            it++;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress&#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressbar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                ConsoleNotifier cn;        <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;                splitter.addIprogress(<span class="hljs-keyword">this</span>);        splitter.addIprogress(&amp;cn);                splitter.split();    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        progressBar-&gt;setValue(value);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleNotifier</span>:</span> <span class="hljs-keyword">public</span> IProgress &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"."</span>;    &#125;&#125;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200806160700160.png" srcset="/img/loading.gif" alt="image-20200806160700160" style="zoom: 50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。 </p></li><li><p>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。</p></li><li><p>观察者自己决定是否需要订阅通知，目标对象对此一无所知。 </p></li><li>Observer模式是基于事件的UI框架中非常常用的设计模式，也是 MVC模式的一个重要组成部分。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Template Method</title>
    <link href="/2020/08/05/DesignPatterns/TemplateMethod/"/>
    <url>/2020/08/05/DesignPatterns/TemplateMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因 （比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p><p>核心在于在稳定与变化之间求得一个平衡，如果全部稳定或者全部变化都是不需要设计模式的。</p><p>如何在确定<strong>稳定操作结构</strong>的前提下，来灵活应对<strong>各个子步骤的变化</strong>或者<strong>晚期实现需求</strong>？</p><p>假设整个代码的操作结构如下图所示，其中红色是Library开发人员完成的，蓝色部分是Application开发人员完成的</p><p><img src="image-20200710191024075.png" srcset="/img/loading.gif" alt="image-20200710191024075" style="zoom:33%;" /></p><h2 id="结构化软件流程设计"><a href="#结构化软件流程设计" class="headerlink" title="结构化软件流程设计"></a>结构化软件流程设计</h2><p><img src="image-20200710191212499.png" srcset="/img/loading.gif" alt="image-20200710191212499" style="zoom:50%;" /></p><p>lib.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>app.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//应用程序开发人员</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>主程序</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Library <span class="hljs-title">lib</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Application <span class="hljs-title">app</span><span class="hljs-params">()</span></span>;        lib.Step1();        <span class="hljs-keyword">if</span>(app.Step2()) &#123;        lib.Step3();    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;        app.Step4();    &#125;    lib.Step5();&#125;</code></pre></div><h2 id="用模板方法的代码重构为"><a href="#用模板方法的代码重构为" class="headerlink" title="用模板方法的代码重构为"></a>用模板方法的代码重构为</h2><p><img src="image-20200710191917988.png" srcset="/img/loading.gif" alt="image-20200710191917988" style="zoom:50%;" /></p><p>lib.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span> </span>&#123;        Step1();        <span class="hljs-keyword">if</span>(Step2()) &#123;            Step3();        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            Step4();        &#125;        Step5();    &#125;        <span class="hljs-keyword">virtual</span> ~Library() &#123;&#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>&#125;</code></pre></div><p>app.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//应用程序开发人员</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span>:</span> <span class="hljs-keyword">public</span> Library &#123;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;;</code></pre></div><p>主程序</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Library* pLib = <span class="hljs-keyword">new</span> Application();    lib.Run();    <span class="hljs-keyword">delete</span> pLib;&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两者的区别在于早绑定和晚绑定。前者属于早绑定，而template method属于晚绑定</p><p><img src="image-20200710192039991.png" srcset="/img/loading.gif" alt="image-20200710192039991" style="zoom:50%;" /></p><p>定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟 (变化)到子类中。Template Method使得子类可以不改变 (复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。</p>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Strategy Method</title>
    <link href="/2020/08/05/DesignPatterns/StrategyMethod/"/>
    <url>/2020/08/05/DesignPatterns/StrategyMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂； 而且有时候支持不使用的算法也是一个性能负担</p><p>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</p><h2 id="Strategy-Method定义"><a href="#Strategy-Method定义" class="headerlink" title="Strategy Method定义"></a>Strategy Method定义</h2><p>定义一系列算法，把它们一个个封装起来，并且使它们可互 相替换（变化）。该模式使得算法可独立于使用它的客户程 序(稳定)而变化（扩展，子类化）。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>考虑一下计算税的例子</p><ul><li>第一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> TaxBase &#123;    CN_Tax,    US_Tax,    DE_Tax&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span>    TaxBase tax;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>                <span class="hljs-keyword">if</span>(tax == CN_Tax) &#123;            <span class="hljs-comment">//CN*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == US_Tax) &#123;            <span class="hljs-comment">//US*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == DE_Tax) &#123;            <span class="hljs-comment">//DE*****</span>        &#125;        <span class="hljs-comment">//***</span>    &#125;&#125;</code></pre></div><p>有些时候，静态地去观察是看不出来的，加入时间轴，考虑到未来的动态变化，问题就会暴露出来。考虑上述例子，如果要加入一个国家，比如法国，那么我们不仅要在<code>TaxBase</code>中中增加一个<code>FR_Tax</code>, 还需要在<code>SalesOrder</code>中增加判断语句。这样的更改违背了开闭原则： 对扩展开放，对修改封闭 (避免去修改源代码</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> TaxBase &#123;    CN_Tax,    US_Tax,    DE_Tax,    <span class="hljs-comment">/***加入France***/</span>    FR_Tax,&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span>    TaxBase tax;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>                <span class="hljs-keyword">if</span>(tax == CN_Tax) &#123;            <span class="hljs-comment">//CN*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == US_Tax) &#123;            <span class="hljs-comment">//US*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == DE_Tax) &#123;            <span class="hljs-comment">//DE*****</span>        &#125;        <span class="hljs-comment">/***加入France***/</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == FR_Tax) &#123;                  &#125;        <span class="hljs-comment">//***</span>    &#125;&#125;</code></pre></div><ul><li>考虑另一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxStrategy</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~TaxStrategy() &#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DETax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span><span class="hljs-keyword">private</span>:    TaxStrategy* strategy;<span class="hljs-keyword">public</span>:    SalesOrder(StrategyFactory* strategyFactory) &#123;        <span class="hljs-keyword">this</span>-&gt;strategy = strategyFactory-&gt;NewStrategy();    &#125;        ~SalesOrder() &#123;        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>        <span class="hljs-function">Context <span class="hljs-title">context</span><span class="hljs-params">()</span></span>;                <span class="hljs-keyword">double</span> val =             srtategy-&gt;Calculate(context);<span class="hljs-comment">//多态调用</span>    &#125;&#125;</code></pre></div><p>如果要增加法国，只需增加一个<code>FRTax</code>类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> doubel <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>这是一种扩展的做法，在这里只需要增加一个FRTax类，不需要更改SalesOrder。</p><p>复用性一般是指二进制层面下的复用性，如果使用第一种方法，那么整个系统需要重新编译，重新测试。虽然修改后保留了一部分原来的代码，但是这个并不是复用。而策略方法不需要重新编译之前编译好的文件，只需要重新编译FRTax这个文件</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200805135526277.png" srcset="/img/loading.gif" alt="image-20200805135526277"> </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使 得类型在运行时方便地根据需要在各个算法之间进行切换。</p></li><li><p>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件 判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需 要Strategy模式。</p></li><li><p>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CA - Storage</title>
    <link href="/2019/12/08/ComputerArchitecture/Storage/"/>
    <url>/2019/12/08/ComputerArchitecture/Storage/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><center><img src="image-20191208134608723.png" srcset="/img/loading.gif" alt="image-20191208134608723" style="zoom:50%;" /></center><h2 id="1-1-缓存性能"><a href="#1-1-缓存性能" class="headerlink" title="1.1 缓存性能"></a>1.1 缓存性能</h2><p>CPU execution time</p><script type="math/tex; mode=display">=(CPU\, clock\, cycles + Memory\, stall\, cycles)\times Clock\, cycle\, time</script><p>{:.warning}</p><p>这里CPU clock cicles包括handle cache hit/miss的时间</p><center><img src="image-20191208135106480.png" srcset="/img/loading.gif" alt="image-20191208135106480" style="zoom:60%;" /></center><center><img src="image-20191208135244903.png" srcset="/img/loading.gif" alt="image-20191208135244903" style="zoom:60%;" /></center><p>看一道例题</p><blockquote><p>a computer with CPI=1 when cache hit.  </p><p>50% instructions are loads and stores;</p><p>2% miss rate, 25 cc miss penalty;</p><p><strong>Q:</strong> how much faster would the computer be if all instructions were cache hits?</p></blockquote><p>Answer:</p><ol><li>always hit:</li></ol><p>CPU execution time = (CPU clocks cycles + Memory stall cycles) * clock cycle</p><p>=<script type="math/tex">(IC \times CPI + 0) \times clock\,cycle</script></p><p>=<script type="math/tex">IC \times clock\, cycle</script></p><p><br/></p><ol><li>with misses</li></ol><p>Memory stall cycles</p><p>= $IC \times \frac{Memory\, accesses}{Instruction}\times Miss\, rate\times Miss\, penalty$</p><p>=$IC\times(1+0.5)\times 0.02\times 25$</p><p>=$IC\times 0.75$</p><p>memory accesses=1.5是因为执行任何一条指令都要访问memory取指令，并且50%的指令是load, store 因此 1+0.5=1.5</p><p>CPU execution time = (CPU clocks cycles + Memory stall cycles) $\times$ clock cycle</p><p>=$(IC\times 1.0+IC\times 0.75)\times$clock cycle</p><p>=$1.75\times $clock cycle</p><p>所以比值是1.75</p><h2 id="1-2-4个存储器层次结构问题"><a href="#1-2-4个存储器层次结构问题" class="headerlink" title="1.2 4个存储器层次结构问题"></a>1.2 4个存储器层次结构问题</h2><p>Q1: Where can a block be placed in the upper level? (block placement)</p><p>Q2: How is a block found if it is in the upper level? (block identification)</p><p>Q3: Which block should be replaced on a miss? (block replacement)</p><p>Q4: What happens on a write? (write strategy)</p><center><img src="image-2019120874232.png" srcset="/img/loading.gif" alt="截屏2019-12-08下午7.42.32" style="zoom:67%;" /></center><center><img src="image-20191208194519623.png" srcset="/img/loading.gif" alt="image-20191208194519623" style="zoom: 67%;" /></center><h3 id="A-Write-Strategy"><a href="#A-Write-Strategy" class="headerlink" title="A. Write Strategy"></a>A. Write Strategy</h3><p><code>Write hit</code></p><ul><li>write-through: info is written to both the block in the cache and to the block in the lower-level memory</li><li>write-back: info is written only to the block in the cache;  to the main memory only when the modified cache block is replaced[dirty bit]</li></ul><p><code>Write miss</code></p><ul><li>Write allocate: data at the missed-<strong>write</strong> location is loaded to cache, followed by a <strong>write</strong>-hit operation  </li><li>No-write allocate[write around]: data at the missed-<strong>write</strong> location is not loaded to cache, and is written directly to the backing store.  ;  <em>until the program tries to read the block, the data is loaded to cache;</em></li></ul><center><img src="image-20191208201918610.png" srcset="/img/loading.gif" alt="image-20191208201918610" style="zoom:50%;" /></center><ol><li>No-Write allocate:  4 misses + 1 hit</li></ol><center><img src="image-20191208202025669.png" srcset="/img/loading.gif" alt="image-20191208202025669" style="zoom:50%;" /></center><ol><li>Write allocate:  2 misses + 3 hits</li></ol><center><img src="image-20191208202722945.png" srcset="/img/loading.gif" alt="image-20191208202722945" style="zoom:50%;" /></center><h1 id="2-缓存性能"><a href="#2-缓存性能" class="headerlink" title="2. 缓存性能"></a>2. 缓存性能</h1><h3 id="Hit-or-Miss-How-long-will-it-take"><a href="#Hit-or-Miss-How-long-will-it-take" class="headerlink" title="Hit or Miss: How long will it take?"></a>Hit or Miss: How long will it take?</h3><p>Average memory access time = Hit time + Miss rate x Miss penalty</p><ul><li><strong>Example</strong></li></ul><blockquote><p>16KB instr cache + 16KB data cache;</p><p>or, 32KB unified cache;</p><p>36% data transfer instructions;</p><p>(load/store takes 1 extra cc on unified cache)</p><p>1 CC hit; 200 CC miss penalty;</p></blockquote><center><img src="image-20191208204528711.png" srcset="/img/loading.gif" alt="image-20191208204528711" style="zoom:30%;" /></center><blockquote><p><strong>Q1:</strong> split cache or unified cache has lower miss rate? </p></blockquote><p>Answer:</p><center><img src="image-20191208204804983.png" srcset="/img/loading.gif" alt="image-20191208204804983" style="zoom:40%;" /></center><ol><li>split cache</li></ol><p>16KB instruction Miss rate</p><p>​        = <script type="math/tex">\frac{3.82}{1000}/1=0.004</script></p><p>16KB data miss rate</p><p>​        =<script type="math/tex">\frac{40.9}{1000}/0.36=0.114</script></p><p>assume 74% of memory accesses are instruction references</p><p>Overall miss rate</p><p>​        =<script type="math/tex">(74\%\times 0.004)+(26\%\times 0.114)=0.0326</script></p><ol><li>unified cache</li></ol><p>Miss rate</p><p>=<script type="math/tex">\frac{43.3}{1000}/(1.0+0.36)=0.0318</script></p><blockquote><p><strong>Q2:</strong> average memory access time?</p></blockquote><center><img src="image-20191208205644462.png" srcset="/img/loading.gif" alt="image-20191208205644462" style="zoom:40%;" /></center><center><img src="image-20191208205754992.png" srcset="/img/loading.gif" alt="image-20191208205754992" style="zoom:40%;" /></center><h2 id="2-1-存储器平均访问时间与处理器性能"><a href="#2-1-存储器平均访问时间与处理器性能" class="headerlink" title="2.1 存储器平均访问时间与处理器性能"></a>2.1 存储器平均访问时间与处理器性能</h2><h1 id="3-Six-Basic-Cache-Optimizations"><a href="#3-Six-Basic-Cache-Optimizations" class="headerlink" title="3. Six Basic Cache Optimizations"></a>3. Six Basic Cache Optimizations</h1><p>我们将所有缺失分成三类</p><ul><li><p>强制缺失[Compulsory]</p><p>cold-start/first-reference misses;</p></li><li><p>容量缺失[Capacity]</p><p>cache size limit;</p><p> blocks discarded and later retrieved;</p></li><li><p>冲突缺失</p><p>collision misses: associativity</p><p>a block discarded and later retrieved in a set;</p></li></ul><center><img src="image-20191208213224033.png" srcset="/img/loading.gif" alt="image-20191208213224033" style="zoom:30%;" /></center><center><img src="image-20191208213207928.png" srcset="/img/loading.gif" alt="image-20191208213207928" style="zoom:30%;" /></center><center><img src="image-20191208213148539.png" srcset="/img/loading.gif" alt="image-20191208213148539" style="zoom:30%;" /></center><h2 id="3-1-Larger-Block-size"><a href="#3-1-Larger-Block-size" class="headerlink" title="3.1 Larger Block size"></a>3.1 Larger Block size</h2><ul><li><p><strong>Reduce</strong> compulsory misses</p><p>​    Leverage spatial locality</p></li><li><p><strong>Reduce</strong> static power</p><p>​    block size增大，地址里面index位就变多，tag位数就变少，比较时需要的工作量就变少</p></li><li><p><strong>Increase</strong> conflict/capacity misses</p><p>​    Fewer block in the cache</p></li></ul><center><img src="image-20191208214954621.png" srcset="/img/loading.gif" alt="image-20191208214954621" style="zoom: 30%;" /></center><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><center><img src="image-20191208215035983.png" srcset="/img/loading.gif" alt="image-20191208215035983" style="zoom:40%;" /></center><p><strong>Answer</strong></p><p> avg mem access time</p><p>​        =hit time + miss rate x miss penalty</p><div class="note note-info">            <p> assume 1-CC hit time</p><p> for a 256-byte block in a 256 KB cache:</p><p> avg mem access time</p><p>​        = 1 + 0.49% x (80 + 2x256/16) = 1.5 cc</p>          </div><p> 2x256/16是因为存储器2cc能给cache传回16bytes</p><h2 id="3-2-Larger-cache"><a href="#3-2-Larger-cache" class="headerlink" title="3.2 Larger cache"></a>3.2 Larger cache</h2><ul><li><p><strong>Reduce</strong> capacity misses</p></li><li><p><strong>Increase</strong> hit time, cost, and power</p></li></ul><h2 id="3-3-Higher-Associativity"><a href="#3-3-Higher-Associativity" class="headerlink" title="3.3 Higher Associativity"></a>3.3 Higher Associativity</h2><ul><li><p><strong>Reduce</strong> conflict misses</p></li><li><p><strong>Increase</strong> hit time</p></li></ul><h2 id="3-4-Multilevel-cache"><a href="#3-4-Multilevel-cache" class="headerlink" title="3.4 Multilevel cache"></a>3.4 Multilevel cache</h2><ul><li><strong>Reduce</strong> miss penalty</li></ul><p><br/></p><h4 id="A-Two-level-cache"><a href="#A-Two-level-cache" class="headerlink" title="A. Two-level cache"></a>A. Two-level cache</h4><p> Add another level of cache between the original cache and memory</p><ul><li><p><strong>L1</strong>: small enough to match the clock cycle time of the fast processor;</p></li><li><p><strong>L2</strong>: large enough to capture many accesses that would go to main memory, lessening miss penalty</p></li></ul><center><img src="image-20191208220714030.png" srcset="/img/loading.gif" alt="image-20191208220714030" style="zoom:50%;" /></center><h4 id="B-Average-memory-access-time"><a href="#B-Average-memory-access-time" class="headerlink" title="B. Average memory access time"></a>B. Average memory access time</h4><p>=Hit timeL1 + Miss rateL1 x Miss penaltyL1</p><p>=Hit timeL1 + Miss rateL1</p><p> x(Hit timeL2+Miss rateL2xMiss penaltyL2)</p><h4 id="C-Average-mem-stalls-per-instruction"><a href="#C-Average-mem-stalls-per-instruction" class="headerlink" title="C. Average mem stalls per instruction"></a>C. Average mem stalls per instruction</h4><p>=Misses per instructionL1 x Hit timeL2</p><p> + Misses per instrL2 x Miss penaltyL2</p><h4 id="D-Local-miss-rate"><a href="#D-Local-miss-rate" class="headerlink" title="D. Local miss rate"></a>D. Local miss rate</h4><p> the number of misses in a cache</p><p> divided by the total number of mem accesses to <u>this cache</u>;</p><p> {:.info}</p><p>分成 Miss rateL1, Miss rateL2</p><h4 id="E-Global-miss-rate"><a href="#E-Global-miss-rate" class="headerlink" title="E. Global miss rate"></a>E. Global miss rate</h4><p> the number of misses in the cache </p><p> divided by the number of mem accesses generated by the processor;</p><p> {:.info}</p><p>L1的全局缺失率Miss rate<strong>L1</strong>,<u>L2的全局缺失率 Miss rateL1 x Miss rateL2</u></p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><blockquote><p>1000 mem references -&gt; 40 misses in L1 and 20 misses in L2;</p><p>miss penalty from L2 is 200 cc;</p><p>hit time of L2 is 10 cc;</p><p>hit time of L1 is 1 cc;</p><p>1.5 mem references per instruction;</p><p> <strong>Q: 1.</strong> various miss rates?</p></blockquote><p> <strong>L1:</strong> local = global</p><p> 40/1000 = 4%</p><p> <strong>L2:</strong></p><p> local: 20/40 = 50%</p><p> global: 20/1000 = 2%</p><blockquote><p><strong>Q: 2.</strong> avg mem access time?</p></blockquote><p>average memory access time</p><p>=Hit timeL1 + Miss rateL1</p><p> x(Hit timeL2+Miss rateL2xMiss penaltyL2)</p><p>=1 + 4% x (10 + 50% x 200)</p><p>=5.4</p><blockquote><p> <strong>Q: 3.</strong> avg stall cycles per instruction?</p></blockquote><p>average stall cycles per instruction</p><p>=Misses per instructionL1 x Hit timeL2</p><p> + Misses per instrL2 x Miss penaltyL2</p><p>=(1.5x40/1000)x10+(1.5x20/1000)x200</p><p>=6.6</p><h2 id="2-5-Prioritize-read-misses-over-writes"><a href="#2-5-Prioritize-read-misses-over-writes" class="headerlink" title="2.5  Prioritize read misses over writes"></a>2.5  Prioritize read misses over writes</h2><ul><li><strong>Reduce</strong> miss penalty</li></ul><div class="note note-info">            <p>这种方法使得在write buffer将数据写入memory之前，就可以为read操作提供服务</p>          </div><h2 id="2-6-Avoid-address-translation-during-indexing-cache"><a href="#2-6-Avoid-address-translation-during-indexing-cache" class="headerlink" title="2.6 Avoid address translation during indexing cache"></a>2.6 Avoid address translation during indexing cache</h2><p>虚拟缓存</p><h1 id="4-Ten-advanced-cache-optimizations"><a href="#4-Ten-advanced-cache-optimizations" class="headerlink" title="4. Ten advanced cache optimizations"></a>4. Ten advanced cache optimizations</h1><center><img src="image-20191209100308445.png" srcset="/img/loading.gif" alt="image-20191209100308445" style="zoom: 33%;" /></center><h2 id="4-1-Small-and-Simple-First-Level-Caches"><a href="#4-1-Small-and-Simple-First-Level-Caches" class="headerlink" title="4.1 Small and Simple First-Level Caches"></a>4.1 Small and Simple First-Level Caches</h2><ul><li>Small size</li></ul><blockquote><p>support a fast clock cycle</p><p>reduce power</p></blockquote><ul><li>Lower associativity</li></ul><blockquote><p>reduce both hit time and power</p><p>(direct-mapped caches can overlap the tag check with the transmission of the data)</p></blockquote><h2 id="4-2-Way-prediction"><a href="#4-2-Way-prediction" class="headerlink" title="4.2 Way prediction"></a>4.2 Way prediction</h2><p>•Reduce conflict misses and hit time</p><p>•<strong>Way prediction</strong></p><p> <em>block predictor bits</em> are added to each block to predict the way/block within the set of the <em>next</em> cache access</p><p> the multiplexor is set <strong>early to select the desired block</strong>;</p><p> only a single tag comparison is performed <strong>in parallel with cache reading</strong>;</p><p> a miss results in checking the other blocks for matches in the next clock cycle;</p><h2 id="4-3-Pipelined-Cache-Access"><a href="#4-3-Pipelined-Cache-Access" class="headerlink" title="4.3 Pipelined Cache Access"></a>4.3 Pipelined Cache Access</h2><ul><li><p>Increase cache bandwidth</p></li><li><p>Higher latency</p></li><li><p>Greater penalty on mispredicted branches and more clock cycles between issuing the load and using the data </p></li></ul><h2 id="4-4-Nonblocking-caches"><a href="#4-4-Nonblocking-caches" class="headerlink" title="4.4 Nonblocking caches"></a>4.4 Nonblocking caches</h2><blockquote><p>对于允许乱序执行的流水化计算机，他的处理器不必因为一次数据缓存缺失而停顿。在等待数据缓存返回缺失数据时，处理器可以继续从指令缓存中提取指令。nonblocking cache允许数据缓存在一次缺失期间继续提供缓存命令</p></blockquote><ul><li>Increase cache bandwidth</li></ul><h2 id="4-5-Multibanked-caches"><a href="#4-5-Multibanked-caches" class="headerlink" title="4.5 Multibanked caches"></a>4.5 Multibanked caches</h2><blockquote><p>Divide cache into independent banks that support simultaneous accesses</p><p>Sequential interleaving spread the addresses of blocks sequentially across the banks</p></blockquote><center><img src="image-20191217202233856.png" srcset="/img/loading.gif" alt="image-20191217202233856" style="zoom:50%;" /></center><ul><li>Increase cache bandwidth</li></ul><h2 id="4-6-Critical-Word-First-amp-Early-Restart"><a href="#4-6-Critical-Word-First-amp-Early-Restart" class="headerlink" title="4.6 Critical Word First &amp; Early Restart"></a>4.6 Critical Word First &amp; Early Restart</h2><p>通常CPU只会request一个word, 但是一个cache line对应了很多个word</p><ul><li>critical word first</li></ul><blockquote><p>首先请求critical word也就是CPU request的那个word, 然后发送给CPU, 然后再去请求一个cache line剩余的部分</p></blockquote><ul><li>early restart</li></ul><blockquote><p>按正常顺序获取word, 不需要等待一个cache line全部放入缓存再发送给处理器，而是critical word到了就直接发送给处理器，不需要等待还没有完成传输的word</p></blockquote><ul><li>Reduce miss penalty</li></ul><h2 id="4-7-Merging-Write-buffer"><a href="#4-7-Merging-Write-buffer" class="headerlink" title="4.7 Merging Write buffer"></a>4.7 Merging Write buffer</h2><p>Write merging merges four entries (with sequential addresses)  into a single buffer entry</p><center><img src="image-20191217203849064.png" srcset="/img/loading.gif" alt="image-20191217203849064" style="zoom:50%;" /></center><ul><li>Reduce miss penalty</li></ul><h2 id="4-8-Compiler-optimizations"><a href="#4-8-Compiler-optimizations" class="headerlink" title="4.8 Compiler optimizations"></a>4.8 Compiler optimizations</h2><h3 id="A-Loop-interchange"><a href="#A-Loop-interchange" class="headerlink" title="A. Loop interchange"></a>A. Loop interchange</h3><h4 id="before"><a href="#before" class="headerlink" title="before"></a>before</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;    x[i][j] = <span class="hljs-number">2</span> * x[i][j];  &#125;&#125;</code></pre></div><p>x[i][j]访问之后访问x[i+1][j],这中间差了100个数据</p><h4 id="after"><a href="#after" class="headerlink" title="after"></a>after</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;    x[i][j] = <span class="hljs-number">2</span> * x[i][j]  &#125;&#125;</code></pre></div><p>x[i][j]访问之后访问x[i][j+1], 这中间只差了一个数据，就可以按照数据存储的顺序来访问，增强了space locality。</p><p>这样一次miss之后，load多个word进cache的话，缺失就会变少</p><h3 id="B-Blocking-分块"><a href="#B-Blocking-分块" class="headerlink" title="B. Blocking[分块]"></a>B. Blocking[分块]</h3><h4 id="before-1"><a href="#before-1" class="headerlink" title="before"></a>before</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++) &#123;    &#123;      r = <span class="hljs-number">0</span>;      <span class="hljs-comment">//y的行 * z的列</span>      <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; N; k++) &#123;        r = r + y[i][k] * z[k][j]      &#125;    &#125;  &#125;&#125;</code></pre></div><p><img src="image-20191217210134473.png" srcset="/img/loading.gif" alt="image-20191217210134473" style="zoom:50%;" /></p><h4 id="after-1"><a href="#after-1" class="headerlink" title="after"></a>after</h4><p><em>maximize accesses to loaded data before they are replaced</em></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(jj = <span class="hljs-number">0</span>; jj &lt; N; jj = jj + B) &#123;  <span class="hljs-keyword">for</span>(kk = <span class="hljs-number">0</span>; kk &lt; N; kk = kk + B) &#123;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;      <span class="hljs-keyword">for</span>(j = jj; j &lt; min(jj+B, N); j++) &#123;        &#123;          r = <span class="hljs-number">0</span>;          <span class="hljs-keyword">for</span>(k = kk; k &lt; min(kk); k++) &#123;            r = r + y[i][k] * z[k][j];          &#125;          x[i][j] = x[i][j] + r;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre></div><p><img src="image-20191217210322625.png" srcset="/img/loading.gif" alt="image-20191217210322625" style="zoom:50%;" /></p><h2 id="4-9-Hardware-prefetching"><a href="#4-9-Hardware-prefetching" class="headerlink" title="4.9 Hardware prefetching"></a>4.9 Hardware prefetching</h2><p>指令和数据都可以预取，既可以直接放在cache中，也可以放在一个访问速度快于main memory的外部缓冲区中。</p><p>下面来看一下指令预取</p><p>通常，处理器在一次缺失时提取两个块。被请求块和下一个相邻块</p><ul><li>被请求块放在他返回时的指令缓存中</li><li>预取块放在指令流缓冲区中。</li></ul><p>请求时，如果发现被请求块位于指令流缓冲区，那么原缓存请求取消，从流缓冲区来读取这个块。并发出下一条预取请求</p><ul><li>Reduce miss penalty/rate</li></ul><h2 id="4-10-Compiler-Prefetching"><a href="#4-10-Compiler-Prefetching" class="headerlink" title="4.10 Compiler Prefetching"></a>4.10 Compiler Prefetching</h2><p>作为hardware prefetching的替代方法。可以在处理器需要某一数据之前，由编译器插入请求该数据的预取指令</p><p>有以下两种prefetch</p><ul><li><p><strong>Register</strong> <strong>prefetch</strong></p><p>load the value into a register</p></li><li><p><strong>Cache</strong> <strong>prefetch</strong></p><p>load data into the cache</p></li></ul><p><strong>Example</strong></p><p>16-byte blocks;</p><p>8-byte elements for a and b;</p><p>write-back strategy</p><p>a[0][0] miss, copy both a[0][0],a[0][1] as one block contains 16/8 = 2;</p><p><strong><em>before</em></strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i = i + <span class="hljs-number">1</span>)  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j = j + <span class="hljs-number">1</span>)    a[i][j] = b[j][<span class="hljs-number">0</span>] * b[j + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]</code></pre></div><p>缺失次数</p><p>对于a, $3\times(100/2)=150$次缺失</p><p>对于b, b不会从空间局部性受益，但是可以从时间局部性受益</p><p>b从b[0][0]访问到b[100][0]一共有101次缺失</p><p>总共251次缺失</p><p><strong><em>after prefetching</em></strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;  prefetch(b[j+<span class="hljs-number">7</span>][<span class="hljs-number">0</span>]);  prefetch(a[<span class="hljs-number">0</span>][j+<span class="hljs-number">7</span>]);  a[<span class="hljs-number">0</span>][j] = b[j][<span class="hljs-number">0</span>] * b[j+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;prefetch(a[i][j+<span class="hljs-number">7</span>]);    a[i][j] = b[j][<span class="hljs-number">0</span>] * b[j+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];  &#125;&#125;</code></pre></div><p>修改后，将会预取a[i][7]—-a[i][99]和b[7][0]—b[100][0]</p><p>所以非预取缺失只会出现在前几个循环</p><ul><li>第一个loop访问b[0][0]—-b[6][0]的7次缺失</li><li>第一个loop访问a[0][0]—a[0][7]的4次缺失</li><li>第二个loop访问a[1][0]—a[1][6]的4次缺失</li><li>第二个loop访问a[2][0]—a[2][6]的4次缺失</li></ul><p>总共有19次非预取缺失</p><p><strong>Reduce</strong> miss penalty/rate</p><h1 id="5-Memory"><a href="#5-Memory" class="headerlink" title="5. Memory"></a>5. Memory</h1><p>Performance Measures</p><ul><li><strong>Latency</strong></li></ul><div class="note note-warning">            <p>the time to retrieve the first word of the block</p>          </div><p> important for caches;</p><p> harder to reduce;</p><blockquote><p><strong>access time</strong>: the time between when a read is requested and when the desired word arrives;</p><p><strong>cycle time</strong>: the minimum time between unrelated requests to memory;</p><p><em>or</em> the minimum time between the start of an access and the start of the next access;</p></blockquote><ul><li><strong>Bandwidth</strong> </li></ul><p>the time to retrieve the rest of this block</p><h2 id="5-1-RAM"><a href="#5-1-RAM" class="headerlink" title="5.1 RAM"></a>5.1 RAM</h2><p><a href="https://www.zhihu.com/question/30492703" target="_blank" rel="noopener">Zhihu Birkee’s answer</a></p><p>RAM，Random-Access Memory，即随机存取存储器，其实就是内存，断电会丢失数据。<br>主要分为SRAM（static）和DRAM（dynamic)。主要的区别在于存储单元，DRAM使用电容电荷进行存储。需要一直刷新充电。SRAM是用锁存器锁住信息，不需要刷新。但也需要充电保持。</p><center><table>  <tr>    <td><div class="card">     <div class="card__image">       <img class="image" src="image-20191209104433202.png" srcset="/img/loading.gif" alt="image-20191209104433202" style="zoom:50%;" />   </div>     <div class="card__content">         <div class="card__header">             <h4>DRAM的基本存储单元</h4>         </div>         <p>利用一个晶体管进行控制电容的充放电</p>    </div></div></td>  <td><div class="card">     <div class="card__image">       <img class="image" src="image-20191209104458720.png" srcset="/img/loading.gif" alt="image-20191209104458720" style="zoom:50%;" />   </div>     <div class="card__content">         <div class="card__header">             <h4>DRAM一般的寻址模式</h4>         </div>         <p>控制的晶体管集成在单个存储单元中</p>    </div> </div></td>  </tr></table></center><h2 id="5-2-SRAM-for-cache-Static-Random-Access-Memory"><a href="#5-2-SRAM-for-cache-Static-Random-Access-Memory" class="headerlink" title="5.2 SRAM for cache[Static Random Access Memory]"></a>5.2 SRAM for cache[Static Random Access Memory]</h2><ul><li><p>Six transistors per bit to prevent the information from being disturbed when read</p></li><li><p>Don’t need to refresh, so access time is very close to cycle time</p></li></ul><h2 id="5-3-DRAM-for-main-memory-Dynamic-Random-Access-Memory"><a href="#5-3-DRAM-for-main-memory-Dynamic-Random-Access-Memory" class="headerlink" title="5.3 DRAM for main memory[Dynamic Random Access Memory]"></a>5.3 DRAM for main memory[Dynamic Random Access Memory]</h2><center><img src="image-20191209105411600.png" srcset="/img/loading.gif" alt="image-20191209105411600" style="zoom:30%;" /></center><center><img src="image-20191209105418930.png" srcset="/img/loading.gif" alt="image-20191209105418930" style="zoom:30%;" /></center><p>bing row into row buffer</p><center><img src="image-20191209105429474.png" srcset="/img/loading.gif" alt="image-20191209105429474" style="zoom:30%;"/></center><p>select Data via Multiplexor</p><center><img src="image-20191209105442259.png" srcset="/img/loading.gif" alt="image-20191209105442259" style="zoom:30%;"/></center><p>Data selected</p><center><img src="image-20191209105451917.png" srcset="/img/loading.gif" alt="image-20191209105451917" style="zoom:30%;"/></center><p>Row buffer hit</p><center><img src="image-20191209105459461.png" srcset="/img/loading.gif" alt="image-20191209105459461" style="zoom:30%;"/></center><p>Row buffer conflict</p><br>## 5.6 提高存储器的可靠性### Error type* **Soft errors**<div class="note note-info">            <p>changes to a cell’s contents, not a change in the circuitry</p>          </div>* **Hard errors**<div class="note note-info">            <p>permanent changes in the operation of one or more memory cells</p>          </div>### Error detection and fix<center><table>  <tr>    <td><div class="card">     <div class="card__content">         <div class="card__header">             <h4>Parity only</h4>         </div>         <p>only one bit of overhead to detect a single error in a sequence of bits;</p>    </div></div></td>  <td><div class="card">      <div class="card__content">         <div class="card__header">             <h4>ECC only</h4>         </div>         <p>detect two errors and correct a single error with 8-bit overhead per 64 data bits</p>    </div> </div></td>    <td><div class="card">      <div class="card__content">         <div class="card__header">             <h4>Chipkill</h4>         </div>         <p>类似于在磁盘中使用RAID方法，它分散数据和ECC信息，在单个存储器芯片完全失效时，可以从其余存储器芯片中重构丢失数据</p>    </div> </div></td>  </tr></table></center><h1 id="6-Disk"><a href="#6-Disk" class="headerlink" title="6. Disk"></a>6. Disk</h1><div class="item">     <div class="item__image">     <img class="image image--lg" src="image-20191209113803942.png" srcset="/img/loading.gif" alt="image-20191209113803942" style="zoom:50%;" />    <img class="image image--lg" src="image-20191209113823956.png" srcset="/img/loading.gif" alt="image-20191209113823956" style="zoom:50%;" />     </div>     <div class="item__content">       <div class="item__header">           <h4>Disk</h4>       </div>       <div class="item__description">         <p>Sector: minimum storage unit. A block may span multiple sectors</p>     <p>Cluster:(dis)contiguous groups of sectors to reduce the overhead of managing on-disk data structures; may span more than one track</p>      </div>     </div> </div><p>Areal density = $\frac{Tracks}{Inch}$ on a disk surface $\times$ $\frac{Bits}{Inch}$ on a track</p><h2 id="6-1-RAID-Redundant-Arrays-of-Inepensive-Disk"><a href="#6-1-RAID-Redundant-Arrays-of-Inepensive-Disk" class="headerlink" title="6.1 RAID[Redundant Arrays of Inepensive Disk]"></a>6.1 RAID[Redundant Arrays of Inepensive Disk]</h2><ul><li>RAID 0: No Redundancy</li><li>RAID 1: Mirroring / Shadowing</li></ul><blockquote><p>Two copies for every piece of data</p><p>one logical write = two physical writes</p><p>100% capacity/space  overhead</p></blockquote><center><img src="IMG_2C62CE9D9D16-1.jpeg" srcset="/img/loading.gif" alt="IMG_2C62CE9D9D16-1" style="zoom:50%;" /></center><ul><li>RAID 2:</li></ul><blockquote><p>Each bit of data word is written to a data disk drive</p><p>Each data word has its (Hamming Code) ECC word recorded on the ECC disks</p><p>On read, the ECC code verifies correct data or corrects single disks errors</p></blockquote><center><img src="image-20191216120558419.png" srcset="/img/loading.gif" alt="image-20191216120558419" style="zoom:50%;" /></center><ul><li>RAID 3:</li></ul><blockquote><p>RAID 3 P校验盘存的是前面所有盘数据的和。</p><p>他很慢，因为每读取一次磁盘数据，校验时要读取其他所有磁盘才能算校验和</p><p>磁盘坏了的话，也可以通过checksum恢复数据</p></blockquote><center><img src="IMG_E9E135911744-1.png" srcset="/img/loading.gif" alt="IMG_E9E135911744-1" style="zoom:50%;" /></center><center><img src="image-20191216121018499.png" srcset="/img/loading.gif" alt="image-20191216121018499" style="zoom:50%;" /></center><ul><li>RAID 4</li></ul><center><img src="IMG_17517EAA2585-1.png" srcset="/img/loading.gif" alt="IMG_17517EAA2585-1" style="zoom: 33%;" /></center><ul><li>RAID 5</li></ul><center><img src="IMG_8BFCBD97FD85-1.png" srcset="/img/loading.gif" alt="IMG_8BFCBD97FD85-1" style="zoom:30%;" /></center><ul><li>RAID 6</li></ul><blockquote><p>row parity</p></blockquote><center><img src="image-20191216130127847.png" srcset="/img/loading.gif" alt="image-20191216130127847" style="zoom:30%;" /></center><blockquote><p>Diagonal parity</p></blockquote><center><img src="image-20191216130657742.png" srcset="/img/loading.gif" alt="image-20191216130657742" style="zoom:30%;" /></center><p>看一个例子</p><p>disk 1和disk 3 double failure</p><center><img src="image-20191216130845614.png" srcset="/img/loading.gif" alt="image-20191216130845614" style="zoom:30%;" /></center><p>First recover Disk 3 stripe 0. Because its diagonal parity is independent from the other failed disk 1.</p><center><img src="image-20191216130921114.png" srcset="/img/loading.gif" alt="image-20191216130921114" style="zoom:30%;" /></center><p>When Disk 3 stripe 0 is recoverd, then we can recover Disk 1 stripe 3. Because on its row, only its stripe is failed. So we can use the row parity to recover the stripe.</p><center><img src="image-20191216130953500.png" srcset="/img/loading.gif" alt="image-20191216130953500" style="zoom:30%;" /></center><p>Now, we have recovered Disk 1 stripe 3 and Disk 3 stripe 0</p><center><img src="image-20191216131127165.png" srcset="/img/loading.gif" alt="image-20191216131127165" style="zoom:30%;" /></center><p>以下同理</p><center><img src="image-20191216131242663.png" srcset="/img/loading.gif" alt="image-20191216131242663" style="zoom:30%;" /></center><center><img src="image-20191216131302430.png" srcset="/img/loading.gif" alt="image-20191216131302430" style="zoom:30%;" /></center><center><img src="image-20191216131334869.png" srcset="/img/loading.gif" alt="image-20191216131334869" style="zoom:30%;" /></center><center><img src="image-20191216131357343.png" srcset="/img/loading.gif" alt="image-20191216131357343" style="zoom:30%;" /></center><center><img src="image-20191216131420435.png" srcset="/img/loading.gif" alt="image-20191216131420435" style="zoom:30%;" /></center><center><img src="image-20191216131449208.png" srcset="/img/loading.gif" alt="image-20191216131449208" style="zoom:30%;" /></center><center><img src="image-20191216131514362.png" srcset="/img/loading.gif" alt="image-20191216131514362" style="zoom:30%;" /></center><center><img src="image-20191216131536642.png" srcset="/img/loading.gif" alt="image-20191216131536642" style="zoom:30%;" /></center><center><img src="image-20191216131556362.png" srcset="/img/loading.gif" alt="image-20191216131556362" style="zoom:30%;" /></center><h1 id="7-I-O-performance"><a href="#7-I-O-performance" class="headerlink" title="7. I/O performance"></a>7. I/O performance</h1><h3 id="unique-measures"><a href="#unique-measures" class="headerlink" title="unique measures"></a>unique measures</h3><ul><li>Diversity</li></ul><blockquote><p>which I/O devices can connect to the computer system?</p></blockquote><ul><li>Capacity</li></ul><blockquote><p>how many I/O devices can connect to a computer system?</p></blockquote><h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><ul><li><p>response time[latency]</p></li><li><p>throughout[bandwidth]</p></li></ul><center><img src="image-20191216102829183.png" srcset="/img/loading.gif" alt="image-20191216102829183" style="zoom:50%;" /></center><h2 id="7-1-Throughout-VS-Response-Time"><a href="#7-1-Throughout-VS-Response-Time" class="headerlink" title="7.1 Throughout VS Response Time"></a>7.1 Throughout VS Response Time</h2><p><strong><em>Transaction</em></strong></p><blockquote><p>An interation between human and computer is called <strong><em><u>transaction</u></em></strong></p></blockquote><p>A <strong><em><u>transaction time</u></em></strong> is divided into three parts:</p><blockquote><ul><li><u>entry time</u></li></ul><blockquote><p>The time for user to enter the command</p></blockquote><ul><li><u>system response time</u></li></ul><blockquote><p>The time between when the user enters the command and the complete response is displayed</p></blockquote><ul><li><u>think time</u></li></ul><blockquote><p>The time from the reception of the response until the user begins to <strong><em><u>enter the next command</u></em></strong></p></blockquote></blockquote><center><img src="image-20191216210721189.png" srcset="/img/loading.gif" alt="image-20191216210721189" style="zoom:40%;" /></center><center><img src="image-20191216210659441.png" srcset="/img/loading.gif" alt="image-20191216210659441" style="zoom:50%;" /></center><p>More transaction time reduction than just the response time reduction. People need less time to think when given a faster response</p><h2 id="7-2-Transaction-Processing-Benchmarks"><a href="#7-2-Transaction-Processing-Benchmarks" class="headerlink" title="7.2 Transaction-Processing Benchmarks"></a>7.2 Transaction-Processing Benchmarks</h2><h3 id="A-SPEC"><a href="#A-SPEC" class="headerlink" title="A. SPEC"></a>A. SPEC</h3><h3 id="B-TPC-C"><a href="#B-TPC-C" class="headerlink" title="B. TPC_C"></a>B. TPC_C</h3><h2 id="7-3-A-little-Queuing-Theory-to-calculate-response-time-and-throughput"><a href="#7-3-A-little-Queuing-Theory-to-calculate-response-time-and-throughput" class="headerlink" title="7.3 A little Queuing Theory[to calculate response time and throughput]"></a>7.3 A little Queuing Theory[to calculate response time and throughput]</h2><center><img src="image-20191216104938324.png" srcset="/img/loading.gif" alt="image-20191216104938324" style="zoom:50%;" /></center><p><strong><em>Flow-balanced State</em></strong></p><ul><li><p>If the system is in <strong>steady state</strong>,  then the number of tasks entering the system must equal the number of tasks leaving the system</p></li><li><p>This <strong>flow-balanced state</strong> is necessary but not sufficient for steady state</p></li><li><p>The system has reached <strong>steady state</strong> if the system has been observed for a sufficiently long time and  mean waiting times stabilize</p></li></ul><h3 id="A-little’s-law-important"><a href="#A-little’s-law-important" class="headerlink" title="A. little’s law[important]"></a>A. little’s law[important]</h3><h4 id="i-Assumptions"><a href="#i-Assumptions" class="headerlink" title="i. Assumptions"></a>i. Assumptions</h4><div class="note note-info">            <p>input rate = output rate; </p><p>a steady supply of tasks independent for how long they wait for service;</p>          </div><h4 id="ii-little’s-law"><a href="#ii-little’s-law" class="headerlink" title="ii. little’s law"></a>ii. little’s law</h4><div class="note note-error">            <p>Mean number of tasks in system =  Arrival rate $\times$ Mean response time</p><p>注意arrival rate 表示单位时间到了几个task</p>          </div><h4 id="iii-single-server-model"><a href="#iii-single-server-model" class="headerlink" title="iii. single-server model"></a>iii. single-server model</h4><center><img src="image-20191216214128113.png" srcset="/img/loading.gif" alt="image-20191216214128113" style="zoom: 40%;" /></center><ul><li>$Time_{server}$  —Average time to service a task; average  $service_{rate}=1/Time_{server}$</li><li>$Time_{queue}$—Average time per task in the queue.</li><li>$Time_{system}$ —Average time per task in the system, or the response time, which is $Time_{queue}+Time_{server}$ .</li><li>Arrival rate—Average number of arriving tasks/second</li><li>$Length_{server}$—Average number of tasks in service.</li><li>$Length_{queue}$—Average length of queue.</li><li>$Length_{system}$—Average number of tasks in system, which is $Length_{server}+Length_{queue}$</li></ul><p><strong><em>Server Utilization</em></strong></p><div class="note note-info">            <p>Server utilization = Arrival rate$\times$ $Time_{server}$</p>          </div><center><img src="image-20191216110406290.png" srcset="/img/loading.gif" alt="image-20191216110406290" style="zoom:50%;" /></center><p><br/></p><p><strong><em>Time queue</em></strong></p><p>$Time_{queue}=Length_{queue}\times Time_{server}+$Mean time to complete the task being serviced when new task arrives if server is busy</p><p>$Time_{queue}=Time_{server}\times \frac{Server\;utilization}{1-Server\; utilization}$</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}Length_{queue}=&Arrival\; rate\times Time_{server}\times\frac{Server\;utilization}{1-Server\; utilization}\\ =&\frac{Server\; utilization^2}{1-Server\; utilization}\end{aligned}\end{equation}</script><h4 id="iv-M-M-1-queue"><a href="#iv-M-M-1-queue" class="headerlink" title="iv. M/M/1 queue"></a>iv. M/M/1 queue</h4><blockquote><p><strong>M</strong>: <em>Markov</em></p><p>exponentially random request arrival;</p><p><strong>M</strong>: <em>Markov</em></p><p>exponentially random service time</p><p><strong>1</strong></p><p>single server</p></blockquote><p><strong>assumptions</strong></p><blockquote><p>The system is in equilibrium</p><p><em>Interarrival</em> <em>times</em> [times between two successive requests arriving] are exponentionally distributed</p><p><em>Infinite population model</em>: unlimited number of sources of requests</p><p>Server starts on the next job immediately after finishing prior one</p><p>FIFO queue with unlimited length</p><p>One server only</p></blockquote><center><img src="image-20191216222544839.png" srcset="/img/loading.gif" alt="image-20191216222544839" style="zoom:50%;" /></center><center><img src="image-20191216222600418.png" srcset="/img/loading.gif" alt="image-20191216222600418" style="zoom:50%;" /></center><center><img src="image-20191216222618484.png" srcset="/img/loading.gif" alt="image-20191216222618484" style="zoom:50%;" /></center><h4 id="v-M-M-m-queue"><a href="#v-M-M-m-queue" class="headerlink" title="v. M/M/m queue"></a>v. M/M/m queue</h4><center><img src="image-20191216222740597.png" srcset="/img/loading.gif" alt="image-20191216222740597" style="zoom:50%;" /></center><center><img src="image-20191216222905001.png" srcset="/img/loading.gif" alt="image-20191216222905001" style="zoom:40%;" /></center>]]></content>
    
    
    <categories>
      
      <category>Computer Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CA - Pipeline</title>
    <link href="/2019/10/13/ComputerArchitecture/pipeline/"/>
    <url>/2019/10/13/ComputerArchitecture/pipeline/</url>
    
    <content type="html"><![CDATA[<h1><a name="pipline">附录C流水线</a></h1><h2 id="1-什么是流水线"><a href="#1-什么是流水线" class="headerlink" title="1 什么是流水线"></a>1 什么是流水线</h2><p>流水线是一种将多条指令 <strong><em>重叠执行</em></strong> 的实现技术  </p><p>一条执行包含多种操作，流水线充分利用了这些 <strong><em>操作之间的并行性</em></strong><br><br/></p><p>为了能更形象地理解这个问题，不妨用汽车装配线来做类比    </p><blockquote><p>汽车装配线的每一环节负责一项任务，所有环节是并行的（也就是不同的汽车同时在不同的环节上）  </p><p>在流水线中，指令就像是一辆待装配的汽车，不同环节完成指令的一部分,这些环节的每一步称为 <strong><em>流水级或者流水段</em></strong>。流水级前后相连形成流水线  </p><p>汽车装配线的 <strong><em>吞吐量</em></strong> 定义为单位时间生产的汽车数量，由完整汽车退出装配线的频率决定</p><p>流水线的吞吐量由指令退出流水线的频率决定。一条指令在流水线中下移一步需要的时间为 <strong><em>处理器周期</em></strong> 。因为各个环节同时执行，所以处理器周期由最缓慢的流水线级确定。</p></blockquote><p>可以想见，要使流水线性能高，平衡各流水线级很重要  </p><blockquote><p>因为处理器周期由最缓慢的流水线级确定，我们想要使最缓慢环节的加快，就要平衡各流水线级。  [木桶原理]</p></blockquote><p>如果各级达到完美平衡，那么每条指令在流水线处理器中的时间为  </p><script type="math/tex; mode=display">\frac{非流水线机器上每条指令的时间}{流水级的数目}</script><p>在这些条件下，流水线加速比=流水级的数目</p><p><br/></p><h1 id="2-RISC指令集"><a href="#2-RISC指令集" class="headerlink" title="2 RISC指令集"></a>2 RISC指令集</h1><p>我们以RISC指令集为例来了解一下流水线实现。一下，我们会介绍RISC指令集以及没有流水线的实现方式。</p><p>RISC指令集子集中每条指令都可以在5个时钟周期以内实现。以MIPS指令集为例介绍这5个时钟周期</p><ul><li><strong><em>指令提取周期(IF(Instruction Fetch))</em></strong>  </li><li><strong><em>指令译码/寄存器提取周期(ID)</em></strong>  </li><li><strong><em>执行/有效地址周期(EX)</em></strong>  </li><li><strong><em>存储器访问(MEM)</em></strong></li><li><strong><em>写回周期(WB)</em></strong></li></ul><center><img="/Users/jones/Library/Application Support/typora-user-images/image-20191219230108716.png" alt="image-20191219230108716" style="zoom:50%;" /></center><p><a href="http://web.cs.iastate.edu/~prabhu/Tutorial/PIPELINE/DLXimplem.html" target="_blank" rel="noopener">http://web.cs.iastate.edu/~prabhu/Tutorial/PIPELINE/DLXimplem.html</a></p><p><br/></p><h1 id="3-RISC处理器经典五级流水线"><a href="#3-RISC处理器经典五级流水线" class="headerlink" title="3 RISC处理器经典五级流水线"></a>3 RISC处理器经典五级流水线</h1><center><img src="ca20190908-1.png" srcset="/img/loading.gif" width="600"></center><center><img src="ca20190908-2.png" srcset="/img/loading.gif" width="600"></center><p><br/></p><p>在RISC流水线中，多条指令的执行重叠不会引入多少冲突，因为以下三点</p><h4 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h4><p>使用分离的指令存储器和数据存储器。</p><p>这样做是因为指令提取和数据访问都需要访问存储器，会引发冲突，所以分离指令和数据存储器。</p><p>注意：如果流水线处理器时钟周期=多周期处理器时钟周期，存储器需要提供<strong>5倍带宽</strong></p><h4 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h4><p>两个阶段使用了寄存器堆：<strong>ID</strong>阶段decode, <strong>WB</strong>阶段writeback写入</p><p>因此，每个时钟周期寄存器需要两次读取(A=Reg[rs], B=Reg[rt]) 和一次写入</p><p>为了出气对相同寄存器堆多次读取和一次写入，<strong><em>我们在时钟周期的前半部分写寄存器，后半部分读寄存器</em></strong></p><h4 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h4><p>程序计数器在IF阶段要递增</p><p>ID阶段要计算潜在的分支目标。若分支在ID改变程序计数器？</p><p><br/></p><p>除了要确保流水线中的指令不会在相同时间使用相同的硬件资源，还要确保不同流水级的指令不会互相干扰。这是通过在流水级之间引入 <u>流水线寄存器</u>来实现的。将一个给定的流水级得出的结果存储到流水线寄存器，并在下一个时钟周期作为下一个流水级的输入。</p><center><img src="image-20191013133054888.png" srcset="/img/loading.gif" alt="image-20191013133054888" style="zoom: 30%;" /></center><h1 id="4-流水化的主要阻碍-流水线冒险"><a href="#4-流水化的主要阻碍-流水线冒险" class="headerlink" title="4 流水化的主要阻碍-流水线冒险"></a>4 流水化的主要阻碍-流水线冒险</h1><p>冒险降低来了流水化所能带来的理想加速比<br>冒险共有一下三类  </p><ol><li><p>结构冒险  </p><p>在重叠执行模式下，硬件无法同时支持指令的所有可能组合，就会出现资源冲突 [比如大家都想访问存储器]</p></li><li><p>数据冒险  </p><p>指令之间存在先后顺序，一条指令取决于先前指令的结果</p></li><li><p>控制冒险 </p><p>分支指令以及其他改变程序计数器的指令会导致控制冒险</p></li></ol><p>为了避免冒险，要求流水线中的一些指令延迟时，其他指令能够继续执行 。</p><div class="note note-warning">            <p>这里讨论的流水线，当一条指令被stall时，在指令停顿之后发射的<strong><em>所有指令也会被停顿</em></strong>，之前发射的指令不会被停顿</p>          </div><p><br/></p><h2 id="4-1-带有停顿的流水线性能"><a href="#4-1-带有停顿的流水线性能" class="headerlink" title="4.1 带有停顿的流水线性能"></a>4.1 带有停顿的流水线性能</h2><p>$<br>流水化加速比=\frac{非流水化指令平均执行时间}{流水化指令平均执行时间}$<br>$=\frac{非流水化CPI\times 非流水化时钟周期}{流水化CPI\times 流水化时钟周期}$<br>$=\frac{非流水化CPI}{流水化CPI}\times \frac{非流水化时钟周期}{流水化时钟周期}$</p><p><br/></p><p>流水化处理器的理想CPI几乎总是等于1，算上停顿<br>$<br>流水化CPI=理想CPI+每条指令的流水线停顿时钟周期$<br>$=1+每条指令的流水线停顿时间周期$</p><p>所以</p><script type="math/tex; mode=display">加速比=\frac{非流水化CPI}{1+每条指令的流水线停顿周期}</script><p>如果所有指令周期数相同，等于流水级数目(流水线深度)，那么非流水化CPI=流水线深度</p><script type="math/tex; mode=display">加速比=\frac{流水深度}{1+每条指令的流水线停顿周期}</script><div class="note note-warning">            <p><u>所以，如果没有流水线停顿，加速比=流水线深度</u></p>          </div><h2 id="4-2-结构冒险"><a href="#4-2-结构冒险" class="headerlink" title="4.2 结构冒险"></a>4.2 结构冒险</h2><p>i. 什么是结构冒险</p><blockquote><p>指令重叠执行需要实现功能单元的流水化和资源的复制，以允许在流水线中出现所有可能的指令组合</p><p>如果由于资源冲突而不能容许某些指令组合，就说出现结构冒险</p></blockquote><p>ii. 解决方式</p><p>在发生结构冒险时，使流水线停顿一个时钟周期</p><p>停顿称为 <u>流水线气泡</u>，他们漂浮穿过流水线，占有空间但是不执行有效工作。导致CPI增大</p><p><br/></p><h2 id="4-3-数据冒险"><a href="#4-3-数据冒险" class="headerlink" title="4.3 数据冒险"></a>4.3 数据冒险</h2><p>i. 数据冒险是什么</p><blockquote><p>有些指令依赖于之前指令的结果</p></blockquote><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">DADD</span> <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R3</span><span class="hljs-symbol">DSUB</span> <span class="hljs-built_in">R4</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R5</span><span class="hljs-keyword">AND </span> <span class="hljs-built_in">R6</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R7</span><span class="hljs-symbol">OR</span>   <span class="hljs-built_in">R8</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R9</span><span class="hljs-symbol">XOR</span>  <span class="hljs-built_in">R10</span>,<span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R11</span></code></pre></div><p>DADD后的所有指令都用到了DADD指令的结果R1</p><p>所以在DADD的结果writeback之前，下面的指令都是不能execute的</p><center><img src="image-20191013143518878.png" srcset="/img/loading.gif" alt="image-20191013143518878" style="zoom:30%;" /></center><p>ii. 解决方法</p><p>A. 转发(forwarding)</p><p>转发是一个什么思想呢？ </p><blockquote><p>DSUB需要DADD的结果x, 那么不妨DADD在算出x之后，就把结果给到DSUB需要这个x的位置，而不用等到writeback</p></blockquote><p>转发的工作方式</p><ol><li>来自EX/MEM和MEM/WB流水线寄存器的输入总是被反馈回ALU的输入端</li><li>如果转发硬件检测到前一个ALU操作已经对当前ALU操作的原寄存器进行了写入操作，则控制逻辑选择转发结果作为ALU输入，而不是选择从寄存器堆中读区的值</li></ol><center><img src="https://miaochenlu.github.io/picture/屏幕快照 2019-10-13 下午2.56.04.png" srcset="/img/loading.gif" style="zoom: 30%;" /></center><p>B, 需要停顿的数据冒险</p><p>并非所有的潜在数据冒险都可以通过转发处理</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">LD</span>   <span class="hljs-built_in">R1</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">R2</span>)<span class="hljs-symbol">DSUB</span> <span class="hljs-built_in">R4</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R5</span><span class="hljs-keyword">AND </span> <span class="hljs-built_in">R6</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R7</span><span class="hljs-symbol">OR</span>   <span class="hljs-built_in">R8</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R9</span></code></pre></div><center><img src="image-20191013151122898.png" srcset="/img/loading.gif" alt="image-20191013151122898" style="zoom:30%;" /></center><center><img src="image-20191013151314878.png" srcset="/img/loading.gif" alt="image-20191013151314878" style="zoom:25%;" /></center><h3 id="More-about-data-dependences-and-hazards"><a href="#More-about-data-dependences-and-hazards" class="headerlink" title="More about data dependences and hazards"></a>More about data dependences and hazards</h3><h4 id="A-data-dependences"><a href="#A-data-dependences" class="headerlink" title="A. data dependences"></a>A. data dependences</h4><ol><li>数据相关[真数据相关]</li></ol><p>指令i生成的结果可能会被指令j用到</p><p>指令j数据相关于指令k, 指令k数据相关于指令i</p><center><img="https://miaochenlu.github.io/picture/image-20191223102354535.png" alt="image-20191223102354535" style="zoom:50%;" /></center><ol><li>名称相关</li></ol><p>当两条指令使用相同的寄存器或者存储器位置[称为名称]， 但与该名称相关的指令之间并没有数据流动时，就会发生名称相关。</p><ul><li><p>Anti-dependence: S1 -&gt; S2 </p><p>(i)  S1 executes before S2<br>(ii) S1 reads from a location that is overwritten later by S2</p></li></ul><div class="note note-warning">            <p>WAR</p><ul><li><p>Output dependence: S1 -&gt; S2 </p><p>(i)  S1 executes before S2<br>(ii) S1 and S2 write to the same location </p></li></ul>          </div><p>WAW</p><p>由于没有在指令之间传递值, 所以antidependence和output dependence只是名称相关，不是真数据相关。改变这些指令中使用的名称[寄存器号或者存储器位置],  就可以使这些指令不再冲突。</p><h4 id="B-data-hazards"><a href="#B-data-hazards" class="headerlink" title="B. data hazards"></a>B. data hazards</h4><ul><li>RAW</li><li>WAW: 对应于output dependence。 只有在前一指令stall时允许后一指令继续执行的流水线中，才会存在WAW冒险</li><li>WAR: 对应于antidependence。</li></ul><h2 id="4-4-分支冒险"><a href="#4-4-分支冒险" class="headerlink" title="4.4 分支冒险"></a>4.4 分支冒险</h2><h3 id="i-分支冒险是什么"><a href="#i-分支冒险是什么" class="headerlink" title="i. 分支冒险是什么"></a>i. 分支冒险是什么</h3><p>执行分支指令时，修改后的PC可能等于也可能不等于PC+4。</p><p>如果分支讲PC改到其目标地址，就是选中了分支；否则就是没有选中分支。一般等到ID末尾，完成地址计算和对比之后才会改变PC</p><p>那么还不知到分支指令跳到哪里，pipeline按顺序执行的指令可能不会被执行到。</p><h3 id="ii-解决方法"><a href="#ii-解决方法" class="headerlink" title="ii. 解决方法"></a>ii. 解决方法</h3><p>一旦在ID期间检测到分支，就对该分支之后的指令重新取值。但是这样处理的问题是，如果分支没有被选中，所以事实上已经正确提取了指令，所以IF的重复没有必要</p><p><img src="image-20191021095111.png" srcset="/img/loading.gif" alt="image-20191021095111" style="zoom:50%;" /></p><p>所以，如何降低流水线分支代价？</p><p>4种简单的编译时机制</p><h4 id="A-冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标"><a href="#A-冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标" class="headerlink" title="A. 冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标"></a>A. 冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标</h4><h4 id="B-将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。"><a href="#B-将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。" class="headerlink" title="B. 将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。"></a>B. 将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。</h4><p>这种预测未选中机制的实现方式是继续提取指令，就好像分支指令时一条正常指令一样。但是，如果分支被选中，就要将已经提取的指令转化为空操作，重新开始在目标地址提取指令。</p><p>这一机制的复杂性在于要知道处理器可能何时被指令改变，以及如何撤销这种改变</p><center><img src="image-20191014112116582.png" srcset="/img/loading.gif" alt="image-20191014112116582" style="zoom:35%;" /></center><h4 id="C-将所有分支都看作选中分支"><a href="#C-将所有分支都看作选中分支" class="headerlink" title="C. 将所有分支都看作选中分支"></a>C. 将所有分支都看作选中分支</h4><p>只要对分支指令进行了译码并且计算了目标地址，就假定该分支被选中，开始在目标位置提取和执行。</p><p>但是在我们的五级流水线中，不可能在知道分支输出结果之前知道目标地址，所以这对我们没什么用。</p><h4 id="D-延迟分支"><a href="#D-延迟分支" class="headerlink" title="D. 延迟分支"></a>D. 延迟分支</h4><blockquote><p>分支指令</p><p>依序后续指令[位于delay slots]</p><p>选中时的分支指令</p></blockquote><p>获得编译器支持，编译器让后续指令有效并且可用</p><center><img src="image-20191021095901298.png" srcset="/img/loading.gif" alt="image-20191021095901298" style="zoom: 40%;" ></center><p>延迟调度有局限性，这个局限性是因为</p><blockquote><ol><li>可以排在延迟时隙[delay slots]中的指令有限制</li><li>编译时预测一个分支是否可能被选中的能力有限。为了提高编译器填充delay slots的能力，大多数具有条件分支的处理器引入了<em>canceling</em> or <em>nullifying</em> branch . 在取消分支中，指令包含了预测分支的方向。当分支行为和预期一致时，分支延迟时隙中的指令就想普通的延迟分支一样执行。预测错误时，分支延迟时隙中的指令转为空操作。</li></ol></blockquote><p>看一下这些不同的解决方法效率有什么差别</p><center><img src="image-20191021101747938.png" srcset="/img/loading.gif" alt="image-20191021101747938" style="zoom:50%;" ></center><p>考虑flush pipeline</p><p>unconditional branch指的是像j, jal这种的，这些直到Decode才会知道分支目标，所以penalty=2</p><p>其他conditional，像beq等，需要EXE才知道是否要跳转，所以penalty=3</p><p>这样，考虑predicted untaken</p><p>unconditional 指令被预测不执行，但是一定会执行，代价是2</p><p>conditional的如果没有执行，和预测一致，代价为0。如果和预测不一致，代价为3</p><p>考虑predicted taken</p><p>如果和预测一致。那么在Branch指令的EXE阶段才能知道分支目标，所以要stall 2个时钟周期才能跳转</p><p><br></p><p>当流水线越来越深，分支的潜在代价增加，使用延迟分支是不够的。要更积极地去预测分支。静态机制[依赖编译时信息，成本低]，动态预测[依据程序特性]</p><h4 id="i-静态分支预测"><a href="#i-静态分支预测" class="headerlink" title="i. 静态分支预测"></a>i. 静态分支预测</h4><p>事先收集数据，根据数据来预测分支</p><h4 id="ii-动态分支预测"><a href="#ii-动态分支预测" class="headerlink" title="ii. 动态分支预测"></a>ii. 动态分支预测</h4><p>使用分支预测缓冲区[Branch-Prediction Buffer].</p><p>这是一个cache，分支指令地址的低位部分用来索引，所有访问都会hit。</p><p>这个存储器包含一个bit来标示这个分支最近是否被选中。这个bit可以用来为接下来的这条分支提供指导。如果预测结果和bit不一致，反转bit; 一致则不反转</p><p>但是只有1bit来标示会存在一点问题，比如分支一直被选中，但是某一次没有被选中，bit也会反转，这种反转其实没有必要，会影响效率。</p><p>所以这里提出了2位预测机制。</p><p>两位预测机制，预测必须连续错过两次才会进行修改。</p><center><img src="image-20191021103246990.png" srcset="/img/loading.gif" alt="image-20191021103246990" style="zoom:50%;" ></center><h1 id="5-如何实现流水线"><a href="#5-如何实现流水线" class="headerlink" title="5. 如何实现流水线"></a>5. 如何实现流水线</h1><p>MIPS CPU多周期实现</p><center><img src="image-20191021105802697.png" srcset="/img/loading.gif" alt="image-20191021105802697" style="zoom:45%;" ></center><h2 id="Basic-Pipeline"><a href="#Basic-Pipeline" class="headerlink" title="Basic Pipeline"></a>Basic Pipeline</h2><center><img src="image-20191021110018403.png" srcset="/img/loading.gif" alt="image-20191021110018403" style="zoom:45%;" ></center><h3 id="i-IF"><a href="#i-IF" class="headerlink" title="i. IF"></a>i. IF</h3><div class="hljs"><pre><code class="hljs cpp">IF/ID.IR = Mem[PC];<span class="hljs-comment">//取指令</span><span class="hljs-keyword">if</span>((EX/MEM.opcode == branch) &amp;&amp; EX/MEM.cond) &#123;  IF/IR.NPC = EX/MEM.ALUOutput;  PC = EX/MEM.ALUOutput;&#125; <span class="hljs-keyword">else</span> &#123;  IF/IR.NPC = PC + <span class="hljs-number">4</span>;  PC = PC + <span class="hljs-number">4</span>;&#125;</code></pre></div><h3 id="ii-ID"><a href="#ii-ID" class="headerlink" title="ii. ID"></a>ii. ID</h3><div class="hljs"><pre><code class="hljs cpp">ID/EX.A = Regs[IF/ID.IR[rs]];ID/EX.B = Regs[IF/ID.IR[rt]];ID/EX.NPC = IF/ID.NPC;ID/EX.IR = IF/ID.IR;ID/EX.Imm = sign-extend(IF/ID.IR[immediate]);</code></pre></div><h3 id="iii-EX"><a href="#iii-EX" class="headerlink" title="iii. EX"></a>iii. EX</h3><h4 id="A-ALU-EX"><a href="#A-ALU-EX" class="headerlink" title="A. ALU EX"></a>A. ALU EX</h4><div class="hljs"><pre><code class="hljs cpp">EX/MEM.IR = ID/EX.IR;执行以下之一<span class="hljs-number">1.</span> EX/MEM.ALUOutput = ID/EX.A func ID/EX.B;<span class="hljs-number">2.</span> EX/MEM.ALUOutput = ID/EX.A op ID/EX.Imm</code></pre></div><h4 id="B-Load-Store-EX"><a href="#B-Load-Store-EX" class="headerlink" title="B. Load Store EX"></a>B. Load Store EX</h4><div class="hljs"><pre><code class="hljs cpp">EX/MEM.IR to ID/EX.IR;EX/MEM.ALUOutput = ID/EX.A + ID/EX.imm;EX/MEM.B = ID/EX.B;</code></pre></div><h4 id="C-Branch-EX"><a href="#C-Branch-EX" class="headerlink" title="C. Branch EX"></a>C. Branch EX</h4><div class="hljs"><pre><code class="hljs cpp">EX/MEM.ALUOutput = ID/EX.NPC + (ID/EX.Imm &lt;&lt; <span class="hljs-number">2</span>);EX/MEM.cond = (ID/EX.A == <span class="hljs-number">0</span>);</code></pre></div><h3 id="iv-MEM"><a href="#iv-MEM" class="headerlink" title="iv. MEM"></a>iv. MEM</h3><h4 id="A-ALU-MEM"><a href="#A-ALU-MEM" class="headerlink" title="A. ALU MEM"></a>A. ALU MEM</h4><div class="hljs"><pre><code class="hljs cpp">MEM/WB.IR = EX/MEM.IR;MEM/WB.ALUOutput = EX/MEM.ALUOutput;</code></pre></div><h4 id="B-Load-Store-MEM"><a href="#B-Load-Store-MEM" class="headerlink" title="B. Load Store MEM"></a>B. Load Store MEM</h4><div class="hljs"><pre><code class="hljs cpp">MEM/WB.OR = EX/MEM.IR;<span class="hljs-number">1.</span> MEM/WB.LMD = Mem[EX/MEM.ALUOutput];<span class="hljs-number">2.</span> Mem[EX/MEM.ALUOutput] = EX/MEM.B;</code></pre></div><h3 id="v-WB"><a href="#v-WB" class="headerlink" title="v. WB"></a>v. WB</h3><h4 id="A-ALU-WB"><a href="#A-ALU-WB" class="headerlink" title="A. ALU WB"></a>A. ALU WB</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> Regs[MEM/WB.IR[rd]] = MEM/WB.ALUOutput;<span class="hljs-number">2.</span> Resg[MEM/WB.IR[rt]] = MEM/WB.ALUOutput;</code></pre></div><h4 id="B-Load-Store-WB"><a href="#B-Load-Store-WB" class="headerlink" title="B. Load Store WB"></a>B. Load Store WB</h4><div class="hljs"><pre><code class="hljs cpp">For load onlyRegs[MEM/WB.IR[rt]] = MEM/WB.LMD;</code></pre></div><h2 id="Control-the-Pipeline"><a href="#Control-the-Pipeline" class="headerlink" title="Control the Pipeline"></a>Control the Pipeline</h2><p>instruction issue:</p><blockquote><p>一条指令从ID移入EX的过程</p></blockquote><p>对于整数流水线，所有数据冒险都可以在ID进行检查。</p><p>如果存在数据冒险，这个指令将会在issue之前停顿。</p><p>同样，我们可以确定在ID期间需要哪种转发，并设定适当的控制。</p><center><img src="image-20191021115323894.png" srcset="/img/loading.gif" alt="image-20191021115323894" style="zoom:35%;" /></center><p>pipeline overhead</p><p>due to stage imbalance, pipeline register setup</p><h3 id="Deal-with-forwarding"><a href="#Deal-with-forwarding" class="headerlink" title="Deal with forwarding"></a>Deal with forwarding</h3><center><img="https://miaochenlu.github.io/picture/image-20191222210658336.png" alt="image-20191222210658336" style="zoom:50%;" /></center><h1 id="6-扩展MIPS流水线，以处理多周期操作"><a href="#6-扩展MIPS流水线，以处理多周期操作" class="headerlink" title="6. 扩展MIPS流水线，以处理多周期操作"></a>6. 扩展MIPS流水线，以处理多周期操作</h1><p>扩展mips流水线，以处理浮点运算</p><p>浮点运算的问题</p><blockquote><p>要求所有浮点运算在1个周期内完成时不现实的，甚至2个时钟周期都不太可能</p><p>如果想要在一个时钟周期内完成，就必须降低clock rate, 或者增加大量的逻辑单元。</p><p>所以</p><ul><li>为了完成操作，EX周期可能要根据需要重复多次</li><li>可能存在多个浮点功能单元，如果待发射指令会导致浮点所用功能单元的结构冒险，或者数据冒险，就会出现停顿。</li></ul></blockquote><p>4个独立的功能单元</p><ul><li>主整数单元，处理load, store, 整数ALU operation, branch</li><li>浮点与整数乘法器</li><li>浮点加法器，处理浮点加、减和转换</li><li>浮点和整型除法器</li></ul><p>假定这些功能单元的执行级没有实现流水化</p><center><img="https://miaochenlu.github.io/picture/image-20191111101801471.png" alt="image-20191111101801471" style="zoom:50%;" /></center><p>两个指标</p><ul><li><p>latency</p><p>the number of intervening cycles between an instruction that produces a result and an instruction that uses the result. 一条指令产生结果后，下一条指令等待多久才可以使用这个结果。注意，是等待。</p><blockquote><p>Essentially, pipeline <strong>latency</strong> is 1 cycle less than the depth of the execution pipeline, which is the number of stages from the <strong>EX stage</strong> to the stage that produces the result </p></blockquote></li><li><p>initiation/repeat interval</p><p>同一类型的指令执行之间必须间隔的周期数。比如，integer ALU的一条指令开始执行，下一条integer ALU指令需要在他后面一个周期才能开始执行</p></li></ul><center><img="https://miaochenlu.github.io/picture/IMG_C3E4F59B24C4-1.png" alt="IMG_C3E4F59B24C4-1" style="zoom:50%;" /></center><p><img src="IMG_C3E4F59B24C4.png" srcset="/img/loading.gif" alt="IMG_C3E4F59B24C4-1" style="zoom:50%;" /></p><p>instruction issue: 从ID到EX的阶段</p><p><center><img="image-20191111103138887.png" alt="image-20191111103138887" style="zoom:50%;" /></center></p><p><center><img="image-20191111104720076.png" alt="image-20191111104720076" style="zoom:50%;" /></center></p><table>  <tr>    <td>      <img src="image-20191111103409484.png" srcset="/img/loading.gif" alt="image-20191111103409484" style="zoom:50%;" />    </td>    <td>      <img src="image-20191111103455864.png" srcset="/img/loading.gif" alt="image-20191111103455864" style="zoom:50%;" />    </td>  </tr></table><table>  <tr>    <td>      <img src="image-20191111103637824.png" srcset="/img/loading.gif" alt="image-20191111103637824" style="zoom:50%;" />    </td>    <td>      <img src="image-20191111104058863.png" srcset="/img/loading.gif" alt="image-20191111104058863" style="zoom:50%;" />    </td>  </tr></table>]]></content>
    
    
    <categories>
      
      <category>Computer Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer network--物理层</title>
    <link href="/2019/09/17/PhysicalLayer/"/>
    <url>/2019/09/17/PhysicalLayer/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据通信的理论基础"><a href="#1-数据通信的理论基础" class="headerlink" title="1 数据通信的理论基础"></a>1 数据通信的理论基础</h1><h2 id="1-1傅里叶分析"><a href="#1-1傅里叶分析" class="headerlink" title="1.1傅里叶分析"></a>1.1傅里叶分析</h2><p>任何一个行为合理周期为T的函数g(t)，都可以表示成正弦函数和余弦函数组成的无穷级数</p><script type="math/tex; mode=display">g(t)=\frac{1}{2}c+\sum_{n=1}^{\infty}a_nsin(2\pi nft)+\sum_{n=1}^{\infty}b_ncos(2\pi nft)</script><p>其中$f=\frac{1}{T}$是基本频率，$a_n$和$b_n$是n次谐波的正弦振幅和余弦振幅,c是常数</p><p><br/></p><h2 id="1-2-带宽有限的信号"><a href="#1-2-带宽有限的信号" class="headerlink" title="1.2 带宽有限的信号"></a>1.2 带宽有限的信号</h2><p>我们考虑一个特殊的例子：</p><p>传输ASCII字符b,这个字符被编码成一个8比特长的字节，01100010</p><p>可以得到系数</p><center><img src="image-20190917211816031.png" srcset="/img/loading.gif" alt="image-20190917211816031" style="zoom:50%;" /></center><blockquote><p> 所有传输设施在传输过程中都要损失一些能量    </p><p> 如果所有傅里叶分量都等量衰减，则结果信号将会在振幅上有所减小，但形状不会变。  </p><p>但是，实际情况是，所有传输设施对于不同傅里叶分量的衰减程度并不相同，这会导致接收端接收到的信号发生<strong>变形</strong>。  </p><p>一般对导线来说，在[0,$f_c$]的频率范围，振幅在传输过程中不回衰减，而在$f_c$这个截止频率之上的所有频率的振幅都会有不同程度的减弱。    </p><p>这个在传输过程中振幅不回明显减弱的频率的宽度就称为<strong>带宽</strong>   </p><p>但是截止频率不是一个突变的量，不是说到达某个阈值，振幅就突然减弱了，所以通常引用的带宽是指从0到接收能量保留一半到那个频率位置</p></blockquote><p>带宽是传输介质的一种物理特性，取决于介质  </p><p>一般将从0到某个最大频率的信号称为<strong>基带信号</strong>，将被搬移并占用某个更大频率范围的信号称为<strong>通带信号</strong>  </p><center><img src="image-20190917211449784.png" srcset="/img/loading.gif" alt="image-20190917211449784" style="zoom: 67%;" /></center><p><br/></p><h4 id="带宽很低，会发生什么？"><a href="#带宽很低，会发生什么？" class="headerlink" title="带宽很低，会发生什么？"></a>带宽很低，会发生什么？</h4><p>如果带宽很低，则只有几个最低频率才能被传输</p><p>假设比特率为$b$ bit/s[每秒发送8个比特]</p><p>则发送8个比特所需要的时间是$\frac{8}{b}$秒</p><p>所以第一个谐波频率是$\frac{b}{8}$赫兹</p><p>如果截止频率是3000hz,则可以通过的最高谐波数为</p><script type="math/tex; mode=display">\frac{3000}{\frac{8}{b}}</script><center><img src="image-20190917213738345.png" srcset="/img/loading.gif" alt="image-20190917213738345" style="zoom:50%;" /></center><p>如上图所示，如果能发送的频率数很少，我们就没办法精确表示周期函数</p><p><br/></p><h2 id="1-3-信道的最大数据速率"><a href="#1-3-信道的最大数据速率" class="headerlink" title="1.3 信道的最大数据速率"></a>1.3 信道的最大数据速率</h2><p><a href="https://blog.csdn.net/supreme42/article/details/7734763" target="_blank" rel="noopener">一些概念</a></p><p>波特率[baud rate/ symbol rate]</p><blockquote><p>波特率指的是信号每秒钟电平变化的次数，单位是<em>Hz</em></p></blockquote><p>比特率</p><blockquote><p>信号每秒钟传输的数据的位数。计算机中数据都是用<em>0</em>，<em>1</em>表示的，所以比特率也就是每秒钟传输<em>0</em>和<em>1</em>的个数，单位是<em>bps</em>[<em>bit per second</em>]</p></blockquote><p>波特率和比特率的关系</p><blockquote><p>我们可以假设一个信号只有两个电平，那么这个时候可以把低电平理解为<em>“0”</em>，高电平理解为<em>“1”</em>，这样每秒钟电平变化的次数也就是传输的<em>0</em>，<em>1</em>个数了，即比特率 <em>=</em> 波特率。</p><p>但是有些信号可能不止两个电平，比如一个四电平的信号，那么每个电平就可以被理解成<em>“00”</em>，<em>“01”</em>，<em>“10”</em>，<em>“11”</em>，这样每次电平变化就能传输两位的数据了，即比特率 <em>= 2 ×</em> 波特率。</p><p>一般的，$bit\,rate = buad\,rate × log_2V$，这里V就是信号电平的个数。</p></blockquote><p>Nyquist证明：如果一个任意信号通过一个带宽为B的低通滤波器，那么只要进行每秒2B次确切采样[一个周期采样2次]，就可以完全重构出被过滤的信号</p><p>不考虑噪声，如果信号包含了V个离散等级，那么公式可以写为</p><script type="math/tex; mode=display">最大数据速率=2Blog_2V(bit/s)</script><p>[最大symbol rate=$2B\,symbol/s$]</p><blockquote><p>每秒采样2B次，也就是采样了2B个电平信号</p><p>也就是采样了2BlogV个bits</p></blockquote><p>事实上，要想重构出信号，每秒2B次采样是不够的，要多一些才够。</p><center><img src="9FC21EC72573A17040AD0FCD3C37A790.png" srcset="/img/loading.gif" alt="9FC21EC72573A17040AD0FCD3C37A790" style="zoom:10%;" /></center><p><br/></p><h4 id="接下来考虑如果存在随机噪声"><a href="#接下来考虑如果存在随机噪声" class="headerlink" title="接下来考虑如果存在随机噪声"></a>接下来考虑如果存在随机噪声</h4><script type="math/tex; mode=display">信噪比(SNR)=\frac{信号功率}{噪声功率}=\frac{S}{N}</script><p>通常将其写成对数形式$10log_{10}\frac{S}{N}$,单位为分贝. </p><p>香农得出：对于一条带宽为B赫兹，噪声比是$\frac{S}{N}$的有噪声通道，他的最大数据传输速率是. </p><script type="math/tex; mode=display">最大比特率=Blog_2{(1+\frac{S}{N})}</script><h2 id="2-引导性传输介质-有线传输"><a href="#2-引导性传输介质-有线传输" class="headerlink" title="2 引导性传输介质[有线传输]"></a>2 引导性传输介质[有线传输]</h2><p>物理层的作用是将bit从一条机器传输到另一台机器。传输所用的物理介质会在传输带宽、延迟、成本等方面产生差别。</p><p>可以将介质分为</p><ul><li>引导性介质：如铜线、光纤</li><li>非引导性介质：如卫星、激光</li></ul><p><br/></p><h3 id="2-1-磁介质"><a href="#2-1-磁介质" class="headerlink" title="2.1 磁介质"></a>2.1 磁介质</h3><p>Never underestimate the bandwidth of station wagon full of tapes hurtling down the highway.</p><h3 id="2-2-双绞线"><a href="#2-2-双绞线" class="headerlink" title="2.2 双绞线"></a>2.2 双绞线</h3><p>构成</p><blockquote><p>双绞线由两根铜线以螺旋状的形式紧紧地绞在一起。</p></blockquote><p>之所以要绞在一起，是因为这样不同电线产生的干扰波会相互抵消，显著降低电线的辐射。</p><p>并且，信号以两根电线的电压差来承载，这样对外部噪声有更好的免疫力，因为噪声对两根电线的干扰是相同的，因此电压差不会改变。</p><p><br/></p><p>双绞线既可以传输模拟信号，也可以传输数字信号。</p><p>传输方向：</p><ul><li>全双工链路[full-duplex]：可以双向同时使用的链路</li><li>半双工链路half-duplex]：可以双向使用但一次只能使用一个方向</li><li>单工链路[simplex]：只允许一个方向上传输</li></ul><p>双绞线的type:</p><blockquote><p>– Category 5 [100Mbps, 1Gbps]<br>– Category 6 [10Gbps]<br>– Category 7 [Shielded Twisted Pair]</p></blockquote><center><img src="image-20191007125121828.png" srcset="/img/loading.gif" alt="image-20191007125121828" style="zoom:33%;" /></center><p>双绞线的缺点是：</p><p>传输距离远的话，信号衰减很厉害，需要使用中继器</p><h3 id="2-3-同轴电缆-coaxial-cable"><a href="#2-3-同轴电缆-coaxial-cable" class="headerlink" title="2.3 同轴电缆[coaxial cable]"></a>2.3 同轴电缆[coaxial cable]</h3><p>构成：</p><blockquote><p>硬的铜芯，外面包上一层绝缘材料，绝缘材料的外面是网状圆柱导体，外层导体再覆盖上一层保护塑料外套</p></blockquote><center><img src="image-20191007133601513.png" srcset="/img/loading.gif" alt="image-20191007133601513" style="zoom: 33%;" /></center><p>特点：</p><blockquote><p>同轴电缆的结构和屏蔽性使得它既有很高的带宽，又有很好的抗噪性。</p><p>这点比双绞线更优秀，因此也比双绞线传的远</p></blockquote><h3 id="2-4-电力线-power-line"><a href="#2-4-电力线-power-line" class="headerlink" title="2.4 电力线[power line]"></a>2.4 电力线[power line]</h3><center><img src="image-20191007133946196.png" srcset="/img/loading.gif" alt="image-20191007133946196" style="zoom: 33%;" /></center><h3 id="2-5-Fiber-optics"><a href="#2-5-Fiber-optics" class="headerlink" title="2.5 Fiber optics"></a>2.5 Fiber optics</h3><center><img src="page40image34686176.png" srcset="/img/loading.gif" alt="page40image34686176.jpg" style="zoom:33%;" /></center><p>Types:</p><blockquote><p>Multimode多模：many different rays</p><p>Unimode单模：single rays, longer distance</p></blockquote><p>Transmission of light through fiber:</p><blockquote><p>-Attenuation [衰减] of light through fiber in the infrared region.</p><p>– Three wavelength bands are used for optical communication. They are centered at 0.85, 1.30, and 1.55 micros [微米].</p></blockquote><center><img src="page41image34714624.png" srcset="/img/loading.gif" alt="page41image34714624.jpg" style="zoom: 33%;" /></center><h4 id="光缆："><a href="#光缆：" class="headerlink" title="光缆："></a><u>光缆</u>：</h4><p>构成：</p><blockquote><p>中间core是玻璃芯，光秒冲通过它传播</p><p>玻璃芯外面是一个玻璃覆盖层[cladding]，覆盖层的折射率比玻璃低，这样可以限制所有光都限制在玻璃芯内[全反射]</p><p>最外面是一层塑料封套[jacket],用来保护里面的玻璃包层</p><p>光纤通常被扎捆成束，最外面再加一层保护套</p></blockquote><center><img src="page42image34731632.png" srcset="/img/loading.gif" alt="page42image34731632.jpg" style="zoom:35%;" /></center><p>信号源一半有两种光源：发光LED和半导体激光</p><center><img src="page44image34725184.png" srcset="/img/loading.gif" alt="page44image34725184.jpg" style="zoom:33%;" /></center><h4 id="光纤和铜线的比较"><a href="#光纤和铜线的比较" class="headerlink" title="光纤和铜线的比较"></a><u>光纤和铜线的比较</u></h4><p>– Advantages</p><ul><li>Higher bandwidths and Low attenuation.</li><li>Not being affected by power surges, electromagnetic interference, or power failures.</li><li>Not affected by corrosive chemicals in the air.</li><li>Thin and lightweight.</li><li>Fibers do not leak light and quite difficult to tap.</li></ul><p>– Disadvantages</p><ul><li><p>Less familiar technology.</p><p>要求较高的操作技能，光纤被过度弯曲容易折断</p></li><li><p>Fiber interfaces more expensive.</p></li></ul><p>– Conclusion: For new routes [longer ones], fiber win</p><h1 id="3-无线传输"><a href="#3-无线传输" class="headerlink" title="3 无线传输"></a>3 无线传输</h1><h2 id="3-1电磁频谱"><a href="#3-1电磁频谱" class="headerlink" title="3.1电磁频谱"></a>3.1电磁频谱</h2><center><img src="image-20191007140913262.png" srcset="/img/loading.gif" alt="image-20191007140913262" style="zoom:30%;" /></center><p>由香农定理我们知道一个电磁波的信号能够携带的信息量与带宽成正比，从图中可以看到光纤带宽是多么宽</p><p>Some spread its frequency over a <em>wide frequency band</em>[spread spectrum, 扩频].</p><p>– Frequency hopping spread spectrum [military, 802.11, Bluetooth]</p><p>– Direct sequence spread spectrum [3G mobile phones]</p><p>– UWB [UltraWideBand]</p><center><img src="page49image35151168.png" srcset="/img/loading.gif" alt="page49image35151168.jpg" style="zoom:33%;" /></center><h3 id="3-2-Radar"><a href="#3-2-Radar" class="headerlink" title="3.2 Radar"></a>3.2 Radar</h3><h3 id="3-3-Radio-transmission"><a href="#3-3-Radio-transmission" class="headerlink" title="3.3 Radio transmission"></a>3.3 Radio transmission</h3><p>[a] In the VLF, LF, and MF bands, radio waves follow the curvature of the earth.</p><p>[b] In the HF band, they bounce off the ionosphere [电离层].</p><center><img src="page52image35155536.png" srcset="/img/loading.gif" alt="page52image35155536.jpg" style="zoom:33%;" /></center><h3 id="3-4-Microwave-transmission"><a href="#3-4-Microwave-transmission" class="headerlink" title="3.4 Microwave transmission"></a>3.4 Microwave transmission</h3><h1 id="4-数字调制与多路复用"><a href="#4-数字调制与多路复用" class="headerlink" title="4 数字调制与多路复用"></a>4 数字调制与多路复用</h1><h4 id="什么是数字调制？"><a href="#什么是数字调制？" class="headerlink" title="什么是数字调制？"></a>什么是数字调制？</h4><blockquote><p>比特与代表他们的信号之间的转换过程称为<strong>数字调制</strong></p></blockquote><p><br/></p><p>我们首先来看如何把<strong>比特直接转换成信号</strong>的方案，这些方案导致了<strong>基带传输</strong></p><blockquote><p>基带传输是指：信号的传输占有传输介质上从0到最大值之间的全部频率</p></blockquote><p>然后我们看通过调节载波信号的幅值、相位或者频率来运载比特的模式，这些方案导致了<strong>通带传输</strong></p><blockquote><p>通带传输是指：信号占据了以载波信号频率为中心的一段频带</p></blockquote><p><br/></p><p>信道通常被多个信号共享，这种信道的共享形式称为<strong>多路复用技术</strong></p><p>多路复用技术可以通过：时分复用、频分复用、码分复用 实现</p><h2 id="4-1-基带传输"><a href="#4-1-基带传输" class="headerlink" title="4.1 基带传输"></a>4.1 基带传输</h2><center><img src="image-20200101212239647.png" srcset="/img/loading.gif" alt="image-20200101212239647" style="zoom:50%;" /></center><h3 id="NRZ"><a href="#NRZ" class="headerlink" title="NRZ"></a>NRZ</h3><p>翻转代表1，不翻转代表0</p><p>一旦NRZ信号被发出去，它沿线缆传播。另一端的接收器以一定周期对信号采样，然后把采样信号转换成比特。</p><p>Problem:</p><blockquote><p>a long run of 0s or 1s leaves the signal unchanged. </p><p>After a while it is hard to tell the bits apart, as 15 zeros look much like 16 zeros unless you have a very accurate clock.</p></blockquote><p>Accurate clock: </p><blockquote><p> For all schemes that encode bits into symbols, the receiver must know <strong>when one symbol ends and the next symbol begins</strong> to correctly decode the bits.</p></blockquote><p>一般来说，accurate clock是很难做到的，那么我们该怎么办呢？</p><h4 id="Clock-Recovery"><a href="#Clock-Recovery" class="headerlink" title="Clock Recovery"></a><u>Clock Recovery</u></h4><ul><li><p>一种方法，额外拉一根时钟线，给接收器发送单独的时钟信号</p><p>这个方法不好，因为这很浪费，用一根额外的线来发送时钟，还不如用它来发送数据呢</p></li></ul><ul><li>A clever trick is to mix the clock signal with the data signal by XORing them together so that no extra line is needed.→<strong><u>Manchester Encoding</u></strong></li></ul><p>  <strong><u>Manchester Encoding</u></strong>的方法是，时钟的频率是比特率的两倍，也就是在一个bit 时间内，时钟会产生一次跳变。时钟XOR bit，产生输出</p><p>  如上图所示</p><blockquote><p> 第一个bit时间t内，传输的bit是1，时钟在[0,t/2]内是0，与bit 1异或，编码成1; </p><p> 在[t/2, t]内时钟跳变到1，与bit 0异或，编码成0.</p><p> 因此我们在第一个bit时间看到的编码先是1后翻转到0</p></blockquote><p>  问题：需要两倍于NRZ的带宽，一个bit时间他要传输两个信号</p><ul><li>As a step in the right direction, we can simplify the situation by encoding a 1 as a transition and a 0 as no transition, or vice versa.→<strong><u>NRZI</u></strong> [Non-Return-to- Zero Inverted,不归零倒相制, Used in USB]</li></ul><p>  <strong><u>NRZI</u></strong>方法是：编码有跳变表示1，编码无跳变表示0</p><p>  这样，再长的一串1都不会产生时钟恢复问题；但是一长串的0仍然有问题</p><ul><li><p>Problem: long runs of 0s?→<strong><u>4B/5B</u></strong></p><p><strong><u>4B/5B</u></strong>的方法是：每4个bits被映射成一个5bits的模式，映射按照一张固定的转换表进行，5bits的选择使得映射结果永远不会出现连续3个0</p><center><img src="page63image36690640.png" srcset="/img/loading.gif" alt="page63image36690640.png" style="zoom:33%;" /></center><p>问题：增加了25%的带宽</p></li></ul><p><br/></p><h2 id="4-2-通带传输"><a href="#4-2-通带传输" class="headerlink" title="4.2 通带传输"></a>4.2 通带传输</h2><p>一般情况下，我们在一个信道上发送信息使用的频率范围并不是从0开始的。对于无线信道来说，发送非常低频率的信号不切实际，因为天线的大小与信号的波长成比例，低频信号需要很大的天线。</p><p>发射频率一般是由监管约束和避免干扰的需要决定的</p><h3 id="4-2-1-数字调试"><a href="#4-2-1-数字调试" class="headerlink" title="4.2.1 数字调试"></a>4.2.1 数字调试</h3><center><img src="image-20191007153614734.png" srcset="/img/loading.gif" alt="image-20191007153614734" style="zoom:50%;" /></center><h4 id="A-幅移键控-ASK-Amplitude-Shift-Keying"><a href="#A-幅移键控-ASK-Amplitude-Shift-Keying" class="headerlink" title="A 幅移键控[ASK, Amplitude Shift Keying]"></a>A 幅移键控[ASK, Amplitude Shift Keying]</h4><p>通过采用不同的振幅表示0和1</p><blockquote><p>如上图(b)所示，这里采用非零幅值和一个零幅值</p></blockquote><h4 id="B-频移键控-FSK-Frequency-Shift-Keying"><a href="#B-频移键控-FSK-Frequency-Shift-Keying" class="headerlink" title="B 频移键控[FSK, Frequency Shift Keying]"></a>B 频移键控[FSK, Frequency Shift Keying]</h4><p>采用两个或更多的频率</p><blockquote><p>如上图[c]所示，使用两个频率表示0和1</p></blockquote><h4 id="C-相移键控-PSK-Phase-Shift-Keying"><a href="#C-相移键控-PSK-Phase-Shift-Keying" class="headerlink" title="C 相移键控[PSK, Phase Shift Keying]"></a>C 相移键控[PSK, Phase Shift Keying]</h4><p>在每个符号的周期中，系统把载波波形偏移0度或者180度。由于只有两个相位，这种调制方法称为二进制相移键控[BPSK]，这里的二进制表示的是两个符号</p><blockquote><p>如上图[d]所示，使用两种相位量表示0和1</p></blockquote><p>当然，我们可以用更多数量的偏移。比如用4个偏移，45，135，225，315，那么每个符号可以表示2bit。这种称为正交相移键控[QPSK, Quadrature]</p><h4 id="D-集大成者"><a href="#D-集大成者" class="headerlink" title="D 集大成者"></a>D 集大成者</h4><p>我们可以综合以上调制方式，使得每个符号表示更多的bit.</p><p>我们选择综合振幅和相位。为什么不考虑频率呢？因为频率和相位有关</p><p><br/></p><p>我们给出星座图</p><blockquote><p> 一个点的相位是以他为起点到原点的线与x轴正方向的夹角</p><p> 一个点的振幅是他到原点的距离</p></blockquote><center><img src="image-20191007154637608.png" srcset="/img/loading.gif" alt="image-20191007154637608" style="zoom: 33%;" /></center><blockquote><p>如图[b], QAM-16：</p><p>一共有16个符号，16个符号可以表示出4bits的所有组合</p><p>因此一个符号可以传输4个比特</p><p>同样，如图[c], QAM-64</p><p>一共有64个符号，一个符号可以传输6bits [..$2^6=64$]</p></blockquote><h2 id="4-3-Multiplexing"><a href="#4-3-Multiplexing" class="headerlink" title="4.3 Multiplexing"></a>4.3 Multiplexing</h2><h3 id="4-3-1-频分复用-FDM-Frequency-Division-Multiplexing"><a href="#4-3-1-频分复用-FDM-Frequency-Division-Multiplexing" class="headerlink" title="4.3.1 频分复用[FDM,Frequency Division Multiplexing]"></a>4.3.1 频分复用[FDM,Frequency Division Multiplexing]</h3><p>利用通带传输的优势使多个用户共享一个信道。</p><p>FDM将频谱分成几个频段，每个用户完全拥有其中一个频段来发送自己的信号</p><center><img src="image-20191005234836200.png" srcset="/img/loading.gif" alt="image-20191005234836200" style="zoom: 40%;" /></center><h4 id="正交频分复用-OFDM-orthogonal"><a href="#正交频分复用-OFDM-orthogonal" class="headerlink" title="正交频分复用[OFDM,orthogonal]"></a>正交频分复用[OFDM,orthogonal]</h4><p>信道带宽被分成许多独立发送数据的子载波，每个子载波之间频率的间隔是$\Delta f$</p><p>每个子载波发出的信号虽然可以扩散到相邻子载波，但是每个子载波的频率响应被设计成在相邻子载波的中心为0。因此，可以在子载波中心频率采样而不会收到其邻居的干扰</p><center><img src="image-20191007160446233.png" srcset="/img/loading.gif" alt="image-20191007160446233" style="zoom:40%;" /></center><h3 id="4-3-2-时分复用"><a href="#4-3-2-时分复用" class="headerlink" title="4.3.2 时分复用"></a>4.3.2 时分复用</h3><p>用户以循环的方式轮流工作。每个用户周期性获得整个带宽非常短的一个时间</p><center><img src="image-20191005234914576.png" srcset="/img/loading.gif" alt="image-20191005234914576" style="zoom:40%;" /></center><h3 id="4-3-3-码分复用"><a href="#4-3-3-码分复用" class="headerlink" title="4.3.3 码分复用"></a>4.3.3 码分复用</h3><p>传输一个bit的时间被划分成m个更短的时间间隔，称这个时间间隔为<u>码片</u>[chip]。每个站分配得到唯一的m位码，称为 <u>码片序列</u></p><p>如果要发送bit 1,站就发送分配给他的码片序列；如果要发送bit 0,站就发送分配给他的码片序列的反码。</p><blockquote><p>m=8,即一个bit时间传输的码片序列是8位的。</p><p>如果A站分配到的码片序列为[-1-1-1+1+1-1+1+1]</p><p>那么如果A想发送bit 1，就发送码片序列[-1-1-1+1+1-1+1+1]</p><p>如果A想发送 bit 0, 就发送码片序列[+1+1+1-1-1+1-1-1]</p></blockquote><p>码片序列的要求：</p><blockquote><p> 所有的码片序列都要两两正交</p></blockquote><center><img src="image-20191006000007082.png" srcset="/img/loading.gif" alt="image-20191006000007082" style="zoom:35%;" /></center><p>A,B,C,D 是发送信号的4个station，他们的码片序列两两正交。</p><p>S1,S2,…S6是6个例子,S6表示这个比特时间A,B,D发送了bit 1，C发送了bit 0。但是我们收到的是S6这个不同站的信号都混淆在一起的整体。怎么把C站发送的比特提取出来呢？</p><p>方法是S6与C做归一化内积。即$S_6\cdot C=[2-2+0-2+0-2-4+0]/8=-1$</p><p>因此我们知道在S6所处的这个比特时间内，C站传输了bit 0。</p><blockquote><p>内积结果</p><p>=1 说明该站发送了 bit 1</p><p>=-1说明该站发送了bit 0</p><p>=0 说明该站没有发送数据</p></blockquote><h1 id="5-公共电话交换网络"><a href="#5-公共电话交换网络" class="headerlink" title="5 公共电话交换网络"></a>5 公共电话交换网络</h1><p>How to connect computers?</p><blockquote><p>For small number of computers and a local area</p><ul><li>LAN </li></ul><p>For a large number of computers or a wide area or lacking right of way</p><ul><li>PSTN [Public Switched Telephone Network]</li></ul></blockquote><h2 id="5-1-Structure-of-the-Telephone-System"><a href="#5-1-Structure-of-the-Telephone-System" class="headerlink" title="5.1 Structure of the Telephone System"></a>5.1 Structure of the Telephone System</h2><p>电话网络的变迁</p><center><img src="image-20191007161859322.png" srcset="/img/loading.gif" alt="image-20191007161859322" style="zoom:40%;" /></center><p>Bell system model</p><p>Levels:</p><ul><li>End office 本地局</li><li>toll office 长途局</li><li>primary office 初级局</li><li>Sectional office 地区局</li><li>Regional office 区域局</li></ul><p>Major components </p><ul><li><p>Local loops [本地回路]: 进入家庭和公司的模拟双绞线</p></li><li><p>Trunks [干线]: 连接交换局的数字光纤</p></li><li><p>Switching offices [交换局]:电话呼叫在这里从一条中继线被接入另一条中继线</p></li></ul><center><img src="image-2019100742053.png" srcset="/img/loading.gif" alt="屏幕快照 2019-10-07 下午4.20.53" style="zoom:50%;" /></center><h2 id="5-1-本地回路：调制解调器、ADSL、光纤"><a href="#5-1-本地回路：调制解调器、ADSL、光纤" class="headerlink" title="5.1 本地回路：调制解调器、ADSL、光纤"></a>5.1 本地回路：调制解调器、ADSL、光纤</h2><h3 id="A-电话调制解调器"><a href="#A-电话调制解调器" class="headerlink" title="A 电话调制解调器"></a>A 电话调制解调器</h3><p>要在物理信道上发送比特，必须把比特转换为可以在信道上传输的模拟信号。这个方式我们在上一节已经学过。</p><p>在信号的另一端，模拟信号要被还原成比特</p><p><br/></p><p><strong><u>调制解调器</u></strong></p><p>是什么</p><blockquote><p>执行数字比特流和模拟信号流之间转换的设备就是调制解调器[modem]</p><p>调制解调器是调制器[modulator]和解调器[demodulator]的缩写</p></blockquote><center><img src="page102image35767104.png" srcset="/img/loading.gif" alt="page102image35767104.png" style="zoom:70%;" /> </center>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CA - Instruction Set</title>
    <link href="/2019/09/08/ComputerArchitecture/instructionSet/"/>
    <url>/2019/09/08/ComputerArchitecture/instructionSet/</url>
    
    <content type="html"><![CDATA[<h1 id="附录A-指令集基本原理"><a href="#附录A-指令集基本原理" class="headerlink" title="附录A 指令集基本原理 "></a><a name="ISA">附录A 指令集基本原理 </a></h1><h1 id="1-What-is-ISA"><a href="#1-What-is-ISA" class="headerlink" title="1 What is ISA?"></a>1 What is ISA?</h1><p>ISA: Instruction Set Architecture</p><p><img src="image-20190930101228492.png" srcset="/img/loading.gif" alt="image-20190930101228492" style="zoom:50%;" /></p><h1 id="2-What-types-of-ISA"><a href="#2-What-types-of-ISA" class="headerlink" title="2 What types of ISA?"></a>2 What types of ISA?</h1><h3 id="2-1-Basis"><a href="#2-1-Basis" class="headerlink" title="2.1 Basis"></a>2.1 Basis</h3><ul><li>type of internal storage</li></ul><blockquote><p>stack</p><p>accumulator</p><p>Register-memory</p><p>Register-register/load-store</p></blockquote><p><br/></p><p>先来解释一下implicit operand和explicit operand</p><ul><li>explicit operand</li></ul><p>明确到哪个地方去取的操作数，比如到某一个由指令确定的<strong><em>寄存器</em></strong>，或者内存中一个由指令确定的<strong><em>存储器地址</em></strong></p><ul><li>implicit operand</li></ul><p>不明确的取值位置，但是系统默认了。比如stack architecture就是默认到stack头部去取，accumulator architecture就是默认到accumulator中去取。</p><p><br/></p><p><img src="image-20191218224444341.png" srcset="/img/loading.gif" alt="image-20191218224444341" style="zoom:50%;" /></p><p>C=A+B的代码示例</p><p><img src="image-20191218224500000.png" srcset="/img/loading.gif" alt="image-20191218224500000" style="zoom:50%;" /></p><p>example problem</p><p><img src="image-20191218224924929.png" srcset="/img/loading.gif" alt="image-20191218224924929" style="zoom:50%;" /></p><h4 id="2-1-1-Stack-Architecture"><a href="#2-1-1-Stack-Architecture" class="headerlink" title="2.1.1 Stack Architecture"></a>2.1.1 Stack Architecture</h4><p><strong><em><u>operand</u></em></strong>:</p><blockquote><p> 2 <strong><em><u>implicit</u></em></strong> operands on the top of the stack(<strong><em>TOS</em></strong>)</p></blockquote><p>用图来看一下以下操作的过程</p><div class="hljs"><pre><code class="hljs armasm">C = A + <span class="hljs-keyword">B </span>(memory locations)<span class="hljs-keyword">Push </span>A<span class="hljs-keyword">Push </span><span class="hljs-keyword">B</span><span class="hljs-keyword">Add </span><span class="hljs-keyword">Pop </span>C</code></pre></div> <table>   <tr>     <td>       <img src="image-20190930102555608.png" srcset="/img/loading.gif" alt="image-20190930102555608" title="original"/>     </td>     <td>  <img src="image-20190930102855084.png" srcset="/img/loading.gif" alt="image-20190930102855084" title="push A"/>     </td>     <td>  <img src="image-20190930103000391.png" srcset="/img/loading.gif" alt="image-20190930103000391" title="push B"  />     </td>     <td>  <img src="image-20190930103037853.png" srcset="/img/loading.gif" alt="image-20190930103037853" title="Add"  />     </td>     <td>  <img src="image-20190930103101742.png" srcset="/img/loading.gif" alt="image-20190930103101742" title="pop C" />     </td>   </tr> </table><h4 id="2-1-2-Accumulator-Architecture"><a href="#2-1-2-Accumulator-Architecture" class="headerlink" title="2.1.2 Accumulator Architecture"></a>2.1.2 Accumulator Architecture</h4><p><strong><em><u>operand</u></em></strong></p><blockquote><p>one implicit operand: accumulator</p><p>one explicit operand: mem location</p></blockquote><p>看一下以下操作的过程</p><div class="hljs"><pre><code class="hljs fortran">C = A + BLoad AAdd BStore Caccumulator is both an <span class="hljs-keyword">implicit</span> input operand and a result</code></pre></div><table>  <tr>    <td>      <img src="image-20190930115553486.png" srcset="/img/loading.gif" alt="image-20190930115553486" title="original"/>    </td>    <td>  <img src="image-20190930115635931.png" srcset="/img/loading.gif" alt="image-20190930115635931" title="load A"/>    </td>      <td>  <img src="image-20190930115734010.png" srcset="/img/loading.gif" alt="image-20190930115734010" title="add B"/>    </td>    <td>  <img src="image-20190930115804883.png" srcset="/img/loading.gif" alt="image-20190930115804883" title="store C"/>    </td>  </tr></table><h1 id="3-存储器寻址"><a href="#3-存储器寻址" class="headerlink" title="3. 存储器寻址"></a>3. 存储器寻址</h1><h2 id="3-1-解释存储器地址"><a href="#3-1-解释存储器地址" class="headerlink" title="3.1 解释存储器地址"></a>3.1 解释存储器地址</h2><p>i. 关于如何对一个较大对象中的字节排序：</p><ul><li>Little Endian : store least significant byte in the smallest address</li></ul><p><img src="image-20191014101250484.png" srcset="/img/loading.gif" alt="image-20191014101250484" style="zoom:40%;" /></p><ul><li>Big Endian : store most significant byte in the smallest address</li></ul><p><img src="image-20191014101429477.png" srcset="/img/loading.gif" alt="image-20191014101429477" style="zoom:40%;" /></p><p>ii. 字节对齐</p><p>大小为s bytes的对象，字节地址为A, 如果$A\; mod\;s = 0$ , 那么是字节对齐的</p><p><img src="image-20191014101703881.png" srcset="/img/loading.gif" alt="image-20191014101703881" style="zoom:40%;" /></p><p>为什么要对齐</p><blockquote><p>When well aligned, requires only one memory access to read one object;</p><p>If address is not well aligned, each misaligned object requires two memory accesses to fetch.</p></blockquote><h2 id="3-2-Addressing-modes"><a href="#3-2-Addressing-modes" class="headerlink" title="3.2  Addressing modes"></a>3.2  Addressing modes</h2><p><img src="image-20191014102744097-6809392.png" srcset="/img/loading.gif" alt="image-20191014102744097-6809392" style="zoom:50%;" /></p><p>References:  </p><p>[1]计算机体系结构 量化研究方法</p>]]></content>
    
    
    <categories>
      
      <category>Computer Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
