<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AbstractFactory</title>
    <link href="/2020/08/21/AbstractFactory/"/>
    <url>/2020/08/21/AbstractFactory/</url>
    
    <content type="html"><![CDATA[<h2 id="Abstract-Factory属于对象创建模式"><a href="#Abstract-Factory属于对象创建模式" class="headerlink" title="Abstract Factory属于对象创建模式"></a>Abstract Factory属于对象创建模式</h2><p>通过对象创建模式绕开<code>new</code>, 来避免对象创建 (<code>new</code>) 过程中所导致的紧耦合(依赖具体类 )，从而支持对象创建的稳定。他是接口抽象之后的第一步工作。</p><p>典型模式有</p><ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li><p>在软件系统中，经常面临着”<u>一系列相互依赖的对象</u>“的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。</p></li><li><p>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种”封装机制”来避免客户程序和这种”多系列具体对象创建工作” 的紧耦合？</p></li></ul><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>提供一个接口，让该接口负责创建一系列”相关或者相互依赖的对象”，无需指定它们具体的类。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>任务是写一个数据访问层。数据库可能会有各种各样的变化。可能是sqlserver, oracel, mysql, 因此对应的类型就需要变化。但是下面的代码的new并不是多态new</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span>    <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;        SqlConnection* connection =            <span class="hljs-keyword">new</span> SqlConnection();        connection-&gt;ConnectionString = <span class="hljs-string">"..."</span>;        SqlCommand* command =            <span class="hljs-keyword">new</span> SqlCommand();        command-&gt;CommandText=<span class="hljs-string">"..."</span>;        command-&gt;SetConnection(connection);        SqlDataReader* reader = command-&gt;ExecuteReader();        <span class="hljs-keyword">while</span> (reader-&gt;Read())&#123;        &#125;    &#125;&#125;;</code></pre></div><ul><li>重构</li></ul><p>要支持多态new, 马上就想到了factory method.</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//数据库访问有关的基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnection</span>&#123;</span>    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnectionFactory</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommand</span>&#123;</span>    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommandFactory</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReader</span>&#123;</span>    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReaderFactory</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;&#125;;<span class="hljs-comment">//支持SQL Server</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnectionFactory</span>:</span><span class="hljs-keyword">public</span> IDBConnectionFactory&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommandFactory</span>:</span><span class="hljs-keyword">public</span> IDBCommandFactory&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReaderFactory</span>:</span><span class="hljs-keyword">public</span> IDataReaderFactory&#123;&#125;;<span class="hljs-comment">//支持Oracle</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span>    IDBConnectionFactory* dbConnectionFactory;    IDBCommandFactory* dbCommandFactory;    IDataReaderFactory* dataReaderFactory;    <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;        IDBConnection* connection =            dbConnectionFactory-&gt;CreateDBConnection();        connection-&gt;ConnectionString(<span class="hljs-string">"..."</span>);        IDBCommand* command =            dbCommandFactory-&gt;CreateDBCommand();        command-&gt;CommandText(<span class="hljs-string">"..."</span>);        command-&gt;SetConnection(connection); <span class="hljs-comment">//关联性</span>        IDBDataReader* reader = command-&gt;ExecuteReader(); <span class="hljs-comment">//关联性</span>        <span class="hljs-keyword">while</span> (reader-&gt;Read())&#123;        &#125;    &#125;&#125;;</code></pre></div><p>但是，这样的问题是IDBConnection, IDBCommand, IDBDataReader可能并不对应，比如一个是oracel的connection, 一个是mysql的command。因此产生关联性问题。</p><ul><li>继续重构</li></ul><p>把connection, command, datareader凝聚到一个类中, 这样就能得到关联性的保证。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//数据库访问有关的基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnection</span>&#123;</span>    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommand</span>&#123;</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReader</span>&#123;</span>    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBFactory</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;    &#125;;<span class="hljs-comment">//支持SQL Server</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDBFactory</span>:</span><span class="hljs-keyword">public</span> IDBFactory&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span> </span>&#123;&#125; &#125;;<span class="hljs-comment">//支持Oracle</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;  &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleDBFactory</span>:</span><span class="hljs-keyword">public</span> IDBFactory&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span> </span>&#123;&#125; &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span>    IDBFactory* dbFactory;    <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;        IDBConnection* connection =            dbFactory-&gt;CreateDBConnection();        connection-&gt;ConnectionString(<span class="hljs-string">"..."</span>);        IDBCommand* command =            dbFactory-&gt;CreateDBCommand();        command-&gt;CommandText(<span class="hljs-string">"..."</span>);        command-&gt;SetConnection(connection); <span class="hljs-comment">//关联性</span>        IDBDataReader* reader = command-&gt;ExecuteReader(); <span class="hljs-comment">//关联性</span>        <span class="hljs-keyword">while</span> (reader-&gt;Read())&#123;        &#125;    &#125;&#125;;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200821143526358.png" srcset="/img/loading.gif" alt="image-20200821143526358" style="zoom:50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>如果没有应对”多系列对象构建”的需求变化，则没有必要使用 Abstract Factory模式，这时候使用简单的工厂完全可以。</p></li><li><p>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、 或作用的关系。不同系列的对象之间不能相互依赖。</p></li><li><p>Abstract Factory模式主要在于应对”新系列”的需求变动。其缺 点在于难以应对”新对象”的需求变动。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Factory Method 工厂模式</title>
    <link href="/2020/08/14/DesignPatterns/FactoryMethod/"/>
    <url>/2020/08/14/DesignPatterns/FactoryMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="Factory-Method属于对象创建模式"><a href="#Factory-Method属于对象创建模式" class="headerlink" title="Factory Method属于对象创建模式"></a>Factory Method属于对象创建模式</h2><p>通过对象创建模式绕开<code>new</code>, 来避免对象创建 (<code>new</code>) 过程中所导致的紧耦合(依赖具体类 )，从而支持对象创建的稳定。他是接口抽象之后的第一步工作。</p><p>典型模式有</p><ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化， 需要创建的对象的具体类型经常变化。</p><p>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种”封装机制”来避免客户程序和这种”具体对象创建工作”的紧耦合？</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使得一个类的实例化延迟（目的：解耦， 手段：虚函数）到子类。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>初始代码，一个文件分割器。</p><p>这个代码会有什么问题呢？要从变化的场景去看。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;FileSplitter* splitter = <span class="hljs-keyword">new</span> FileSplitter();        splitter-&gt;split;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSpitter</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>最开始我们讲过一个原则：面向接口的编程。一个对象的类型应该声明成抽象类或者接口，而不应该声明成具体的类。如果声明成具体的类，就把他定死了，无法应对未来的变化。</p><p>假设我们产生了新的需求：</p><p>需要支持二进制文件，txt文件，图片文件，视频文件的分割</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span> &#123;</span> <span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~ISplitter() &#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySpliter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;  &#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">/*******************问题产生了******************/</span>ISplitter* splitter = <span class="hljs-keyword">new</span> BinarySplitter(); <span class="hljs-comment">//??????怎么又依赖细节了？？？</span>        splitter-&gt;split;    &#125;&#125;</code></pre></div><div class="note note-warning">            <p><code>new</code>不能new抽象类，<code>new</code>只能new具体类。但是我们需要的是多态<code>new</code>。怎么解决呢？</p>          </div><ul><li>开始重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//return new ISplitter(...);//这样也是不对的，因为不能new抽象类</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BinarySplitter();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span> &#123;</span> <span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~ISplitter() &#123;&#125;&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;SplitterFactory factory;ISplitter* splitter = factory.CreateSplitter();        splitter-&gt;split;    &#125;&#125;</code></pre></div><p>但是这种实现根本没有解决问题，<code>ISplitter* splitter = factory.CreateSplitter();</code>依然依赖于具体的类BinarySplitter</p><ul><li>继续重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//抽象类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~ISplitter() &#123;&#125;&#125;;<span class="hljs-comment">//工厂基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~SplitterFactory()&#123;&#125;    &#125;&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;SplitterFactory* factory;<span class="hljs-comment">//多态了</span>ISplitter* splitter = factory-&gt;CreateSplitter();        splitter-&gt;split;    &#125;&#125;</code></pre></div><ul><li>继续完善</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//具体类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySpliter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;  &#125;;<span class="hljs-comment">//具体工厂</span>BinarySplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BinarySplitter();    &#125;&#125;;TxtSplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TxtSplitter();    &#125;&#125;;PictureSplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PictureSplitter();    &#125;&#125;;VideoSplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VideoSplitter();    &#125;&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    SplitterFactory* factory;<span class="hljs-keyword">public</span>:    MainForm(SplitterFactory* factory) &#123;        <span class="hljs-keyword">this</span>-&gt;factory = factory;    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//多态new</span>ISplitter* splitter = factory-&gt;CreateSplitter();        splitter-&gt;split;    &#125;&#125;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200814150354579.png" srcset="/img/loading.gif" alt="image-20200814150354579" style="zoom:50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导 致软件的脆弱。</p></li><li><p>Factory Method模式通过面向对象的手法，将所要创建的具体对 象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。</p></li><li><p>Factory Method模式解决”单个对象”的需求变化。缺点在于要求创建方法/参数相同。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bridge 桥模式</title>
    <link href="/2020/08/11/DesignPatterns/Bridge/"/>
    <url>/2020/08/11/DesignPatterns/Bridge/</url>
    
    <content type="html"><![CDATA[<h2 id="Bridge属于”单一职责”模式"><a href="#Bridge属于”单一职责”模式" class="headerlink" title="Bridge属于”单一职责”模式"></a>Bridge属于”单一职责”模式</h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码， 这时候的关键是划清责任。</p><ul><li><p>典型模式</p><p>• Decorator</p><p>• Bridge</p></li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>由于某些类型的固有的实现逻辑，使得它们具有<u>两个变化的维度， 乃至多个纬度</u>的变化。</p><p>如何应对这种”多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>将抽象部分(业务功能)与实现部分(平台实现)分离，使他们都可以独立地变化</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>一个通信模块Messager。根据平台分为PC, Mobile，派生出两个子类PCMessagerBase, MobileMessagerBase。根据业务分成perfect和lite, 前面的两个子类又派生出PCMessagerLite, PCMessagerPerfect, MobileMessagerLite, MobileMessagerPerfect.</p><p>如果设平台有n中选择，业务有m中，那么类的数目为$1 + n + m * n$</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Message() &#123;&#125;&#125;<span class="hljs-comment">//平台实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;; <span class="hljs-comment">//业务抽象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerLite</span>:</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        PCMessagerBase::Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        PCMessagerBase::WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        PCMessagerBase::DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerPerfect</span>:</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;PCMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        PCMessagerBase::Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;PCMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        PCMessagerBase::WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        PCMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        PCMessagerBase::DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerLite</span>:</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        MobileMessagerBase::Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        MobileMessagerBase::WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        MobileMessagerBase::DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerPerfect</span>:</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;MobileMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        MobileMessagerBase::Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;MobileMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        MobileMessagerBase::WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        MobileMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        MobileMessagerBase::DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;</code></pre></div><p>但是这样设置的类有很多的结构性重复。比如PCMessagerPerfect, MobileMessagerPerfect。</p><ul><li>重构</li></ul><p>将PCMessagerLite, PCMessagerPerfect, MobileMessagerLite, MobileMessagerPerfect的继承改为组合。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Message() &#123;&#125;&#125;<span class="hljs-comment">//平台实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;; <span class="hljs-comment">//业务抽象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerLite</span> &#123;</span>    Messager* messager;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        messager-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        messager-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        messager-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerPerfect</span> &#123;</span>    Messager* messager;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;messager-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messager-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;messager-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messager-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;       messager-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messager-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;</code></pre></div><p>注意，这样修改之后并不是完整的，因为MessagerLite和MessagerPerfect没有了PlaySound, Connect…这些函数</p><ul><li>继续重构</li></ul><p>可以看到平台类在重载PlaySound, PlaySound, WriteText, Connect这几个函数。而业务类在重载Login, SendMessage, SendPicture这几个函数。因此把这两块函数放在一个类里面是不合适的，我们把他们拆分成两个类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Message() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerImp</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~MessageImp() &#123;&#125;&#125;<span class="hljs-comment">//平台实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span>:</span> <span class="hljs-keyword">public</span> MessagerImp &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span>:</span> <span class="hljs-keyword">public</span> MessagerImp &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;; <span class="hljs-comment">//业务抽象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerLite</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;    MessagerImp* messagerImp;<span class="hljs-comment">//...</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        messagerImp-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        messagerImp-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        messagerImp-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerPerfect</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;    MessagerImp* messagerImp;<span class="hljs-comment">//...</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;       messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;</code></pre></div><ul><li>再重构</li></ul><p>可以看到MessageLite和MessagerPerfect这两个类里面都有MessagerImp字段。根据重构的原则，应该将他往上提到Messager类中。</p><p>最终类的数目编程$1+n+m$</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span> &#123;</span><span class="hljs-keyword">protected</span>:    MessagerImp* messagerImp;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Message() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerImp</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~MessageImp() &#123;&#125;&#125;<span class="hljs-comment">//平台实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span>:</span> <span class="hljs-keyword">public</span> MessagerImp &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span>:</span> <span class="hljs-keyword">public</span> MessagerImp &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;; <span class="hljs-comment">//业务抽象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerLite</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        messagerImp-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        messagerImp-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        messagerImp-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerPerfect</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;       messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200811150059187.png" srcset="/img/loading.gif" alt="image-20200811150059187" style="zoom:50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Bridge模式使用”对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓 抽象和实现沿着各自纬度的变化，即”子类化”它们。</p></li><li><p>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。 Bridge模式是比多继承方案更好的解决方法。</p></li><li><p>Bridge模式的应用一般在”两个非常强的变化维度”，有时一个 类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资本论读书摘抄</title>
    <link href="/2020/08/09/Capital/"/>
    <url>/2020/08/09/Capital/</url>
    
    <content type="html"><![CDATA[<h1 id="2020-08-09"><a href="#2020-08-09" class="headerlink" title="2020-08-09"></a>2020-08-09</h1><h4 id="商品-第一卷第一章"><a href="#商品-第一卷第一章" class="headerlink" title="商品 第一卷第一章"></a>商品 第一卷第一章</h4><ul><li><p>商品的两个因素: 使用价值和价值</p></li><li><p>物的有用性成为使用价值。服务是具有使用价值的。</p></li><li><p>由于使用价值才是构成一个社会的财富的物质内容，因此，股票市场的涨跌并不代表一个社会的财富的增加或减少</p></li><li><p>交换价值首先表现为一种使用价值同另一种使用价值相交换的量的关系或比例。</p></li><li><p>由于交换是一个私人劳动向社会劳动的转变过程，这个过程中存在一定的随机性，因此交换价值具有一定的偶然性。但这种偶然性中包含必然性。用马克思身后才发展起来的概率论的术语来说，一个商品或一个使用价值在不同的时间和地点进行交换时，其交换价值是一个随机变量，但这个随机变量有一个确定的，并非偶然的和纯粹相对的期望值，这个期望值就是商品固有的，内在的交换价值。</p></li><li><p>现代庸俗经济学用供求关系和效用来解释交换价值的形成。实际上供求关系和效用只能解释交换价值的随机部分，而不能解释交换价值内在的期望值。按现代庸俗经济学的解释，之所以1夸特小麦=a吨铁，是因为这两者带给交易者的边际效用是相同的。由于边际效用纯属个人的主观感受，因此，如果市场上都按上式进行交易，那就意味着所有的交易者的主观感受完全一致，用概率论的术语说，既然每个人的主观感觉是无限的或是可以无限细分的，因此，发生这种情况的概率为零，即它是几乎不可能的。于是，如果我们观察到某个市场上的交易都在或大多数都在按同一等式进行交换时，效用论要么破产，要么需要假定存在一个不以个人意志为转移的效用期望值，而分析这个期望值是如何存在的，就不得不回到劳动价值学说。</p></li><li><p>商品的交换价值是由外部的别的东西来度量的，而商品的价值则是它本身单纯凝结的人类劳动，后文说明它是由所凝固的劳动时间来度量的。这两个价值的度量单位是不同的。这种不同决定了，在一定的条件下，尤其是资本主义条件下，商品的交换价值与商品的价值是相背离的。</p></li><li><p>劳动与生产资料共同创造财富。社会主义并不反对资本，(资本分为预付来购买生产资料的不变资本和预付来购买劳动的可变资本。但由于现在资本家往往正如马克思在《资本论》中将要指出的那样，并不预购劳动，而是让工人先提供(预付)劳动，再从工人劳动创造的价值中，取出一部分来作为报酬支付给工人。即，资本家往往只需预付不变资本(单个资本家可以贷款或赊欠来一部分不变资本，但这些资本还是来自于资本家，货币资本家)，通过赊欠可变资本，进行生产。所以这里将代表生产资料的不变资本，简称为资本。)而是反对资本与劳动的人为脱节，反对有人通过垄断资本而不劳而获、骄奢淫逸；反对有劳动能力的劳动者为了获得与资本相结合的机会而被迫过着辛劳而悲惨的生活。</p></li><li><p>有人认为，工人的工资是固定的，资本家的利润是不固定的。所以，资本家承担了生产经营过程中的风险，而工人不承担风险，所以资本家应当获得与其所承担的风险相应的剥削收入。但是，一方面，资本家的所得大大超过他所承担的风险；另一方面，工人的劳动是预付的，同样存在风险。被拖欠和无端克扣工资的事经常发生，而且拖欠的工资即使发还也往往是不付利息的。至于最后工资完全泡汤的事也不是没有发生过，部分泡汤的就更多。即使有工资，有时还不够用来治疗职业病。而且资本家的风险是他自己造成的，由他自己负责；而工人的风险则是由资本家造成的，资本家反而应当因此对工人进行补偿。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Decorator</title>
    <link href="/2020/08/07/DesignPatterns/Decorator/"/>
    <url>/2020/08/07/DesignPatterns/Decorator/</url>
    
    <content type="html"><![CDATA[<h2 id="Decorator属于”单一职责”模式"><a href="#Decorator属于”单一职责”模式" class="headerlink" title="Decorator属于”单一职责”模式"></a>Decorator属于”单一职责”模式</h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码， 这时候的关键是划清责任。</p><ul><li><p>典型模式</p><p>• Decorator</p><p>• Bridge</p></li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在某些情况下我们可能会”过度地使用继承来扩展对象的功能”， 由于继承为类型引入的<strong>静态特质</strong>，使得这种扩展方式缺乏灵活性； 并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</p><p>如何使”对象功能的扩展”能够根据需要来动态地实现？同时避免”扩展功能的增多”带来的子类膨胀问题？从而使得任何”功能扩展变化”所导致的影响将为最低？</p><p>所谓静态特质, 比如在CryptoNetworkStream的Read函数中定死了调用NetworkStream::Read(), 而我们重构后的CryptoStream中的Read函数调用stream-&gt;Read(), 支持多态，可以产生变化。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面给出一个Stream代码示例，其继承关系如下所示</p><p><img src="image-20200807143722316.png" srcset="/img/loading.gif" alt="image-20200807143722316" style="zoom:30%;" /></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//业务操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stream</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Stream() &#123;&#125;&#125;;<span class="hljs-comment">//主体类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读文件流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位文件流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写文件流</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读网络流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位网络流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写网络流</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读内存流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位内存流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写内存流</span>    &#125;&#125;;<span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoNetworkStream</span>:</span> <span class="hljs-keyword">public</span> NetworkStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoMemoryStream</span>:</span> <span class="hljs-keyword">public</span> MemoryStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedNetworkStream</span>:</span> <span class="hljs-keyword">public</span> NetworkStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedMemoryStream</span>:</span> <span class="hljs-keyword">public</span> MemoryStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoBufferedFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Read(number);<span class="hljs-comment">//读文件流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Seek(position);<span class="hljs-comment">//定位文件流</span>        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Write(position);<span class="hljs-comment">//写文件流</span>        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//编译时装配</span>    CryptoFileStream* fs1 = <span class="hljs-keyword">new</span> CryptoFileStream();        BufferedFileStream* fs2 = <span class="hljs-keyword">new</span> BufferedFileStream();        CryptoBufferedFileStream* fs3 = <span class="hljs-keyword">new</span> CryptoBufferedFileStream();&#125;</code></pre></div><p>这样设计的代码存在大量的冗余，比如对于不同的stream, 无论是FileStream还是NetworkStream还是MemoryStream, 他们的加密操作都是一样的。</p><ul><li>重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoFileStream</span> &#123;</span>    FileStream* stream;<span class="hljs-comment">//=new FileStream()</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoNetworkStream</span> &#123;</span>    NetworkStream* stream;<span class="hljs-comment">//=new NetworkStream();</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoMemoryStream</span> &#123;</span>    MemoryStream* stream;<span class="hljs-comment">//=new MemoryStream();</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;</code></pre></div><ul><li>继续重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;    Stream* stream;<span class="hljs-comment">//...</span><span class="hljs-keyword">public</span>:    CryptoStream(Stream* stm): stream(stm) &#123;            &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;    Stream* stream; <span class="hljs-comment">//...</span>    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//运行时装配</span>    FileStream* s1 = <span class="hljs-keyword">new</span> FileStream();    CryptoStream* s2 = <span class="hljs-keyword">new</span> CryptoStream(s1);    BufferedStream* s3 = <span class="hljs-keyword">new</span> BufferedStream(s1);    BufferedStream* s4 = <span class="hljs-keyword">new</span> BufferedStream(s2);&#125;</code></pre></div><p>很神奇，CryptoStream既有Stream基类，也有Stream字段。这里还需要继承Stream是因为他定义了基类的接口规范</p><ul><li>继续重构</li></ul><p>CryptoStream, BufferedStream都有Stream这个字段，把他们提到一个中间类中，</p><p>设置一个DecoratorStream中间类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoratorStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">protected</span>:    Stream* stream; <span class="hljs-comment">//...</span>    DecoratorStream(Stream* stm): DecoratorStream(stm) &#123;            &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> DecoratorStream &#123;<span class="hljs-keyword">public</span>:    CryptoStream(Stream* stm): DecoratorStream(stm) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span>:</span> <span class="hljs-keyword">public</span> DecoratorStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//运行时装配</span>    FileStream* s1 = <span class="hljs-keyword">new</span> FileStream();    CryptoStream* s2 = <span class="hljs-keyword">new</span> CryptoStream(s1);    BufferedStream* s3 = <span class="hljs-keyword">new</span> BufferedStream(s1);    BufferedStream* s4 = <span class="hljs-keyword">new</span> BufferedStream(s2);&#125;</code></pre></div><p>新的类关系</p><p><img src="image-20200807143823919.png" srcset="/img/loading.gif" alt="image-20200807143823919" style="zoom:30%;" /></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200807160507597.png" srcset="/img/loading.gif" alt="image-20200807160507597" style="zoom:50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免 了使用继承带来的”灵活性差”和”多子类衍生问题”。</p></li><li><p>Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又 表现为has-a Component的组合关系，即Decorator类又使用了 另外一个Component类。</p></li><li><p>Decorator模式的目的并非解决”多子类衍生的多继承”问题，Decorator模式应用的要点在于解决”主体类在多个方向上的扩展 功能”——是为”装饰”的含义。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="/2020/08/06/DesignPatterns/Principle/"/>
    <url>/2020/08/06/DesignPatterns/Principle/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>变化是复用的天敌！ 面向对象设计最大的优势在于：<u><strong><em>抵御变化</em></strong></u></p>          </div><h4 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 (DIP)"></a>依赖倒置原则 (DIP)</h4><ul><li><p>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。</p></li><li><p>抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。</p></li></ul><p><br></p><h4 id="开放封闭原则-OCP"><a href="#开放封闭原则-OCP" class="headerlink" title="开放封闭原则 (OCP)"></a>开放封闭原则 (OCP)</h4><ul><li><p>对扩展开放，对更改封闭。</p></li><li><p>类模块应该是可扩展的，但是不可修改。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Observer 观察者模式</title>
    <link href="/2020/08/06/DesignPatterns/Observer/"/>
    <url>/2020/08/06/DesignPatterns/Observer/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，我们需要为某些对象建立一种”通知依赖关系” </p><p><u>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密， 将使软件不能很好地抵御变化</u>。</p><p>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>定义对象间的一种<u><strong><em>一对多</em></strong></u>（变化）的依赖关系，以便当一个 对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并<u><strong><em>自动更新</em></strong></u>。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>考虑一个文件分割器程序，将一个大文件分割成几个小文件。</p><p>我们有一个主界面MainForm (在这里是一个观察者), 里面有两个对象，一个是文件路径，一个是分割成的文件都个数。当button click时就会调用filesplitter将文件分割</p><p>代码如下</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;<span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber):    m_filePath(filePath),    m_fileNumber(fileNumber) &#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>        &#125;    &#125;&#125;</code></pre></div><h4 id="需求1：文件分割进度条"><a href="#需求1：文件分割进度条" class="headerlink" title="需求1：文件分割进度条"></a>需求1：文件分割进度条</h4><ul><li>第一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;<span class="hljs-comment">/***增加progress bar***/</span>    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;<span class="hljs-comment">/***增加progres bar***/</span>    ProgressBar* m_progressBar;<span class="hljs-keyword">public</span>:<span class="hljs-comment">/***增加初始化参数***/</span>    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, ProgressBar* progressBar):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_progressBar(progressBar)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span><span class="hljs-comment">/***更新progress bar***/</span>            <span class="hljs-keyword">if</span>(m_progressBar != <span class="hljs-literal">NULL</span>) &#123;                m_progressBar-&gt;setValue((i + <span class="hljs-number">1</span>) / m_fileNumber);            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="note note-warning">            <p>但是这种实现方式违反了<u>依赖倒置原则</u>。FileSplitter依赖ProgressBar 这样一种具体的实现细节，但是进度条的种类和展现形式是变化的，如果我们想将进度条换一种展现形式，比如不断打点，那么就会面临需求变更的困扰。</p>          </div><ul><li>第二种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    <span class="hljs-comment">//ProgressBar* m_progressBar; 这是一个通知控件</span>    IProgress* m_iprogress; <span class="hljs-comment">//抽象通知机制</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, IProgress* iprogress):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_iprogress(iprogress)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">if</span>(m_iprogress != <span class="hljs-literal">NULL</span>) &#123;                <span class="hljs-keyword">float</span> progressValue = m_fileNumber;                progressValue = (i + <span class="hljs-number">1</span>) / progressValue;                m_iprogress-&gt;DoProgress(progressValue); <span class="hljs-comment">//更新进度条</span>            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress&#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressbar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        progressBar-&gt;setValue(value);    &#125;&#125;</code></pre></div><p>C++支持多继承，但是不推荐使用多继承，因为会带来很多耦合的问题。但是有一种情况是推荐使用多继承的，一个主的继承类，其他都是接口  (单继承多实现), 这里就属于这种情况</p><ul><li>再修改一下</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    <span class="hljs-comment">//ProgressBar* m_progressBar; 这是一个通知控件</span>    IProgress* m_iprogress; <span class="hljs-comment">//抽象通知机制</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, IProgress* iprogress):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_iprogress(iprogress)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">float</span> progressValue = m_fileNumber;            progressValue = (i + <span class="hljs-number">1</span>) / progressValue;            onProgress(progressValue);        &#125;    &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span>(m_iprogress != <span class="hljs-literal">NULL</span>) &#123;        m_iprogress-&gt;DoProgress(value);<span class="hljs-comment">//更新进度条</span>        &#125;    &#125;&#125;</code></pre></div><h4 id="需求2-多观察者"><a href="#需求2-多观察者" class="headerlink" title="需求2: 多观察者"></a>需求2: 多观察者</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    List&lt;IProgress*&gt; m_iprogressList; <span class="hljs-comment">//抽象通知机制, 支持多个观察者</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber):    m_filePath(filePath),    m_fileNumber(fileNumber) &#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIProgress</span><span class="hljs-params">(IProgress* iprogress)</span> </span>&#123;        m_iprogressList.add(iprogress);    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeIProgress</span><span class="hljs-params">(IProgress* iprogress)</span> </span>&#123;        m_iprogressList.remove(iprogress);    &#125;            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">float</span> progressValue = m_fileNumber;            progressValue = (i + <span class="hljs-number">1</span>) / progressValue;            onProgress(progressValue);        &#125;    &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        List&lt;IProgress*&gt;::iterator it = m_iprogressList.begin();        <span class="hljs-keyword">while</span>(it != m_iprogressList.end()) &#123;            (*it)-&gt;DoProgress(value);            it++;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress&#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressbar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                ConsoleNotifier cn;        <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;                splitter.addIprogress(<span class="hljs-keyword">this</span>);        splitter.addIprogress(&amp;cn);                splitter.split();    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        progressBar-&gt;setValue(value);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleNotifier</span>:</span> <span class="hljs-keyword">public</span> IProgress &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"."</span>;    &#125;&#125;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200806160700160.png" srcset="/img/loading.gif" alt="image-20200806160700160" style="zoom: 50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。 </p></li><li><p>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。</p></li><li><p>观察者自己决定是否需要订阅通知，目标对象对此一无所知。 </p></li><li>Observer模式是基于事件的UI框架中非常常用的设计模式，也是 MVC模式的一个重要组成部分。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Template Method</title>
    <link href="/2020/08/05/DesignPatterns/TemplateMethod/"/>
    <url>/2020/08/05/DesignPatterns/TemplateMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因 （比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p><p>核心在于在稳定与变化之间求得一个平衡，如果全部稳定或者全部变化都是不需要设计模式的。</p><p>如何在确定<strong>稳定操作结构</strong>的前提下，来灵活应对<strong>各个子步骤的变化</strong>或者<strong>晚期实现需求</strong>？</p><p>假设整个代码的操作结构如下图所示，其中红色是Library开发人员完成的，蓝色部分是Application开发人员完成的</p><p><img src="image-20200710191024075.png" srcset="/img/loading.gif" alt="image-20200710191024075" style="zoom:33%;" /></p><h2 id="结构化软件流程设计"><a href="#结构化软件流程设计" class="headerlink" title="结构化软件流程设计"></a>结构化软件流程设计</h2><p><img src="image-20200710191212499.png" srcset="/img/loading.gif" alt="image-20200710191212499" style="zoom:50%;" /></p><p>lib.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>app.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//应用程序开发人员</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>主程序</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Library <span class="hljs-title">lib</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Application <span class="hljs-title">app</span><span class="hljs-params">()</span></span>;        lib.Step1();        <span class="hljs-keyword">if</span>(app.Step2()) &#123;        lib.Step3();    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;        app.Step4();    &#125;    lib.Step5();&#125;</code></pre></div><h2 id="用模板方法的代码重构为"><a href="#用模板方法的代码重构为" class="headerlink" title="用模板方法的代码重构为"></a>用模板方法的代码重构为</h2><p><img src="image-20200710191917988.png" srcset="/img/loading.gif" alt="image-20200710191917988" style="zoom:50%;" /></p><p>lib.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span> </span>&#123;        Step1();        <span class="hljs-keyword">if</span>(Step2()) &#123;            Step3();        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            Step4();        &#125;        Step5();    &#125;        <span class="hljs-keyword">virtual</span> ~Library() &#123;&#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>&#125;</code></pre></div><p>app.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//应用程序开发人员</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span>:</span> <span class="hljs-keyword">public</span> Library &#123;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;;</code></pre></div><p>主程序</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Library* pLib = <span class="hljs-keyword">new</span> Application();    lib.Run();    <span class="hljs-keyword">delete</span> pLib;&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两者的区别在于早绑定和晚绑定。前者属于早绑定，而template method属于晚绑定</p><p><img src="image-20200710192039991.png" srcset="/img/loading.gif" alt="image-20200710192039991" style="zoom:50%;" /></p><p>定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟 (变化)到子类中。Template Method使得子类可以不改变 (复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。</p>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Strategy Method</title>
    <link href="/2020/08/05/DesignPatterns/StrategyMethod/"/>
    <url>/2020/08/05/DesignPatterns/StrategyMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂； 而且有时候支持不使用的算法也是一个性能负担</p><p>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</p><h2 id="Strategy-Method定义"><a href="#Strategy-Method定义" class="headerlink" title="Strategy Method定义"></a>Strategy Method定义</h2><p>定义一系列算法，把它们一个个封装起来，并且使它们可互 相替换（变化）。该模式使得算法可独立于使用它的客户程 序(稳定)而变化（扩展，子类化）。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>考虑一下计算税的例子</p><ul><li>第一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> TaxBase &#123;    CN_Tax,    US_Tax,    DE_Tax&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span>    TaxBase tax;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>                <span class="hljs-keyword">if</span>(tax == CN_Tax) &#123;            <span class="hljs-comment">//CN*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == US_Tax) &#123;            <span class="hljs-comment">//US*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == DE_Tax) &#123;            <span class="hljs-comment">//DE*****</span>        &#125;        <span class="hljs-comment">//***</span>    &#125;&#125;</code></pre></div><p>有些时候，静态地去观察是看不出来的，加入时间轴，考虑到未来的动态变化，问题就会暴露出来。考虑上述例子，如果要加入一个国家，比如法国，那么我们不仅要在<code>TaxBase</code>中中增加一个<code>FR_Tax</code>, 还需要在<code>SalesOrder</code>中增加判断语句。这样的更改违背了开闭原则： 对扩展开放，对修改封闭 (避免去修改源代码</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> TaxBase &#123;    CN_Tax,    US_Tax,    DE_Tax,    <span class="hljs-comment">/***加入France***/</span>    FR_Tax,&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span>    TaxBase tax;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>                <span class="hljs-keyword">if</span>(tax == CN_Tax) &#123;            <span class="hljs-comment">//CN*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == US_Tax) &#123;            <span class="hljs-comment">//US*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == DE_Tax) &#123;            <span class="hljs-comment">//DE*****</span>        &#125;        <span class="hljs-comment">/***加入France***/</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == FR_Tax) &#123;                  &#125;        <span class="hljs-comment">//***</span>    &#125;&#125;</code></pre></div><ul><li>考虑另一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxStrategy</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~TaxStrategy() &#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DETax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span><span class="hljs-keyword">private</span>:    TaxStrategy* strategy;<span class="hljs-keyword">public</span>:    SalesOrder(StrategyFactory* strategyFactory) &#123;        <span class="hljs-keyword">this</span>-&gt;strategy = strategyFactory-&gt;NewStrategy();    &#125;        ~SalesOrder() &#123;        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>        <span class="hljs-function">Context <span class="hljs-title">context</span><span class="hljs-params">()</span></span>;                <span class="hljs-keyword">double</span> val =             srtategy-&gt;Calculate(context);<span class="hljs-comment">//多态调用</span>    &#125;&#125;</code></pre></div><p>如果要增加法国，只需增加一个<code>FRTax</code>类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> doubel <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>这是一种扩展的做法，在这里只需要增加一个FRTax类，不需要更改SalesOrder。</p><p>复用性一般是指二进制层面下的复用性，如果使用第一种方法，那么整个系统需要重新编译，重新测试。虽然修改后保留了一部分原来的代码，但是这个并不是复用。而策略方法不需要重新编译之前编译好的文件，只需要重新编译FRTax这个文件</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200805135526277.png" srcset="/img/loading.gif" alt="image-20200805135526277"> </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使 得类型在运行时方便地根据需要在各个算法之间进行切换。</p></li><li><p>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件 判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需 要Strategy模式。</p></li><li><p>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CA - Storage</title>
    <link href="/2019/12/08/ComputerArchitecture/Storage/"/>
    <url>/2019/12/08/ComputerArchitecture/Storage/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><center><img src="image-20191208134608723.png" srcset="/img/loading.gif" alt="image-20191208134608723" style="zoom:50%;" /></center><h2 id="1-1-缓存性能"><a href="#1-1-缓存性能" class="headerlink" title="1.1 缓存性能"></a>1.1 缓存性能</h2><p>CPU execution time</p><script type="math/tex; mode=display">=(CPU\, clock\, cycles + Memory\, stall\, cycles)\times Clock\, cycle\, time</script><p>{:.warning}</p><p>这里CPU clock cicles包括handle cache hit/miss的时间</p><center><img src="image-20191208135106480.png" srcset="/img/loading.gif" alt="image-20191208135106480" style="zoom:60%;" /></center><center><img src="image-20191208135244903.png" srcset="/img/loading.gif" alt="image-20191208135244903" style="zoom:60%;" /></center><p>看一道例题</p><blockquote><p>a computer with CPI=1 when cache hit.  </p><p>50% instructions are loads and stores;</p><p>2% miss rate, 25 cc miss penalty;</p><p><strong>Q:</strong> how much faster would the computer be if all instructions were cache hits?</p></blockquote><p>Answer:</p><ol><li>always hit:</li></ol><p>CPU execution time = (CPU clocks cycles + Memory stall cycles) * clock cycle</p><p>=<script type="math/tex">(IC \times CPI + 0) \times clock\,cycle</script></p><p>=<script type="math/tex">IC \times clock\, cycle</script></p><p><br/></p><ol><li>with misses</li></ol><p>Memory stall cycles</p><p>= $IC \times \frac{Memory\, accesses}{Instruction}\times Miss\, rate\times Miss\, penalty$</p><p>=$IC\times(1+0.5)\times 0.02\times 25$</p><p>=$IC\times 0.75$</p><p>memory accesses=1.5是因为执行任何一条指令都要访问memory取指令，并且50%的指令是load, store 因此 1+0.5=1.5</p><p>CPU execution time = (CPU clocks cycles + Memory stall cycles) $\times$ clock cycle</p><p>=$(IC\times 1.0+IC\times 0.75)\times$clock cycle</p><p>=$1.75\times $clock cycle</p><p>所以比值是1.75</p><h2 id="1-2-4个存储器层次结构问题"><a href="#1-2-4个存储器层次结构问题" class="headerlink" title="1.2 4个存储器层次结构问题"></a>1.2 4个存储器层次结构问题</h2><p>Q1: Where can a block be placed in the upper level? (block placement)</p><p>Q2: How is a block found if it is in the upper level? (block identification)</p><p>Q3: Which block should be replaced on a miss? (block replacement)</p><p>Q4: What happens on a write? (write strategy)</p><center><img src="image-2019120874232.png" srcset="/img/loading.gif" alt="截屏2019-12-08下午7.42.32" style="zoom:67%;" /></center><center><img src="image-20191208194519623.png" srcset="/img/loading.gif" alt="image-20191208194519623" style="zoom: 67%;" /></center><h3 id="A-Write-Strategy"><a href="#A-Write-Strategy" class="headerlink" title="A. Write Strategy"></a>A. Write Strategy</h3><p><code>Write hit</code></p><ul><li>write-through: info is written to both the block in the cache and to the block in the lower-level memory</li><li>write-back: info is written only to the block in the cache;  to the main memory only when the modified cache block is replaced[dirty bit]</li></ul><p><code>Write miss</code></p><ul><li>Write allocate: data at the missed-<strong>write</strong> location is loaded to cache, followed by a <strong>write</strong>-hit operation  </li><li>No-write allocate[write around]: data at the missed-<strong>write</strong> location is not loaded to cache, and is written directly to the backing store.  ;  <em>until the program tries to read the block, the data is loaded to cache;</em></li></ul><center><img src="image-20191208201918610.png" srcset="/img/loading.gif" alt="image-20191208201918610" style="zoom:50%;" /></center><ol><li>No-Write allocate:  4 misses + 1 hit</li></ol><center><img src="image-20191208202025669.png" srcset="/img/loading.gif" alt="image-20191208202025669" style="zoom:50%;" /></center><ol><li>Write allocate:  2 misses + 3 hits</li></ol><center><img src="image-20191208202722945.png" srcset="/img/loading.gif" alt="image-20191208202722945" style="zoom:50%;" /></center><h1 id="2-缓存性能"><a href="#2-缓存性能" class="headerlink" title="2. 缓存性能"></a>2. 缓存性能</h1><h3 id="Hit-or-Miss-How-long-will-it-take"><a href="#Hit-or-Miss-How-long-will-it-take" class="headerlink" title="Hit or Miss: How long will it take?"></a>Hit or Miss: How long will it take?</h3><p>Average memory access time = Hit time + Miss rate x Miss penalty</p><ul><li><strong>Example</strong></li></ul><blockquote><p>16KB instr cache + 16KB data cache;</p><p>or, 32KB unified cache;</p><p>36% data transfer instructions;</p><p>(load/store takes 1 extra cc on unified cache)</p><p>1 CC hit; 200 CC miss penalty;</p></blockquote><center><img src="image-20191208204528711.png" srcset="/img/loading.gif" alt="image-20191208204528711" style="zoom:30%;" /></center><blockquote><p><strong>Q1:</strong> split cache or unified cache has lower miss rate? </p></blockquote><p>Answer:</p><center><img src="image-20191208204804983.png" srcset="/img/loading.gif" alt="image-20191208204804983" style="zoom:40%;" /></center><ol><li>split cache</li></ol><p>16KB instruction Miss rate</p><p>​        = <script type="math/tex">\frac{3.82}{1000}/1=0.004</script></p><p>16KB data miss rate</p><p>​        =<script type="math/tex">\frac{40.9}{1000}/0.36=0.114</script></p><p>assume 74% of memory accesses are instruction references</p><p>Overall miss rate</p><p>​        =<script type="math/tex">(74\%\times 0.004)+(26\%\times 0.114)=0.0326</script></p><ol><li>unified cache</li></ol><p>Miss rate</p><p>=<script type="math/tex">\frac{43.3}{1000}/(1.0+0.36)=0.0318</script></p><blockquote><p><strong>Q2:</strong> average memory access time?</p></blockquote><center><img src="image-20191208205644462.png" srcset="/img/loading.gif" alt="image-20191208205644462" style="zoom:40%;" /></center><center><img src="image-20191208205754992.png" srcset="/img/loading.gif" alt="image-20191208205754992" style="zoom:40%;" /></center><h2 id="2-1-存储器平均访问时间与处理器性能"><a href="#2-1-存储器平均访问时间与处理器性能" class="headerlink" title="2.1 存储器平均访问时间与处理器性能"></a>2.1 存储器平均访问时间与处理器性能</h2><h1 id="3-Six-Basic-Cache-Optimizations"><a href="#3-Six-Basic-Cache-Optimizations" class="headerlink" title="3. Six Basic Cache Optimizations"></a>3. Six Basic Cache Optimizations</h1><p>我们将所有缺失分成三类</p><ul><li><p>强制缺失[Compulsory]</p><p>cold-start/first-reference misses;</p></li><li><p>容量缺失[Capacity]</p><p>cache size limit;</p><p> blocks discarded and later retrieved;</p></li><li><p>冲突缺失</p><p>collision misses: associativity</p><p>a block discarded and later retrieved in a set;</p></li></ul><center><img src="image-20191208213224033.png" srcset="/img/loading.gif" alt="image-20191208213224033" style="zoom:30%;" /></center><center><img src="image-20191208213207928.png" srcset="/img/loading.gif" alt="image-20191208213207928" style="zoom:30%;" /></center><center><img src="image-20191208213148539.png" srcset="/img/loading.gif" alt="image-20191208213148539" style="zoom:30%;" /></center><h2 id="3-1-Larger-Block-size"><a href="#3-1-Larger-Block-size" class="headerlink" title="3.1 Larger Block size"></a>3.1 Larger Block size</h2><ul><li><p><strong>Reduce</strong> compulsory misses</p><p>​    Leverage spatial locality</p></li><li><p><strong>Reduce</strong> static power</p><p>​    block size增大，地址里面index位就变多，tag位数就变少，比较时需要的工作量就变少</p></li><li><p><strong>Increase</strong> conflict/capacity misses</p><p>​    Fewer block in the cache</p></li></ul><center><img src="image-20191208214954621.png" srcset="/img/loading.gif" alt="image-20191208214954621" style="zoom: 30%;" /></center><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><center><img src="image-20191208215035983.png" srcset="/img/loading.gif" alt="image-20191208215035983" style="zoom:40%;" /></center><p><strong>Answer</strong></p><p> avg mem access time</p><p>​        =hit time + miss rate x miss penalty</p><div class="note note-info">            <p> assume 1-CC hit time</p><p> for a 256-byte block in a 256 KB cache:</p><p> avg mem access time</p><p>​        = 1 + 0.49% x (80 + 2x256/16) = 1.5 cc</p>          </div><p> 2x256/16是因为存储器2cc能给cache传回16bytes</p><h2 id="3-2-Larger-cache"><a href="#3-2-Larger-cache" class="headerlink" title="3.2 Larger cache"></a>3.2 Larger cache</h2><ul><li><p><strong>Reduce</strong> capacity misses</p></li><li><p><strong>Increase</strong> hit time, cost, and power</p></li></ul><h2 id="3-3-Higher-Associativity"><a href="#3-3-Higher-Associativity" class="headerlink" title="3.3 Higher Associativity"></a>3.3 Higher Associativity</h2><ul><li><p><strong>Reduce</strong> conflict misses</p></li><li><p><strong>Increase</strong> hit time</p></li></ul><h2 id="3-4-Multilevel-cache"><a href="#3-4-Multilevel-cache" class="headerlink" title="3.4 Multilevel cache"></a>3.4 Multilevel cache</h2><ul><li><strong>Reduce</strong> miss penalty</li></ul><p><br/></p><h4 id="A-Two-level-cache"><a href="#A-Two-level-cache" class="headerlink" title="A. Two-level cache"></a>A. Two-level cache</h4><p> Add another level of cache between the original cache and memory</p><ul><li><p><strong>L1</strong>: small enough to match the clock cycle time of the fast processor;</p></li><li><p><strong>L2</strong>: large enough to capture many accesses that would go to main memory, lessening miss penalty</p></li></ul><center><img src="image-20191208220714030.png" srcset="/img/loading.gif" alt="image-20191208220714030" style="zoom:50%;" /></center><h4 id="B-Average-memory-access-time"><a href="#B-Average-memory-access-time" class="headerlink" title="B. Average memory access time"></a>B. Average memory access time</h4><p>=Hit timeL1 + Miss rateL1 x Miss penaltyL1</p><p>=Hit timeL1 + Miss rateL1</p><p> x(Hit timeL2+Miss rateL2xMiss penaltyL2)</p><h4 id="C-Average-mem-stalls-per-instruction"><a href="#C-Average-mem-stalls-per-instruction" class="headerlink" title="C. Average mem stalls per instruction"></a>C. Average mem stalls per instruction</h4><p>=Misses per instructionL1 x Hit timeL2</p><p> + Misses per instrL2 x Miss penaltyL2</p><h4 id="D-Local-miss-rate"><a href="#D-Local-miss-rate" class="headerlink" title="D. Local miss rate"></a>D. Local miss rate</h4><p> the number of misses in a cache</p><p> divided by the total number of mem accesses to <u>this cache</u>;</p><p> {:.info}</p><p>分成 Miss rateL1, Miss rateL2</p><h4 id="E-Global-miss-rate"><a href="#E-Global-miss-rate" class="headerlink" title="E. Global miss rate"></a>E. Global miss rate</h4><p> the number of misses in the cache </p><p> divided by the number of mem accesses generated by the processor;</p><p> {:.info}</p><p>L1的全局缺失率Miss rate<strong>L1</strong>,<u>L2的全局缺失率 Miss rateL1 x Miss rateL2</u></p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><blockquote><p>1000 mem references -&gt; 40 misses in L1 and 20 misses in L2;</p><p>miss penalty from L2 is 200 cc;</p><p>hit time of L2 is 10 cc;</p><p>hit time of L1 is 1 cc;</p><p>1.5 mem references per instruction;</p><p> <strong>Q: 1.</strong> various miss rates?</p></blockquote><p> <strong>L1:</strong> local = global</p><p> 40/1000 = 4%</p><p> <strong>L2:</strong></p><p> local: 20/40 = 50%</p><p> global: 20/1000 = 2%</p><blockquote><p><strong>Q: 2.</strong> avg mem access time?</p></blockquote><p>average memory access time</p><p>=Hit timeL1 + Miss rateL1</p><p> x(Hit timeL2+Miss rateL2xMiss penaltyL2)</p><p>=1 + 4% x (10 + 50% x 200)</p><p>=5.4</p><blockquote><p> <strong>Q: 3.</strong> avg stall cycles per instruction?</p></blockquote><p>average stall cycles per instruction</p><p>=Misses per instructionL1 x Hit timeL2</p><p> + Misses per instrL2 x Miss penaltyL2</p><p>=(1.5x40/1000)x10+(1.5x20/1000)x200</p><p>=6.6</p><h2 id="2-5-Prioritize-read-misses-over-writes"><a href="#2-5-Prioritize-read-misses-over-writes" class="headerlink" title="2.5  Prioritize read misses over writes"></a>2.5  Prioritize read misses over writes</h2><ul><li><strong>Reduce</strong> miss penalty</li></ul><div class="note note-info">            <p>这种方法使得在write buffer将数据写入memory之前，就可以为read操作提供服务</p>          </div><h2 id="2-6-Avoid-address-translation-during-indexing-cache"><a href="#2-6-Avoid-address-translation-during-indexing-cache" class="headerlink" title="2.6 Avoid address translation during indexing cache"></a>2.6 Avoid address translation during indexing cache</h2><p>虚拟缓存</p><h1 id="4-Ten-advanced-cache-optimizations"><a href="#4-Ten-advanced-cache-optimizations" class="headerlink" title="4. Ten advanced cache optimizations"></a>4. Ten advanced cache optimizations</h1><center><img src="image-20191209100308445.png" srcset="/img/loading.gif" alt="image-20191209100308445" style="zoom: 33%;" /></center><h2 id="4-1-Small-and-Simple-First-Level-Caches"><a href="#4-1-Small-and-Simple-First-Level-Caches" class="headerlink" title="4.1 Small and Simple First-Level Caches"></a>4.1 Small and Simple First-Level Caches</h2><ul><li>Small size</li></ul><blockquote><p>support a fast clock cycle</p><p>reduce power</p></blockquote><ul><li>Lower associativity</li></ul><blockquote><p>reduce both hit time and power</p><p>(direct-mapped caches can overlap the tag check with the transmission of the data)</p></blockquote><h2 id="4-2-Way-prediction"><a href="#4-2-Way-prediction" class="headerlink" title="4.2 Way prediction"></a>4.2 Way prediction</h2><p>•Reduce conflict misses and hit time</p><p>•<strong>Way prediction</strong></p><p> <em>block predictor bits</em> are added to each block to predict the way/block within the set of the <em>next</em> cache access</p><p> the multiplexor is set <strong>early to select the desired block</strong>;</p><p> only a single tag comparison is performed <strong>in parallel with cache reading</strong>;</p><p> a miss results in checking the other blocks for matches in the next clock cycle;</p><h2 id="4-3-Pipelined-Cache-Access"><a href="#4-3-Pipelined-Cache-Access" class="headerlink" title="4.3 Pipelined Cache Access"></a>4.3 Pipelined Cache Access</h2><ul><li><p>Increase cache bandwidth</p></li><li><p>Higher latency</p></li><li><p>Greater penalty on mispredicted branches and more clock cycles between issuing the load and using the data </p></li></ul><h2 id="4-4-Nonblocking-caches"><a href="#4-4-Nonblocking-caches" class="headerlink" title="4.4 Nonblocking caches"></a>4.4 Nonblocking caches</h2><blockquote><p>对于允许乱序执行的流水化计算机，他的处理器不必因为一次数据缓存缺失而停顿。在等待数据缓存返回缺失数据时，处理器可以继续从指令缓存中提取指令。nonblocking cache允许数据缓存在一次缺失期间继续提供缓存命令</p></blockquote><ul><li>Increase cache bandwidth</li></ul><h2 id="4-5-Multibanked-caches"><a href="#4-5-Multibanked-caches" class="headerlink" title="4.5 Multibanked caches"></a>4.5 Multibanked caches</h2><blockquote><p>Divide cache into independent banks that support simultaneous accesses</p><p>Sequential interleaving spread the addresses of blocks sequentially across the banks</p></blockquote><center><img src="image-20191217202233856.png" srcset="/img/loading.gif" alt="image-20191217202233856" style="zoom:50%;" /></center><ul><li>Increase cache bandwidth</li></ul><h2 id="4-6-Critical-Word-First-amp-Early-Restart"><a href="#4-6-Critical-Word-First-amp-Early-Restart" class="headerlink" title="4.6 Critical Word First &amp; Early Restart"></a>4.6 Critical Word First &amp; Early Restart</h2><p>通常CPU只会request一个word, 但是一个cache line对应了很多个word</p><ul><li>critical word first</li></ul><blockquote><p>首先请求critical word也就是CPU request的那个word, 然后发送给CPU, 然后再去请求一个cache line剩余的部分</p></blockquote><ul><li>early restart</li></ul><blockquote><p>按正常顺序获取word, 不需要等待一个cache line全部放入缓存再发送给处理器，而是critical word到了就直接发送给处理器，不需要等待还没有完成传输的word</p></blockquote><ul><li>Reduce miss penalty</li></ul><h2 id="4-7-Merging-Write-buffer"><a href="#4-7-Merging-Write-buffer" class="headerlink" title="4.7 Merging Write buffer"></a>4.7 Merging Write buffer</h2><p>Write merging merges four entries (with sequential addresses)  into a single buffer entry</p><center><img src="image-20191217203849064.png" srcset="/img/loading.gif" alt="image-20191217203849064" style="zoom:50%;" /></center><ul><li>Reduce miss penalty</li></ul><h2 id="4-8-Compiler-optimizations"><a href="#4-8-Compiler-optimizations" class="headerlink" title="4.8 Compiler optimizations"></a>4.8 Compiler optimizations</h2><h3 id="A-Loop-interchange"><a href="#A-Loop-interchange" class="headerlink" title="A. Loop interchange"></a>A. Loop interchange</h3><h4 id="before"><a href="#before" class="headerlink" title="before"></a>before</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;    x[i][j] = <span class="hljs-number">2</span> * x[i][j];  &#125;&#125;</code></pre></div><p>x[i][j]访问之后访问x[i+1][j],这中间差了100个数据</p><h4 id="after"><a href="#after" class="headerlink" title="after"></a>after</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;    x[i][j] = <span class="hljs-number">2</span> * x[i][j]  &#125;&#125;</code></pre></div><p>x[i][j]访问之后访问x[i][j+1], 这中间只差了一个数据，就可以按照数据存储的顺序来访问，增强了space locality。</p><p>这样一次miss之后，load多个word进cache的话，缺失就会变少</p><h3 id="B-Blocking-分块"><a href="#B-Blocking-分块" class="headerlink" title="B. Blocking[分块]"></a>B. Blocking[分块]</h3><h4 id="before-1"><a href="#before-1" class="headerlink" title="before"></a>before</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++) &#123;    &#123;      r = <span class="hljs-number">0</span>;      <span class="hljs-comment">//y的行 * z的列</span>      <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; N; k++) &#123;        r = r + y[i][k] * z[k][j]      &#125;    &#125;  &#125;&#125;</code></pre></div><p><img src="image-20191217210134473.png" srcset="/img/loading.gif" alt="image-20191217210134473" style="zoom:50%;" /></p><h4 id="after-1"><a href="#after-1" class="headerlink" title="after"></a>after</h4><p><em>maximize accesses to loaded data before they are replaced</em></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(jj = <span class="hljs-number">0</span>; jj &lt; N; jj = jj + B) &#123;  <span class="hljs-keyword">for</span>(kk = <span class="hljs-number">0</span>; kk &lt; N; kk = kk + B) &#123;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;      <span class="hljs-keyword">for</span>(j = jj; j &lt; min(jj+B, N); j++) &#123;        &#123;          r = <span class="hljs-number">0</span>;          <span class="hljs-keyword">for</span>(k = kk; k &lt; min(kk); k++) &#123;            r = r + y[i][k] * z[k][j];          &#125;          x[i][j] = x[i][j] + r;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre></div><p><img src="image-20191217210322625.png" srcset="/img/loading.gif" alt="image-20191217210322625" style="zoom:50%;" /></p><h2 id="4-9-Hardware-prefetching"><a href="#4-9-Hardware-prefetching" class="headerlink" title="4.9 Hardware prefetching"></a>4.9 Hardware prefetching</h2><p>指令和数据都可以预取，既可以直接放在cache中，也可以放在一个访问速度快于main memory的外部缓冲区中。</p><p>下面来看一下指令预取</p><p>通常，处理器在一次缺失时提取两个块。被请求块和下一个相邻块</p><ul><li>被请求块放在他返回时的指令缓存中</li><li>预取块放在指令流缓冲区中。</li></ul><p>请求时，如果发现被请求块位于指令流缓冲区，那么原缓存请求取消，从流缓冲区来读取这个块。并发出下一条预取请求</p><ul><li>Reduce miss penalty/rate</li></ul><h2 id="4-10-Compiler-Prefetching"><a href="#4-10-Compiler-Prefetching" class="headerlink" title="4.10 Compiler Prefetching"></a>4.10 Compiler Prefetching</h2><p>作为hardware prefetching的替代方法。可以在处理器需要某一数据之前，由编译器插入请求该数据的预取指令</p><p>有以下两种prefetch</p><ul><li><p><strong>Register</strong> <strong>prefetch</strong></p><p>load the value into a register</p></li><li><p><strong>Cache</strong> <strong>prefetch</strong></p><p>load data into the cache</p></li></ul><p><strong>Example</strong></p><p>16-byte blocks;</p><p>8-byte elements for a and b;</p><p>write-back strategy</p><p>a[0][0] miss, copy both a[0][0],a[0][1] as one block contains 16/8 = 2;</p><p><strong><em>before</em></strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i = i + <span class="hljs-number">1</span>)  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j = j + <span class="hljs-number">1</span>)    a[i][j] = b[j][<span class="hljs-number">0</span>] * b[j + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]</code></pre></div><p>缺失次数</p><p>对于a, $3\times(100/2)=150$次缺失</p><p>对于b, b不会从空间局部性受益，但是可以从时间局部性受益</p><p>b从b[0][0]访问到b[100][0]一共有101次缺失</p><p>总共251次缺失</p><p><strong><em>after prefetching</em></strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;  prefetch(b[j+<span class="hljs-number">7</span>][<span class="hljs-number">0</span>]);  prefetch(a[<span class="hljs-number">0</span>][j+<span class="hljs-number">7</span>]);  a[<span class="hljs-number">0</span>][j] = b[j][<span class="hljs-number">0</span>] * b[j+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;prefetch(a[i][j+<span class="hljs-number">7</span>]);    a[i][j] = b[j][<span class="hljs-number">0</span>] * b[j+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];  &#125;&#125;</code></pre></div><p>修改后，将会预取a[i][7]—-a[i][99]和b[7][0]—b[100][0]</p><p>所以非预取缺失只会出现在前几个循环</p><ul><li>第一个loop访问b[0][0]—-b[6][0]的7次缺失</li><li>第一个loop访问a[0][0]—a[0][7]的4次缺失</li><li>第二个loop访问a[1][0]—a[1][6]的4次缺失</li><li>第二个loop访问a[2][0]—a[2][6]的4次缺失</li></ul><p>总共有19次非预取缺失</p><p><strong>Reduce</strong> miss penalty/rate</p><h1 id="5-Memory"><a href="#5-Memory" class="headerlink" title="5. Memory"></a>5. Memory</h1><p>Performance Measures</p><ul><li><strong>Latency</strong></li></ul><div class="note note-warning">            <p>the time to retrieve the first word of the block</p>          </div><p> important for caches;</p><p> harder to reduce;</p><blockquote><p><strong>access time</strong>: the time between when a read is requested and when the desired word arrives;</p><p><strong>cycle time</strong>: the minimum time between unrelated requests to memory;</p><p><em>or</em> the minimum time between the start of an access and the start of the next access;</p></blockquote><ul><li><strong>Bandwidth</strong> </li></ul><p>the time to retrieve the rest of this block</p><h2 id="5-1-RAM"><a href="#5-1-RAM" class="headerlink" title="5.1 RAM"></a>5.1 RAM</h2><p><a href="https://www.zhihu.com/question/30492703" target="_blank" rel="noopener">Zhihu Birkee’s answer</a></p><p>RAM，Random-Access Memory，即随机存取存储器，其实就是内存，断电会丢失数据。<br>主要分为SRAM（static）和DRAM（dynamic)。主要的区别在于存储单元，DRAM使用电容电荷进行存储。需要一直刷新充电。SRAM是用锁存器锁住信息，不需要刷新。但也需要充电保持。</p><center><table>  <tr>    <td><div class="card">     <div class="card__image">       <img class="image" src="image-20191209104433202.png" srcset="/img/loading.gif" alt="image-20191209104433202" style="zoom:50%;" />   </div>     <div class="card__content">         <div class="card__header">             <h4>DRAM的基本存储单元</h4>         </div>         <p>利用一个晶体管进行控制电容的充放电</p>    </div></div></td>  <td><div class="card">     <div class="card__image">       <img class="image" src="image-20191209104458720.png" srcset="/img/loading.gif" alt="image-20191209104458720" style="zoom:50%;" />   </div>     <div class="card__content">         <div class="card__header">             <h4>DRAM一般的寻址模式</h4>         </div>         <p>控制的晶体管集成在单个存储单元中</p>    </div> </div></td>  </tr></table></center><h2 id="5-2-SRAM-for-cache-Static-Random-Access-Memory"><a href="#5-2-SRAM-for-cache-Static-Random-Access-Memory" class="headerlink" title="5.2 SRAM for cache[Static Random Access Memory]"></a>5.2 SRAM for cache[Static Random Access Memory]</h2><ul><li><p>Six transistors per bit to prevent the information from being disturbed when read</p></li><li><p>Don’t need to refresh, so access time is very close to cycle time</p></li></ul><h2 id="5-3-DRAM-for-main-memory-Dynamic-Random-Access-Memory"><a href="#5-3-DRAM-for-main-memory-Dynamic-Random-Access-Memory" class="headerlink" title="5.3 DRAM for main memory[Dynamic Random Access Memory]"></a>5.3 DRAM for main memory[Dynamic Random Access Memory]</h2><center><img src="image-20191209105411600.png" srcset="/img/loading.gif" alt="image-20191209105411600" style="zoom:30%;" /></center><center><img src="image-20191209105418930.png" srcset="/img/loading.gif" alt="image-20191209105418930" style="zoom:30%;" /></center><p>bing row into row buffer</p><center><img src="image-20191209105429474.png" srcset="/img/loading.gif" alt="image-20191209105429474" style="zoom:30%;"/></center><p>select Data via Multiplexor</p><center><img src="image-20191209105442259.png" srcset="/img/loading.gif" alt="image-20191209105442259" style="zoom:30%;"/></center><p>Data selected</p><center><img src="image-20191209105451917.png" srcset="/img/loading.gif" alt="image-20191209105451917" style="zoom:30%;"/></center><p>Row buffer hit</p><center><img src="image-20191209105459461.png" srcset="/img/loading.gif" alt="image-20191209105459461" style="zoom:30%;"/></center><p>Row buffer conflict</p><br>## 5.6 提高存储器的可靠性### Error type* **Soft errors**<div class="note note-info">            <p>changes to a cell’s contents, not a change in the circuitry</p>          </div>* **Hard errors**<div class="note note-info">            <p>permanent changes in the operation of one or more memory cells</p>          </div>### Error detection and fix<center><table>  <tr>    <td><div class="card">     <div class="card__content">         <div class="card__header">             <h4>Parity only</h4>         </div>         <p>only one bit of overhead to detect a single error in a sequence of bits;</p>    </div></div></td>  <td><div class="card">      <div class="card__content">         <div class="card__header">             <h4>ECC only</h4>         </div>         <p>detect two errors and correct a single error with 8-bit overhead per 64 data bits</p>    </div> </div></td>    <td><div class="card">      <div class="card__content">         <div class="card__header">             <h4>Chipkill</h4>         </div>         <p>类似于在磁盘中使用RAID方法，它分散数据和ECC信息，在单个存储器芯片完全失效时，可以从其余存储器芯片中重构丢失数据</p>    </div> </div></td>  </tr></table></center><h1 id="6-Disk"><a href="#6-Disk" class="headerlink" title="6. Disk"></a>6. Disk</h1><div class="item">     <div class="item__image">     <img class="image image--lg" src="image-20191209113803942.png" srcset="/img/loading.gif" alt="image-20191209113803942" style="zoom:50%;" />    <img class="image image--lg" src="image-20191209113823956.png" srcset="/img/loading.gif" alt="image-20191209113823956" style="zoom:50%;" />     </div>     <div class="item__content">       <div class="item__header">           <h4>Disk</h4>       </div>       <div class="item__description">         <p>Sector: minimum storage unit. A block may span multiple sectors</p>     <p>Cluster:(dis)contiguous groups of sectors to reduce the overhead of managing on-disk data structures; may span more than one track</p>      </div>     </div> </div><p>Areal density = $\frac{Tracks}{Inch}$ on a disk surface $\times$ $\frac{Bits}{Inch}$ on a track</p><h2 id="6-1-RAID-Redundant-Arrays-of-Inepensive-Disk"><a href="#6-1-RAID-Redundant-Arrays-of-Inepensive-Disk" class="headerlink" title="6.1 RAID[Redundant Arrays of Inepensive Disk]"></a>6.1 RAID[Redundant Arrays of Inepensive Disk]</h2><ul><li>RAID 0: No Redundancy</li><li>RAID 1: Mirroring / Shadowing</li></ul><blockquote><p>Two copies for every piece of data</p><p>one logical write = two physical writes</p><p>100% capacity/space  overhead</p></blockquote><center><img src="IMG_2C62CE9D9D16-1.jpeg" srcset="/img/loading.gif" alt="IMG_2C62CE9D9D16-1" style="zoom:50%;" /></center><ul><li>RAID 2:</li></ul><blockquote><p>Each bit of data word is written to a data disk drive</p><p>Each data word has its (Hamming Code) ECC word recorded on the ECC disks</p><p>On read, the ECC code verifies correct data or corrects single disks errors</p></blockquote><center><img src="image-20191216120558419.png" srcset="/img/loading.gif" alt="image-20191216120558419" style="zoom:50%;" /></center><ul><li>RAID 3:</li></ul><blockquote><p>RAID 3 P校验盘存的是前面所有盘数据的和。</p><p>他很慢，因为每读取一次磁盘数据，校验时要读取其他所有磁盘才能算校验和</p><p>磁盘坏了的话，也可以通过checksum恢复数据</p></blockquote><center><img src="IMG_E9E135911744-1.png" srcset="/img/loading.gif" alt="IMG_E9E135911744-1" style="zoom:50%;" /></center><center><img src="image-20191216121018499.png" srcset="/img/loading.gif" alt="image-20191216121018499" style="zoom:50%;" /></center><ul><li>RAID 4</li></ul><center><img src="IMG_17517EAA2585-1.png" srcset="/img/loading.gif" alt="IMG_17517EAA2585-1" style="zoom: 33%;" /></center><ul><li>RAID 5</li></ul><center><img src="IMG_8BFCBD97FD85-1.png" srcset="/img/loading.gif" alt="IMG_8BFCBD97FD85-1" style="zoom:30%;" /></center><ul><li>RAID 6</li></ul><blockquote><p>row parity</p></blockquote><center><img src="image-20191216130127847.png" srcset="/img/loading.gif" alt="image-20191216130127847" style="zoom:30%;" /></center><blockquote><p>Diagonal parity</p></blockquote><center><img src="image-20191216130657742.png" srcset="/img/loading.gif" alt="image-20191216130657742" style="zoom:30%;" /></center><p>看一个例子</p><p>disk 1和disk 3 double failure</p><center><img src="image-20191216130845614.png" srcset="/img/loading.gif" alt="image-20191216130845614" style="zoom:30%;" /></center><p>First recover Disk 3 stripe 0. Because its diagonal parity is independent from the other failed disk 1.</p><center><img src="image-20191216130921114.png" srcset="/img/loading.gif" alt="image-20191216130921114" style="zoom:30%;" /></center><p>When Disk 3 stripe 0 is recoverd, then we can recover Disk 1 stripe 3. Because on its row, only its stripe is failed. So we can use the row parity to recover the stripe.</p><center><img src="image-20191216130953500.png" srcset="/img/loading.gif" alt="image-20191216130953500" style="zoom:30%;" /></center><p>Now, we have recovered Disk 1 stripe 3 and Disk 3 stripe 0</p><center><img src="image-20191216131127165.png" srcset="/img/loading.gif" alt="image-20191216131127165" style="zoom:30%;" /></center><p>以下同理</p><center><img src="image-20191216131242663.png" srcset="/img/loading.gif" alt="image-20191216131242663" style="zoom:30%;" /></center><center><img src="image-20191216131302430.png" srcset="/img/loading.gif" alt="image-20191216131302430" style="zoom:30%;" /></center><center><img src="image-20191216131334869.png" srcset="/img/loading.gif" alt="image-20191216131334869" style="zoom:30%;" /></center><center><img src="image-20191216131357343.png" srcset="/img/loading.gif" alt="image-20191216131357343" style="zoom:30%;" /></center><center><img src="image-20191216131420435.png" srcset="/img/loading.gif" alt="image-20191216131420435" style="zoom:30%;" /></center><center><img src="image-20191216131449208.png" srcset="/img/loading.gif" alt="image-20191216131449208" style="zoom:30%;" /></center><center><img src="image-20191216131514362.png" srcset="/img/loading.gif" alt="image-20191216131514362" style="zoom:30%;" /></center><center><img src="image-20191216131536642.png" srcset="/img/loading.gif" alt="image-20191216131536642" style="zoom:30%;" /></center><center><img src="image-20191216131556362.png" srcset="/img/loading.gif" alt="image-20191216131556362" style="zoom:30%;" /></center><h1 id="7-I-O-performance"><a href="#7-I-O-performance" class="headerlink" title="7. I/O performance"></a>7. I/O performance</h1><h3 id="unique-measures"><a href="#unique-measures" class="headerlink" title="unique measures"></a>unique measures</h3><ul><li>Diversity</li></ul><blockquote><p>which I/O devices can connect to the computer system?</p></blockquote><ul><li>Capacity</li></ul><blockquote><p>how many I/O devices can connect to a computer system?</p></blockquote><h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><ul><li><p>response time[latency]</p></li><li><p>throughout[bandwidth]</p></li></ul><center><img src="image-20191216102829183.png" srcset="/img/loading.gif" alt="image-20191216102829183" style="zoom:50%;" /></center><h2 id="7-1-Throughout-VS-Response-Time"><a href="#7-1-Throughout-VS-Response-Time" class="headerlink" title="7.1 Throughout VS Response Time"></a>7.1 Throughout VS Response Time</h2><p><strong><em>Transaction</em></strong></p><blockquote><p>An interation between human and computer is called <strong><em><u>transaction</u></em></strong></p></blockquote><p>A <strong><em><u>transaction time</u></em></strong> is divided into three parts:</p><blockquote><ul><li><u>entry time</u></li></ul><blockquote><p>The time for user to enter the command</p></blockquote><ul><li><u>system response time</u></li></ul><blockquote><p>The time between when the user enters the command and the complete response is displayed</p></blockquote><ul><li><u>think time</u></li></ul><blockquote><p>The time from the reception of the response until the user begins to <strong><em><u>enter the next command</u></em></strong></p></blockquote></blockquote><center><img src="image-20191216210721189.png" srcset="/img/loading.gif" alt="image-20191216210721189" style="zoom:40%;" /></center><center><img src="image-20191216210659441.png" srcset="/img/loading.gif" alt="image-20191216210659441" style="zoom:50%;" /></center><p>More transaction time reduction than just the response time reduction. People need less time to think when given a faster response</p><h2 id="7-2-Transaction-Processing-Benchmarks"><a href="#7-2-Transaction-Processing-Benchmarks" class="headerlink" title="7.2 Transaction-Processing Benchmarks"></a>7.2 Transaction-Processing Benchmarks</h2><h3 id="A-SPEC"><a href="#A-SPEC" class="headerlink" title="A. SPEC"></a>A. SPEC</h3><h3 id="B-TPC-C"><a href="#B-TPC-C" class="headerlink" title="B. TPC_C"></a>B. TPC_C</h3><h2 id="7-3-A-little-Queuing-Theory-to-calculate-response-time-and-throughput"><a href="#7-3-A-little-Queuing-Theory-to-calculate-response-time-and-throughput" class="headerlink" title="7.3 A little Queuing Theory[to calculate response time and throughput]"></a>7.3 A little Queuing Theory[to calculate response time and throughput]</h2><center><img src="image-20191216104938324.png" srcset="/img/loading.gif" alt="image-20191216104938324" style="zoom:50%;" /></center><p><strong><em>Flow-balanced State</em></strong></p><ul><li><p>If the system is in <strong>steady state</strong>,  then the number of tasks entering the system must equal the number of tasks leaving the system</p></li><li><p>This <strong>flow-balanced state</strong> is necessary but not sufficient for steady state</p></li><li><p>The system has reached <strong>steady state</strong> if the system has been observed for a sufficiently long time and  mean waiting times stabilize</p></li></ul><h3 id="A-little’s-law-important"><a href="#A-little’s-law-important" class="headerlink" title="A. little’s law[important]"></a>A. little’s law[important]</h3><h4 id="i-Assumptions"><a href="#i-Assumptions" class="headerlink" title="i. Assumptions"></a>i. Assumptions</h4><div class="note note-info">            <p>input rate = output rate; </p><p>a steady supply of tasks independent for how long they wait for service;</p>          </div><h4 id="ii-little’s-law"><a href="#ii-little’s-law" class="headerlink" title="ii. little’s law"></a>ii. little’s law</h4><div class="note note-error">            <p>Mean number of tasks in system =  Arrival rate $\times$ Mean response time</p><p>注意arrival rate 表示单位时间到了几个task</p>          </div><h4 id="iii-single-server-model"><a href="#iii-single-server-model" class="headerlink" title="iii. single-server model"></a>iii. single-server model</h4><center><img src="image-20191216214128113.png" srcset="/img/loading.gif" alt="image-20191216214128113" style="zoom: 40%;" /></center><ul><li>$Time_{server}$  —Average time to service a task; average  $service_{rate}=1/Time_{server}$</li><li>$Time_{queue}$—Average time per task in the queue.</li><li>$Time_{system}$ —Average time per task in the system, or the response time, which is $Time_{queue}+Time_{server}$ .</li><li>Arrival rate—Average number of arriving tasks/second</li><li>$Length_{server}$—Average number of tasks in service.</li><li>$Length_{queue}$—Average length of queue.</li><li>$Length_{system}$—Average number of tasks in system, which is $Length_{server}+Length_{queue}$</li></ul><p><strong><em>Server Utilization</em></strong></p><div class="note note-info">            <p>Server utilization = Arrival rate$\times$ $Time_{server}$</p>          </div><center><img src="image-20191216110406290.png" srcset="/img/loading.gif" alt="image-20191216110406290" style="zoom:50%;" /></center><p><br/></p><p><strong><em>Time queue</em></strong></p><p>$Time_{queue}=Length_{queue}\times Time_{server}+$Mean time to complete the task being serviced when new task arrives if server is busy</p><p>$Time_{queue}=Time_{server}\times \frac{Server\;utilization}{1-Server\; utilization}$</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}Length_{queue}=&Arrival\; rate\times Time_{server}\times\frac{Server\;utilization}{1-Server\; utilization}\\ =&\frac{Server\; utilization^2}{1-Server\; utilization}\end{aligned}\end{equation}</script><h4 id="iv-M-M-1-queue"><a href="#iv-M-M-1-queue" class="headerlink" title="iv. M/M/1 queue"></a>iv. M/M/1 queue</h4><blockquote><p><strong>M</strong>: <em>Markov</em></p><p>exponentially random request arrival;</p><p><strong>M</strong>: <em>Markov</em></p><p>exponentially random service time</p><p><strong>1</strong></p><p>single server</p></blockquote><p><strong>assumptions</strong></p><blockquote><p>The system is in equilibrium</p><p><em>Interarrival</em> <em>times</em> [times between two successive requests arriving] are exponentionally distributed</p><p><em>Infinite population model</em>: unlimited number of sources of requests</p><p>Server starts on the next job immediately after finishing prior one</p><p>FIFO queue with unlimited length</p><p>One server only</p></blockquote><center><img src="image-20191216222544839.png" srcset="/img/loading.gif" alt="image-20191216222544839" style="zoom:50%;" /></center><center><img src="image-20191216222600418.png" srcset="/img/loading.gif" alt="image-20191216222600418" style="zoom:50%;" /></center><center><img src="image-20191216222618484.png" srcset="/img/loading.gif" alt="image-20191216222618484" style="zoom:50%;" /></center><h4 id="v-M-M-m-queue"><a href="#v-M-M-m-queue" class="headerlink" title="v. M/M/m queue"></a>v. M/M/m queue</h4><center><img src="image-20191216222740597.png" srcset="/img/loading.gif" alt="image-20191216222740597" style="zoom:50%;" /></center><center><img src="image-20191216222905001.png" srcset="/img/loading.gif" alt="image-20191216222905001" style="zoom:40%;" /></center>]]></content>
    
    
    <categories>
      
      <category>Computer Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer network--MAC子层</title>
    <link href="/2019/11/12/ComputerNetwork/MACLayer/"/>
    <url>/2019/11/12/ComputerNetwork/MACLayer/</url>
    
    <content type="html"><![CDATA[<p>计算机网络课程-MAC子层总结</p><a id="more"></a><style>  .page__header .header__brand path {    fill: rgba(255, 255, 255, .95);  }</style><p>网络链路可以分成两类</p><ul><li>点到点连接[PPP协议]</li><li>广播信道</li></ul><h1 id="1-信道分配问题"><a href="#1-信道分配问题" class="headerlink" title="1. 信道分配问题"></a>1. 信道分配问题</h1><h2 id="1-1静态信道分配"><a href="#1-1静态信道分配" class="headerlink" title="1.1静态信道分配"></a>1.1静态信道分配</h2><p>在多个竞争用户之间分配单个信道的传统做法是把信道容量拆开分给多个用户使用</p><h2 id="1-2-动态信道分配"><a href="#1-2-动态信道分配" class="headerlink" title="1.2 动态信道分配"></a>1.2 动态信道分配</h2><h3 id="1-2-1-关键假设"><a href="#1-2-1-关键假设" class="headerlink" title="1.2.1 关键假设"></a>1.2.1 关键假设</h3><ul><li><p>流量独立</p><p>模型由N个独立的站组成，每个站都有一个程序或者用户要传输的帧。在长度为$\Delta t$的间隔内，期望产生的帧数是$\lambda \Delta t$。这里的$\lambda$为常数(新帧的到达率)。</p></li><li><p><strong>单信道</strong></p><p>所有的通信都用这一个信道</p></li><li><p>冲突可观察</p><p>如果两帧同时传输，则他们在时间上就有重叠，产生混乱的信号，这就是冲突。所有的站都能检测到冲突。冲突的帧必须在以后再次被发送</p><p>[冲突的话会发送站点会检测到增强的信号</p></li><li><p>时间连续或分槽</p><p>时间可以假设连续：任意时刻都可以开始传输帧</p><p>时间可以分槽（离散）</p></li><li><p>载波侦听或不听</p></li></ul><h3 id="1-2-2-多路访问协议"><a href="#1-2-2-多路访问协议" class="headerlink" title="1.2.2 多路访问协议"></a>1.2.2 多路访问协议</h3><h4 id="i-纯ALOHA"><a href="#i-纯ALOHA" class="headerlink" title="i. 纯ALOHA"></a>i. 纯ALOHA</h4><p>思想:</p><blockquote><p>有数据要发就发送</p><p>如果帧破坏了，则发送方等待一个随机时间后再次发送</p></blockquote><p><img src="image-20191115204112604.png" srcset="/img/loading.gif" alt="image-20191115204112604" style="zoom:50%;" /></p><p>帧时[frame time]</p><blockquote><p>传输一个标准的、固定长度的帧需要的时间[帧的长度/比特率]</p></blockquote><p>假定站产生的新帧可以模型化为一个平均每“帧时”产生 N 个帧的泊松分布</p><p>出了新生成的帧外，每个站还会产生由于先前遭受冲突而重传的那些帧</p><p>进一步假设在每个“帧时”中，老帧和新帧合起来也符合泊松分布，每个帧时的平均帧数是G，显然$G\geq N$</p><p>参数定义</p><ul><li>帧时T[..frame length/bit rate]：发送一个标准长的帧所需的时间</li><li>吞吐率Throughput S：在一个帧时T内发送成功的平均帧数（0&lt;S&lt;1，S=1时信道利用率100%）</li><li>运载负载Offered load G：一个帧时T内所有通信站总共发送的帧平均值（包括原发和重发帧）（G≥S，G=S表示无冲突）</li><li>P0：一帧发送成功（未发生冲突）的概率，发送成功的分组在已发送分组的总数中所占的比例；公式：$S = G\times P0$</li></ul><p>如何计算P0</p><p>冲突危险期：2T[2个帧时]</p><p>在这个危险期，生成帧的均值为2G</p><p><img src="image-20191115204525493.png" srcset="/img/loading.gif" alt="image-20191115204525493" style="zoom:50%;" /><br><br/></p><p><img src="IMG_2DF27CD714C6-1.png" srcset="/img/loading.gif" alt="IMG_2DF27CD714C6-1" style="zoom: 33%;" /><br>在2T时间内发送成功的概率=2T时间内没有其他帧生成的概率</p><p>$P_0=\frac{(G\cdot 2)^0e^{-G\cdot 2}}{0!}=e^{-2G}$</p><p>$S=GP_0=Ge^{-2G}$</p><h4 id="ii-分槽ALOHA"><a href="#ii-分槽ALOHA" class="headerlink" title="ii. 分槽ALOHA"></a>ii. 分槽ALOHA</h4><p>思想</p><blockquote><p>时间离散化</p><p>必须要等到一个时间槽点开始时刻才能发送帧</p></blockquote><p><img src="image-20191115210524429.png" srcset="/img/loading.gif" alt="image-20191115210524429" style="zoom:50%;" /><br>性能如何？</p><p>只需要在当前帧时没有其他站发送帧就可以保证一个帧发送成功</p><p>$P_0=\frac{(G\cdot 1)^0e^{-G\cdot 1}}{0!}=e^{-G}$</p><p>$S=GP_0=Ge^{-G}$</p><p><img src="image-20191115210722147.png" srcset="/img/loading.gif" alt="image-20191115210722147" style="zoom:50%;" /></p><h3 id="1-2-3-载波侦听多路访问协议"><a href="#1-2-3-载波侦听多路访问协议" class="headerlink" title="1.2.3 载波侦听多路访问协议"></a>1.2.3 载波侦听多路访问协议</h3><p>上面两种属于不听就说</p><p>下面我们可以尝试先听再说的方式[发送帧之前检测信道中是否有数据在发送]</p><h4 id="i-CSMA-Carrier-sense-multiple-access-without-CD-collision-detection"><a href="#i-CSMA-Carrier-sense-multiple-access-without-CD-collision-detection" class="headerlink" title="i. CSMA[Carrier sense multiple access] without CD[collision detection]"></a>i. CSMA[Carrier sense multiple access] without CD[collision detection]</h4><p>A. Persistent CSMA[1-persistent]</p><ul><li>If the channel is <strong>idle</strong>, the station <strong>transmits</strong> a frame. </li><li>If the channel is <strong>busy</strong>, the station <strong>waits</strong> until it becomes idle. Then the station transmits a frame. </li><li>If a <strong>collision occurs</strong>, the station <strong>waits a random</strong> <strong>amount of time</strong> and starts all over again. </li></ul><p>这个协议也叫1-persistent，因为<strong>不停地去sense信道</strong>，只要信道空闲就能发现。当新到空闲时，他传输数据的概率为1。问题是，如果两个station都在等待信道，那么当信道空闲时，他们同时发送，这必然产生冲突</p><p><br/></p><p>B. Non-persistent CSMA</p><ul><li><p>If the channel is <strong>idle</strong>, the station <strong>transmits</strong> a frame. </p></li><li><p>If the channel is <strong>in use</strong>, the station <strong>does not</strong> continually sense it. Instead, it <strong>waits a random</strong> <strong>period of time</strong> and then repeats the algorithm. </p></li><li><p>If a <strong>collision occurs</strong>, the station <strong>waits a random</strong> <strong>amount of time</strong> and starts all over again. </p></li></ul><p>这种方式信道利用率比1-persistent高，但是比1-persistent的delay时间长</p><p><br/></p><p>C. p-persistent CSMA</p><p> <strong>Applied to slotted channels</strong></p><ul><li>If the channel is <strong>idle</strong>, it <strong>transmits with a probability</strong> <strong>p</strong>. With a probability <em>q=1-p</em>, it defers until the next slot. </li><li>If that slot is also idle, it either transmits or defers again, with probabilities <em>p</em> and <em>q</em>. </li><li>This process is repeated until either the frame has been transmitted or another station has begun transmitting. </li><li>If the channel is <strong>busy</strong>, it <strong>waits until the next slot</strong> and applies the above algorithm.</li></ul><p><img src="image-20191115220004447.png" srcset="/img/loading.gif" alt="image-20191115220004447" style="zoom: 25%;" /></p><h4 id="ii-CSMA-with-CD"><a href="#ii-CSMA-with-CD" class="headerlink" title="ii. CSMA with CD"></a>ii. CSMA with CD</h4><p>思想</p><blockquote><p>As soon as stations detect a collision, they stop their transmissions</p></blockquote><p>CSMA/CD可以出于以下几种状态</p><ul><li>contention</li><li>transmission</li><li>idle</li></ul><p><img src="image-20191115220550462.png" srcset="/img/loading.gif" alt="image-20191115220550462" style="zoom: 33%;" /><br>竞争算法：</p><blockquote><p>假设两个站同时在t0时刻开始传送数据，他们需要多长时间才能意识到发生冲突呢？ 2$\tau$</p><p>因此，将CSMA/CD竞争看成一个分槽ALOHA系统，时间槽宽度为$2\tau$</p><p>CSMA/CD 和分槽 ALOHA 的区别在于， 只有一个站能用来传输的时间槽（即信道被抓住了）<strong><em>后面紧跟的那些时间槽被用来传输该帧的其余部分</em></strong>。如果帧时相比传播时间长很多，这种差异将能大大提高协议的性能。</p></blockquote><p><img src="IMG_D9933EA1BF2A-1.png" srcset="/img/loading.gif" alt="IMG_D9933EA1BF2A-1" style="zoom: 33%;" /></p><h3 id="1-2-4-无冲突协议"><a href="#1-2-4-无冲突协议" class="headerlink" title="1.2.4 无冲突协议"></a>1.2.4 无冲突协议</h3><h4 id="i-位图协议"><a href="#i-位图协议" class="headerlink" title="i. 位图协议"></a>i. 位图协议</h4><p>一共有N个station，每个竞争期包含N个槽。如果0号station有一帧要发送，那么他在0号槽中传输1位。这个槽不允许其他station发送。</p><p>当所有N个槽都经过后，每个站都知道哪些站希望传送数据。</p><p>这是，按照数字顺序开始传送数据</p><p><img src="image-20191115224154892.png" srcset="/img/loading.gif" alt="image-20191115224154892" style="zoom:50%;" /><br>每个站都同意下一个是谁传输，所以永远不会发生冲突</p><p>当最后一个就绪站传送完它的帧后，另一个N位竞争期又开始了</p><p>Notations</p><ul><li>The time unit is one contention bit </li><li><em>N</em>: contention period</li><li><em>d</em>: data frame length </li></ul><p>性能分析</p><ul><li>low load</li></ul><blockquote><ul><li>for low-numbered stations ,比如0，1</li></ul><p>如果当这个station做好发送数据的准备时，当前槽出于位图中间的某个地方，那么这个station需要等待完成当前扫描的N/2个槽，在等待完成下一次扫描的另外N个槽，然后才能开始传输数据</p><p>如果处于开头的话，一种情况是刚好轮到他的槽，那么等待N就可以；一种情况是错过他的槽，那么他要等过这N次以及下个N个槽。平均为1.5</p><p>等待时间为1.5N</p><ul><li>for high-numbered stations, 比如上图6,7</li></ul><p>要么刚好轮到他不等，要么刚好错过他等N</p><p>平均等待0.5N个槽</p></blockquote><p>平均而言，delay for all stations is N</p><p>信道利用率为: $\frac{d}{N+d}$ 每一帧的额外开销是N位，数据长度为d位</p><ul><li>high load</li></ul><blockquote><p>the 𝑁 bit contention period is distributed over 𝑁 frames, yielding an overhead of only 1 bit per frame, </p></blockquote><p>the efficiency: $\frac{𝑑}{d + 1}$ </p><h4 id="ii-token-passing"><a href="#ii-token-passing" class="headerlink" title="ii. token passing"></a>ii. token passing</h4><p>令牌代表发送权限，令牌以预定义的顺序从一个站传到下一个站</p><p>如果站有个等待传输的帧队列，当他接收到令牌就可以发送帧，然后再把令牌传递到下一站；如果没有帧要传，则只是简单把令牌传递下去</p><p><img src="image-20191115233333760.png" srcset="/img/loading.gif" alt="image-20191115233333760" style="zoom:50%;" /></p><h4 id="iii-Binary-Countdown"><a href="#iii-Binary-Countdown" class="headerlink" title="iii. Binary Countdown"></a>iii. Binary Countdown</h4><h3 id="1-2-5-有限竞争协议"><a href="#1-2-5-有限竞争协议" class="headerlink" title="1.2.5 有限竞争协议"></a>1.2.5 有限竞争协议</h3><p>目前为止</p><ul><li>Methods with contention <ul><li><strong>Under</strong> <strong>low</strong> <strong>load</strong>, the contention method (i.e., pure or slotted ALOHA, CSMA) is preferable due to its low delay.  </li><li><strong>Under</strong> <strong>high</strong> <strong>load</strong>, the contention method becomes increasingly less efficient. </li></ul></li><li>Methods without contention <ul><li>Under low load, the collision-free method has high delay. </li><li>Under high load, the collision-free method becomes increasingly more efficient. </li></ul></li></ul><p>综合他们的优点缺点，提出limited-contention protocols</p><p>有限竞争协议在低负载下来用竞争的做法而提供较短的延迟，但在高负载下来用无冲突技术， 从而获得良好的信道效率</p><h4 id="Adaptive-Tree-Walk"><a href="#Adaptive-Tree-Walk" class="headerlink" title="Adaptive Tree Walk"></a>Adaptive Tree Walk</h4><p>把站看作二叉树的<strong>叶节点</strong></p><p>在一次成功传送之后的第一个竞争槽，即 0 号槽中，允许所有的站尝试获取信道。</p><p>如果它们之中的某一个获得了信道，则很好；如果发生了冲突，则在1号槽中， 只有位于树中 2 号节点之下的那些站才可以参与竞争。</p><p>如果其中的某个站获得了信道，则 在该站发送完一帧之后的那个槽被保留给位于节点 3 下面的那些站。</p><p>另一方面，如果节点 2 下面的两个或者多个站都要传输数据，则在 1 号槽中就会发生冲突，此时，下一个槽， 即 2 号槽就由位于节点 4 下面的站来竞争。</p><p><img src="image-20191115234633276.png" srcset="/img/loading.gif" alt="image-20191115234633276" style="zoom:50%;" /></p><h3 id="1-2-6-无限局域网协议"><a href="#1-2-6-无限局域网协议" class="headerlink" title="1.2.6 无限局域网协议"></a>1.2.6 无限局域网协议</h3><p>假设每个无线电发射器有某个固定的传播范围，用一个圆形覆盖区域表示，在这区域内的另一个站可以侦听并接收该站的传输</p><h4 id="隐藏终端问题"><a href="#隐藏终端问题" class="headerlink" title="隐藏终端问题"></a>隐藏终端问题</h4><blockquote><p>假设有3无线通信站ABC如下所示：<br>A        B         - C </p><p>其中B在C的无线电波范围内，但A不在C的无线电波范围内。此时C正在向B传送数据，而A也试图向B传送数据。此时，A不能够监听到B正在忙（因为A在监听信道的时候什么也听不到，所以它会错误的认为此时可以向B传送数据了）。如果A向B传送数据，则将导致错误。此即隐藏站问题。其中C是A的隐藏站。</p></blockquote><h4 id="暴露终端问题"><a href="#暴露终端问题" class="headerlink" title="暴露终端问题"></a>暴露终端问题</h4><blockquote><p>假设有3无线通信站ABC如下所示：<br>-A        B          C </p><p>其中B在A的无线电波范围内，但C不在A的无线电波范围内。此时A正在传送数据（向除B以外的某通信站），而B希望给C发送数据，但是错误地认为该传送过程将会失败（因为B会监听到一次传输，所以它会错误地认为此时不能向C发送数据）。此即暴露站问题。其中A是B的暴露站</p></blockquote><h4 id="冲突避免多路访问（MACA-Multiple-Access-with-Collision-Avoidance"><a href="#冲突避免多路访问（MACA-Multiple-Access-with-Collision-Avoidance" class="headerlink" title="冲突避免多路访问（MACA, Multiple Access with Collision Avoidance)"></a>冲突避免多路访问（MACA, Multiple Access with Collision Avoidance)</h4><p><img src="image-20191116001108257.png" srcset="/img/loading.gif" alt="image-20191116001108257" style="zoom:50%;" /></p><p>考虑A如何向B发送一帧。 </p><blockquote><ul><li><p>A首先给B发送一 个 RTS (Request To Send帧)，这个短帧 (30 字节）包含了随后将要发送的数据帧的长度</p></li><li><p>然后， B 用一个 CTS (Clear to Send ）作为应答， 此 CTS 帧也包含了数据长度（从 RTS 帧中复制过来）。 A 在收到了CTS 帧之后便开始传输。</p></li></ul></blockquote><p>现在我们来看，如果其他站也听到了这些帧，它们会如何反应。</p><blockquote><ul><li>如果一个站听到了 RTS 帧，那么它一定离 A 很近，它必须保持沉默，至少等待足够长的时间以便在无冲突情况下 CTS 被返回给 A</li><li>如果一个站听到了 CTS ，则它一定离 B 很近，在接下来的数据传送过程 中它必须一直保持沉默，只要检查 CTS 帧，该站就可以知道数据帧的长度（即数据传输要持续多久）。</li></ul></blockquote><p>但是这样仍然可能发生冲突：B 和 C 可能同时给 A 发送 RTS</p><p>这种方法对隐藏终端比较有效，无助于暴露终端问题</p><h1 id="2-以太网"><a href="#2-以太网" class="headerlink" title="2. 以太网"></a>2. 以太网</h1><h2 id="2-1-经典以太网物理层"><a href="#2-1-经典以太网物理层" class="headerlink" title="2.1 经典以太网物理层"></a>2.1 经典以太网物理层</h2><p><img src="image-20191116182110572.png" srcset="/img/loading.gif" alt="image-20191116182110572" style="zoom:50%;" /></p><p>采用Machester encoding</p><p>Differential Manchester encoding :</p><p>时钟的频率是比特率的两倍，也就是在一个bit 时间内，时钟会产生一次跳变。时钟XOR bit，产生输出</p><p><img src="image-20191116183235764.png" srcset="/img/loading.gif" alt="image-20191116183235764" style="zoom:50%;" /></p><blockquote><p>第一个bit时间t内，传输的bit是1，时钟在[0,t/2]内是0，与bit 1异或，编码成1;</p><p>在[t/2, t]内时钟跳变到1，与bit 0异或，编码成0.</p><p>因此我们在第一个bit时间看到的编码先是1后翻转到0</p></blockquote><p>问题：需要两倍于NRZ的带宽，一个bit时间他要传输两个信号</p><h2 id="2-2-经典以太网MAC子层协议"><a href="#2-2-经典以太网MAC子层协议" class="headerlink" title="2.2 经典以太网MAC子层协议"></a>2.2 经典以太网MAC子层协议</h2><p><img src="image-20191116183434635.png" srcset="/img/loading.gif" alt="image-20191116183434635" style="zoom:50%;" /></p><p><img src="IMG_2710(20191116-184052).png" srcset="/img/loading.gif" alt="IMG_2710(20191116-184052)" style="zoom: 33%;" /></p><p>这里有效帧长必须&gt;=64字节</p><p>减去目的地址原地址类型和checksum之后，数据部分部分&gt;=46字节</p><blockquote><p>因为争用期为$2\tau$，通常取为51.2us</p><p>对于10Mb/s以太网，在争用期可以发送512bit，也就是64字节</p><p>使用CSMA/CD, 直到信道空闲才会发送帧</p><p>如果两个站同时发送数据，则在$2\tau$时间内会检测到冲突。也就是在前64个字节就可以检测到冲突。如果前64个字节不冲突，则就不会冲突。</p></blockquote><h3 id="二进制指数后退-binary-exponential-backoff-的CSMA-CA"><a href="#二进制指数后退-binary-exponential-backoff-的CSMA-CA" class="headerlink" title="二进制指数后退[binary exponential backoff]的CSMA/CA"></a>二进制指数后退[binary exponential backoff]的CSMA/CA</h3><p>这个协议确定了随机等待时间</p><p>一个时间槽为$2\tau$, 基本退避时间为$2\tau$</p><p>第一次冲突发生后，每个站随机等待 0 个或者 1 个时间槽，之后再重试发送。如果两个站冲突之后选择了同一个随机数，那么它们将再次冲突。在第二次冲突后，每个站随机选择等待0、1、2或3个时间槽 。如果第三次冲突又发生了（发生的概率为 0.25 ），则下一次等待的时间槽数从 0 到 $2^3-1$ 之间随机选择。</p><p>达到 10 次冲突之后，随机数的选择区间被固定在最大值 1023 ，以后不再增加。 在 16 次冲突之后，控制器放弃努力，并给计算机返回一个失败报告 。</p><p>总而言之，如下</p><p><img src="IMG_D69A5042B9FC-1%202.png" srcset="/img/loading.gif" alt="IMG_D69A5042B9FC-1 2" style="zoom:76%;" /></p><p>实质：</p><blockquote><p> 冲突的次数大概能确定要发送的站的数量，二进制退避快速收敛到适应的数量</p></blockquote><p><br/></p><h2 id="2-3-Switched-Ethernet交换式以太网"><a href="#2-3-Switched-Ethernet交换式以太网" class="headerlink" title="2.3 Switched Ethernet交换式以太网"></a>2.3 Switched Ethernet交换式以太网</h2><p>在集线器中，所有站都位于同一个冲突域 (<strong><em>collision domain</em></strong>), 它们必须使用 CSMA/CD 算法来调度各自的传输。在交换机中，每个端口有自己独立的冲突域。</p><p>In a hub, all stations are in the same collision domain; while in a switch, each portis a collision domain.</p><p>通常情况下，电缆是全双工的[同时允许两个方向发送数据]，站和端口可以同时往电缆上发送帧，根本无须担心其他站或者端口。现在冲突不可能发生，因而 CSMA/CD 也就不需要了。然后，如果电缆是半双工的[同时只允许一个方向发送数据]，则站和端口必须以通常的 CSMA/CD 方式竞争传输。</p><p><img src="my_1568281840_ZK4myJNWO8.png" srcset="/img/loading.gif" alt="_1568281840_ZK4myJNWO8" style="zoom:67%;" /></p><blockquote><p>交换机的性能优于集线器有两方面的原因。</p><ul><li>由于没有冲突，容量的使用更为有效。</li><li>有了交换机可以同时发送多个帧（由不同的站发出〉。这些帧到达交换机端口井穿过交换机背板输出到适当的端口。然而，由于两帧可能在同一时间去往同一个输出端口，交换机必须有缓冲，以便它暂时把输入帧排入队列直到帧被传输到输出端口。</li></ul></blockquote><p>不可能做到的。系统总吞吐量通常可以提高一个数量级，主要取决于端口数目和流量模式。</p><h2 id="2-4-Fastethernet-100Mbps"><a href="#2-4-Fastethernet-100Mbps" class="headerlink" title="2.4 Fastethernet[100Mbps]"></a>2.4 Fastethernet[100Mbps]</h2><p>802.3u</p><p><img src="image-20191231000041449.png" srcset="/img/loading.gif" alt="image-20191231000041449" style="zoom:50%;" /></p><h2 id="2-5-Gigabit-Ethernet-1Gbps"><a href="#2-5-Gigabit-Ethernet-1Gbps" class="headerlink" title="2.5 Gigabit Ethernet[1Gbps]"></a>2.5 Gigabit Ethernet[1Gbps]</h2><p><img src="image-20191231000139476.png" srcset="/img/loading.gif" alt="image-20191231000139476" style="zoom:50%;" /></p><h2 id="2-6-10-Gigabit-Ethernet-10Gbps"><a href="#2-6-10-Gigabit-Ethernet-10Gbps" class="headerlink" title="2.6 10 Gigabit Ethernet[10Gbps]"></a>2.6 10 Gigabit Ethernet[10Gbps]</h2><p><img src="image-20191231000528967.png" srcset="/img/loading.gif" alt="image-20191231000528967" style="zoom:50%;" /></p><h1 id="3-无限局域网"><a href="#3-无限局域网" class="headerlink" title="3. 无限局域网"></a>3. 无限局域网</h1><h2 id="3-1-The-802-11-Architecture-and-Protocol-Stack"><a href="#3-1-The-802-11-Architecture-and-Protocol-Stack" class="headerlink" title="3.1 The 802.11: Architecture and Protocol Stack"></a>3.1 The 802.11: Architecture and Protocol Stack</h2><p><img src="image-20191231001119031.png" srcset="/img/loading.gif" alt="image-20191231001119031" style="zoom:50%;" /></p><p>802.11 网络的使用模式有两种：</p><blockquote><ul><li>最普遍使用的把客户端（比如笔记本电脑和智能手机客户端），连接到另一个网络（比如公司内联网或 Internet ）。这种使用模式如图 (a) 所示。在有架构模式下，每个客户端与一个接入点（ AP, Access Point ）关联，该接入点又与其他网络连接。客户端发送和接收数据包都要通过 AP 进行。几个接入点可通过一个称为分布式系统（ distribution system ）的有线网络连接在一起，形成一个扩展的 802.11 网络。 在这种情况下，客户端可以通过它们的接入点向其他客户端发送帧。</li><li>另一种模式，如图 4-23 (b ）所示，是一种自组织网络（ ad hoc network ）。这种模式下 的网络由一组相互关联的计算机组成，它们相互之间可以直接向对方发送帧。这里没有接入点。由于 Internet 接入是无线的杀手级应用，自组织网络并没有那么受欢迎。</li></ul></blockquote><p><img src="image-20191231222744244.png" srcset="/img/loading.gif" alt="image-20191231222744244" style="zoom:50%;" /></p><p>所有 802 协议的数据链路层分为两个或更多个子层。在 802.11 中 </p><blockquote><ul><li>介质访问控制（MAC, Medium Access Control) 子层决定如何分配信道，也就是说下一个谁可以发送。</li><li>在它上方的是逻辑链路控制（ LLC, Logical Link Control) 子层，它的工作是隐藏 802 系列协议之间的差异，使它们在网络层看来并无差别。</li></ul></blockquote><h2 id="3-2-The-802-11-Physical-Protocol"><a href="#3-2-The-802-11-Physical-Protocol" class="headerlink" title="3.2 The 802.11: Physical Protocol"></a>3.2 The 802.11: Physical Protocol</h2><ul><li>802.11: FHSS(Frequency Hopping Spread Specture) and Infrared[2.4Mbps]</li><li>802.11a: OFDM(Orthogonal Frequency Division Multiplexing) at 5GHz (54Mbps)</li><li>802.11b: HR-DSSS (High Rate Direct Sequence Spread Spectrum) (11Mbps)</li><li>802.11g: OFDM(Orthogonal Frequency Division Multiplexing) at 2.4 GHz (54Mbps)</li><li>802.11n: MIMO OFDM (Multiple-Input Multiple-Output Orthogonal Frequency Division Multiplexing) at multiple frequencies. (600Mbps)</li></ul><h2 id="3-3-The-802-11-Sublayer-Protocol"><a href="#3-3-The-802-11-Sublayer-Protocol" class="headerlink" title="3.3 The 802.11: Sublayer Protocol"></a>3.3 The 802.11: Sublayer Protocol</h2><h3 id="A-问题1"><a href="#A-问题1" class="headerlink" title="A. 问题1"></a>A. 问题1</h3><blockquote><p>无线电几乎总是半双工的，这意味着它们不能在一个频率上传输的同时侦听该频率上的突发噪声。接收到的信号很容易变得比发射信号弱上一百万倍，因此它无法在同一时间听到这么微弱的信号。而在以太网中，一个站只要等到介质空闲，然后开始传输。 如果它没有在发送的前 64 个字节期间收到返回的突发噪声，则几乎可以肯定帧能正确地传送出去。但对于无线介质，这种冲突检测机制根本不起作用。</p><p>因为冲突检测不起作用，所以802.11尝试避免冲突。采用的协议为带有冲突避免的CSMA/CA，CSMA with collision avoidance.</p></blockquote><h4 id="解决方式：CSMA-CA"><a href="#解决方式：CSMA-CA" class="headerlink" title="解决方式：CSMA/CA"></a>解决方式：CSMA/CA</h4><ul><li><p>通过侦听确定在一个很短的时间内[这段时间称为 <strong><em>DIFS</em></strong> ]没有信号：然后倒计数空闲时间槽</p></li><li><p>当有帧在发送时暂停该计数器：当计数器递减到 0, 该站就发送自己的帧。</p><ul><li>如果帧发送成功，目标站立即发送一个短确认。</li><li>如果没有收到确认， 则可推断出传输发生了错误，无论是冲突或是其他什么错。在这种情况下，发送方要加倍后退选择的时间槽数，再重新试图发送。如此反复，连续像以太网那样以指数后退，直到成功发送帧或达到重传的最大次数。</li></ul></li></ul><blockquote><p>下图给出了一个发送帧的时序例子。 </p><p>A 站首先发出一个帧。</p><p>当 A 发送时， B 站和 C 站准备就绪发送。它们看到信道正忙，便等待它变成空闲。不久， A 收到一个确认，信道进入空闲状态。</p><p>然而，不是两个站都发出一帧从而立即产生冲突，而是 B 站和 C 站都执行后退算法。 C 站选择了一个较短的后退时间，因而先获得发送权。 B 站侦听到 C 在使用信道时<u>暂停自己的倒计时</u>，并在 C 收到确认之后立即<u>恢复倒计时</u>。一旦 B 完成了后退，立即发送自己的帧。</p></blockquote><p><img src="image-20191231223848359.png" srcset="/img/loading.gif" alt="image-20191231223848359" style="zoom:50%;" /></p><p>802.11和以太网有两个主要区别</p><ul><li>首先，早期的后退有助于避免冲突。冲突避免在无线传输中非常重要，即使只发生一个冲突因为整个帧都被传输了出去，因此冲突的代价非常昂贵。</li><li>其次，利用确认来推断是否发生冲突，因为冲突无法被检测出来。</li></ul><p>这种操作模式称为<strong><em><u>分布式协调功能 DCF Distributed Coordination Function</u></em></strong>。因为每个站都独立行事，没有任何一种中央控制机制。[…标准还包括一个可选的操作模式，称为点协调功能（ PCF, Point Coordination Function）。在这种模式下， AP 控制自己覆盖范围内的一切活动。</p><h3 id="B-问题2-隐藏暴露终端问题"><a href="#B-问题2-隐藏暴露终端问题" class="headerlink" title="B. 问题2: 隐藏暴露终端问题"></a>B. 问题2: 隐藏暴露终端问题</h3><p>为了减少究竟哪个站在发送的模糊不清， 802.11 定义信道侦听包括物理侦听和虚拟侦听两部分。</p><ul><li>物理侦听只是简单地检查介质，看是否存在有效的信号</li><li>虚拟侦听，每个站可以保留一个信道何时要用的逻辑记录，这是通过跟踪网络分配向量（ NAV, Network Allocation Vector）获得的。每个帧携带一个 NAV字段，说明这个帧所属的一系列数据将传输多长时间。无意中听到这个帧的站就知道无论自己是否能够侦听到物理信号，由 NAV所指出的时间段信道一定是繁忙的。例如，一个数据帧的 NAV 给出了发送一个确认所需要的时间。所有听到该数据帧的站将在发送确认期间推迟发送，而不管它们是否能听到确认的发送。</li></ul><p>可选的 RTS/CTS 机制使用 NAV 来防止隐藏终端在同一时间发送。</p><blockquote><p>在下面这个例子中， A 想给 B 发送， C 是 A 范围内的一个站（也有可能在 B 的范围内，但 这并不重要）。 D 在 B 范围内，但不在 A 的范围内。</p><p>C A B  D</p></blockquote><p><img src="image-20191231233241805.png" srcset="/img/loading.gif" alt="image-20191231233241805" style="zoom:50%;" /></p><p>具体的</p><p>对A和B来说</p><blockquote><ul><li>该协议开始于当 A 决定向 B 发送数据时。 A 首先给 B 发送一个 RTS 帧，请求对方允许自己发送一个帧给它。</li><li>如果 B 接收到这个请求，它就以 CTS 帧作为应答，表明信道被清除可以发送。</li><li>一旦收到 CTS 帧， A 就发送数据帧，井启动一个 ACK 计时器。</li><li>当正确的数据帧到达后， B 用一个 ACK 帧回复 A，完成此次交流。如果 A 的 ACK 计时器超时前， ACK 没有返回，则可视为发生了一个冲突，经过一次后退整个协议重新开始运行。</li></ul></blockquote><p>对C和D来说</p><blockquote><p>C 和 D 的角度来看这次数据交流。 C 在 A 的范围内，因此它可能会收到 RTS 帧。</p><p>如果收到了，它就意识到很快有人要发送数据。从 RTS 请求帧提供的信息，可以估算出数据序列将需要传多长时间，包括最后的 ACK。因此，它停止传输任何东西，直到此次数据交换完成。它通过更新自己的 NAV 记录表明信道正忙。</p><p>D 无法听到 RTS ，但它确实听到了 CTS ，所以它也更新自己的 NAV。 请注意， NAV 信号是不传输的，它们只是由站内部使用，提醒自己保留一定时间内的安静。</p></blockquote><ul><li>可靠性： 无线网络环境嘈杂，并且不可靠，这是因为相当大一部分要受到来自其他种类设备的干扰</li></ul><blockquote><p>增加传输成功概率所用的策略是</p><ul><li><p>降低传输速率。在一个给定的信噪比环境下，速度放慢可以使用更健壮的调制解调技术，帧就越有可能被正确接收。</p></li><li><p>发送短帧。考虑任何一位都有可能出错，短帧每一位都不出错的概率比长帧高</p></li></ul></blockquote><ul><li>节省电源</li><li>服务质量</li></ul><blockquote><p>扩展了 CSMA/CA，并且仔细定义帧之间的各种时间间隔。 一帧发出去后，需要保持一段特定时间的空闲以便检查信道不在被用，然后任何站才可以发送帧。</p><p>这里的关键就在于<strong><em><u>为不同类型的帧确定不同的时间间隔</u></em></strong>。</p><p>5 个时间间隔如下图。常规的数据帧之间的间隔称为 DCF 帧间隔 [DIFS, DCF InterFrame Spacing ]。任何站都可以在介质空闲 DIFS 后尝试抓取信道发送一个新帧。采用通常的竞争规则，如果发生冲突或许还需要二进制指数后退。最短的间隔是短帧间间隔( SIFS, Short InterFrame Spacing ）。它允许一次对话的各方具有优先抓住信道的机会。例子 包括让接收方发送 ACK、诸如 RTS 和 CTS 的其他控制帧序列， 或者让发送方突发一系列 段。发送方只需等待 SIFS 即可发送下一段，这样做是为了阻止一次数据交流中间被其他站 横插一帧。</p></blockquote><p><img src="image-20200101001413274.png" srcset="/img/loading.gif" alt="image-20200101001413274" style="zoom:50%;" /></p><blockquote><ul><li><p>最短的间隔是短帧间间隔( SIFS, Short InterFrame Spacing ）。它允许一次对话的各方具有优先抓住信道的机会</p></li><li><p>常规的数据帧之间的间隔称为 DCF 帧间隔 (DIFS, DCF InterFrame Spacing ）。任何站都可以在介质空闲 DIFS 后尝试抓取信道发送一个新帧</p></li><li>两个仲裁帧间空间（ AIFS, Arbitration lnterFrame Space ）间隔显示了两个不同优先级 的例子。短的时间间隔 AIFS1 小于 DIFS ，但比 SIFS 长。较长的时间间隔 AIFS4 比 DIFS 还大</li><li>扩展帧间间隔 （EIFS, Extended InterFrame Spacing ） ，仅用于一个站刚刚收到坏帧或未知帧后报告问题</li></ul></blockquote><h2 id="3-4-802-11帧结构"><a href="#3-4-802-11帧结构" class="headerlink" title="3.4 802.11帧结构"></a>3.4 802.11帧结构</h2><p>The 802.11 standard defines three different classes of frames:</p><ul><li><p>Data</p></li><li><p>Control</p></li><li><p>Management</p></li></ul><p><img src="image-20200101005700537.png" srcset="/img/loading.gif" alt="image-20200101005700537" style="zoom:40%;" /></p><h1 id="4-Data-link-layer-Switching"><a href="#4-Data-link-layer-Switching" class="headerlink" title="4. Data link layer Switching"></a>4. Data link layer Switching</h1><p>网桥工作在<strong><em>数据链路层</em></strong>，因此它们通过检查数据链路层地址来转发帧。</p><h2 id="4-1-Uses-of-Bridges"><a href="#4-1-Uses-of-Bridges" class="headerlink" title="4.1 Uses of Bridges"></a>4.1 Uses of Bridges</h2><p>Why bridges are used?</p><ul><li><p>Different organizations have different LANs, but need communicate.</p></li><li><p>Different locations have different LANs. Using bridges are cost effective than using a centralized switch.</p></li><li><p>Multiple LANs are used to accommodate the load.</p></li></ul><p><img src="image-20200101010533214.png" srcset="/img/loading.gif" alt="image-20200101010533214" style="zoom:50%;" /></p><h2 id="4-2-Learning-Bridges"><a href="#4-2-Learning-Bridges" class="headerlink" title="4.2 Learning Bridges"></a>4.2 Learning Bridges</h2><p>所有附在网桥同一端口的站都属于<strong><em><u>同一个冲突域</u></em></strong>，该冲突域和其他端口的冲突域是不同。如果存在多个站，例如传统的以太网、集线器或半双工链路，那么帧的发送需要用到 CSMA/CD 协议。</p><p>两个局域网桥接在一起的拓扑结构分两种情况</p><ul><li>左侧两个多点局域网，比如经典以太网通过一个特殊的站连接在一起，这个站就是同属于两个局域网的网桥。</li><li>在右侧，局域网用点到点电缆连接在一起，包括一个集线器。</li></ul><p><img src="image-20200101010628782.png" srcset="/img/loading.gif" alt="image-20200101010628782" style="zoom:50%;" /></p><p>网桥算法</p><ul><li><p>When the first bridges are first plugged in, all the hash tables are empty. None of the bridges know where any of the destinations are, so they use the <strong><em>flooding algorithm</em></strong>.对于每个发向未知目 标地址的入境帧，网桥将它输出到所有的端口，但它来的那个输入端口除外</p></li><li><p>As time goes on, the bridges learn where destinations are. (<strong><em>backward learning</em></strong>)网桥可以看得到每个端口上发送的所有帧。通过检查这些帧的源地址， 网桥就可获知通过那个端口能访问到哪些机器。例如，上图(b)中，网桥 B1看到端口 3 上的一帧来自站 C，那么它就知道通过端口 3 一定能到达 C ，因此它就在哈希表 中构造一项。以后所有抵达 B1 要去 C 的帧都将被转发到端口 3。</p></li><li><p>Whenever a frame whose source is already in the table arrives, its entry is updated with the current time. (time updating) </p></li><li>Periodically, a process in the bridge scans the hash and purges all entries more than a few minutes old. (Aging)</li></ul><p>对于一个入境帧，它在网桥中的路由过程取决于它从哪个端口来（源端口），以及它要往哪个目标地址去（目标端口）。整个转发过程如下： </p><ol><li><p>如果去往目标地址的端口与源端口相同，则丢弃该帧。</p><blockquote><p>考虑上图b中，站 E 和 F 都连到集线器 H1，进而再连接到网桥 B2 。如果 E 发送一个帧给 F ，集线器将中继该帧到 B2 以及 F。这就是集线器该做的事情一一它们用有线把所有端口连在一起，这样从一个端口输入的帧只是输出到所有其他端口。该帧最终将从端口 2 到达 B2 ，这正是它到达目的地的正确输出端口。网桥 B2 只需丢弃该帧。</p></blockquote></li><li><p>如果去往目标地址的端口与源端口不同，则转发该帧到目标端口。</p></li><li><p>如果目标端口未知，则使用泛洪法，将帧发送到所有的端口，除了它入境的那个。</p></li></ol><h2 id="4-3-Spanning-Tree-Bridges"><a href="#4-3-Spanning-Tree-Bridges" class="headerlink" title="4.3 Spanning Tree Bridges"></a>4.3 Spanning Tree Bridges</h2><p>为了提高可靠性，网桥之间可使用冗余链路。在下图所示的例子中，在一对网桥之间并行设置了两条链路。这种设计可确保一条链路岩掉后，网络不会被分成两组计算机， 使得它们之间无法通信。</p><p>这种冗余引入了一些额外的问题，因为它生成了拓扑环路。</p><p><img src="image-20200101013110957.png" srcset="/img/loading.gif" alt="image-20200101013110957" style="zoom:40%;" /></p><p>解决环路问题的方法是，构造生成树</p><blockquote><p>5 个网桥互联在一起，同时还有站与这些网桥连接。每个站只与一个网桥相连。在网桥之间有一些冗余连接，因此如果这些链路都用，帧就有可能沿着环路转发。</p><p>我们可以将这种拓扑结构抽象成一个图，网桥为节点。点到点的链路是边。 通过去掉一些链路（图中用虚线表示），整个图即被简化为一棵生成树， 按照定义这树上没有环路。利用这棵生成树，从每个站到每个其他站恰好只有一条路径。 </p><p>一旦网桥同意这棵生成树，则站之间的所有转发都将沿着这棵树进行。由于从每个源到每 个目标都只有唯一一条路径可走，所以不可能产生环路。</p></blockquote><p><img src="image-20200101013333406.png" srcset="/img/loading.gif" alt="image-20200101013333406" style="zoom:50%;" /></p><h2 id="4-4-中继器／集线器／网桥／交换机／路由器和网关"><a href="#4-4-中继器／集线器／网桥／交换机／路由器和网关" class="headerlink" title="4.4 中继器／集线器／网桥／交换机／路由器和网关"></a>4.4 中继器／集线器／网桥／交换机／路由器和网关</h2><p><img src="image-20200101013706679.png" srcset="/img/loading.gif" alt="image-20200101013706679" style="zoom:50%;" /></p><h3 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h3><h4 id="A-Repeater中继器"><a href="#A-Repeater中继器" class="headerlink" title="A. Repeater中继器"></a>A. Repeater中继器</h4><p>用来在物理层放大信号</p><h4 id="B-Hub集线器"><a href="#B-Hub集线器" class="headerlink" title="B. Hub集线器"></a>B. Hub集线器</h4><p>集线器有许多条输入线路，它将这些输入线路连接在一起。从任何 一条线路上到达的帧都被发送到所有其他的线路上。如果两帧同时到达，它们将会冲突。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="A-网桥-交换机"><a href="#A-网桥-交换机" class="headerlink" title="A. 网桥/交换机"></a>A. 网桥/交换机</h4><p><img src="my_1568281840_ZK4myJNWO8.png" srcset="/img/loading.gif" alt="_1568281840_ZK4myJNWO8" style="zoom:67%;" /></p><p>与集线器不同的是网桥的每个端口被隔离成它 自己一个冲突域：如果端口是全双工的点到点线路，则需要用到 CSMA/CD 算法。当到达 一帧时，网桥从帧头提取出帧的目的地址，并用该地址查询一张应该把帧发往哪里去的表。</p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h2 id="4-5-VLAN"><a href="#4-5-VLAN" class="headerlink" title="4.5 VLAN"></a>4.5 VLAN</h2><p><img src="image-20200101014524120.png" srcset="/img/loading.gif" alt="image-20200101014524120" style="zoom:50%;" /></p><p>为了使VLAN正常地运行，网桥必须建立配置表。这些配置表指明了通过哪些端口可以访问哪些VLAN。当一帧到来时，比如说来自灰色VLAN，那么这帧必须被转发到所有标记为 G 的端口。这一条规则对于网桥不知道目的地位置的普通流量（即单播）以及组播和广播流量都适用。注意，一个端口可以标记为多种VLAN颜色。</p><p>refences</p><p>[1]<a href="https://blog.csdn.net/Jaihk662/article/details/80386620" target="_blank" rel="noopener">https://blog.csdn.net/Jaihk662/article/details/80386620</a></p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer network--数据链路层</title>
    <link href="/2019/10/16/ComputerNetwork/DataLinkLayer/"/>
    <url>/2019/10/16/ComputerNetwork/DataLinkLayer/</url>
    
    <content type="html"><![CDATA[<p>计算机网络课程—数据链路层总结</p><a id="more"></a><style>  .page__header .header__brand path {    fill: rgba(255, 255, 255, .95);  }</style><p><br/></p><h1 id="1-数据链路层的设计问题"><a href="#1-数据链路层的设计问题" class="headerlink" title="1. 数据链路层的设计问题"></a>1. 数据链路层的设计问题</h1><p>数据链路层使用物理层提供的服务在通信信道上发送和接收比特。要实现的功能包括</p><ul><li>向网络层提供一个定义良好的服务接口</li><li>处理传输错误</li><li>调节数据流，确保慢速的接受方不会被快速的发送方淹没</li></ul><p>数据包被封装成帧，每个帧包含一个Header,一个Payload field,一个Trailer</p><center><img src="image-20191012225542485.png" srcset="/img/loading.gif" alt="image-20191012225542485" style="zoom:50%;" /></center><h2 id="1-1-提供给网络层的服务"><a href="#1-1-提供给网络层的服务" class="headerlink" title="1.1 提供给网络层的服务"></a>1.1 提供给网络层的服务</h2><p>三种服务类型</p><ul><li>无确认的无连接服务</li></ul><blockquote><p>特点</p><ul><li><p>事先不用建立物理连接，事后也不用释放逻辑连接</p></li><li><p>源机器向目标机器发送独立的frame,目标机器不对这些frame进行确认</p></li></ul><p>适合的场合</p><ul><li><p>实时通信[数据迟到比数据受损更难忍受]</p></li><li><p>错误率比较低的场合[因为数据链路层可靠性不高，所以物理层reliable要求会高一点，适合有线网络</p></li></ul></blockquote><ul><li>有确认的无连接服务</li></ul><blockquote><p>特点</p><ul><li>不用建立物理连接</li><li>发送的每一帧都要单独确认，这样发送方可以知道一个帧是否已经正确到达目的地。如果一个帧在制定时间间隔内还没有到达，则发送方将再次发送该帧</li><li>不能保证收到包的顺序和发送顺序一致</li></ul><p>适用场合</p><ul><li>不可靠的信道：无线系统,WiFi</li></ul></blockquote><ul><li>有确认的有连接服务</li></ul><blockquote><p>源机器和目标机器在传输任何数据之前要建立一个连接，连接发送每一帧都被编号，数据链路层确保发出的每个帧都会真正被接收方按顺序收到且只收到一次。相当于提供了一个可靠的比特流</p><p>适用场合</p><ul><li>长距离且不可靠的链路 </li></ul></blockquote><h2 id="1-2-framing-成帧"><a href="#1-2-framing-成帧" class="headerlink" title="1.2 framing[成帧]"></a>1.2 framing[成帧]</h2><p>数据链路层要检测和纠正错误。</p><p>数据链路层通常的做法是将比特流拆分成多个离散的帧。</p><p>为每个帧计算一个称为校验和的短令牌，放在帧中一起传输。</p><p>帧到达目标机器时，重新计算校验和。如果新计算的校验和与传输过来的不同，说明产生了错误。</p><p><br/></p><p>拆分方法</p><h3 id="1-2-1-Byte-count"><a href="#1-2-1-Byte-count" class="headerlink" title="1.2.1 Byte count"></a>1.2.1 Byte count</h3><p>Method: to use a field in the header to specify the number of characters in the frame.</p><center><img src="image-20191008100755672.png" srcset="/img/loading.gif" alt="image-20191008100755672" style="zoom:35%;" /></center><p>problem:</p><p>错了一个character count就会全错</p><center><img src="image-20191012232424422.png" srcset="/img/loading.gif" alt="image-20191012232424422" style="zoom:50%;" /></center><h3 id="1-2-2-flag-bytes-with-byte-stuffing字节填充的标志字节法"><a href="#1-2-2-flag-bytes-with-byte-stuffing字节填充的标志字节法" class="headerlink" title="1.2.2  flag bytes with byte stuffing字节填充的标志字节法"></a>1.2.2  flag bytes with byte stuffing字节填充的标志字节法</h3><p>考虑到出错之后到重新同步问题，用一些标志字节(flag byte)作为一个帧开始和结束</p><center><img src="image-20191012233630323.png" srcset="/img/loading.gif" alt="image-20191012233630323" style="zoom:50%;" /></center><p>如图所示的这种frame的结构</p><p>两个连续的flag标志了一帧的结束和下一帧的开始。</p><p>problem:</p><p>如果标志字节在数据中出现，会干扰到帧的分界</p><p><br/></p><p>所以提出的解决方法是字节填充(byte stuffing)，发送方的数据链路层在数据中偶尔出现的每个标志字节前面插入一个特殊的转义字节(ESC),如果转移字符也出现在数据中，再用一个转义字符填充</p><center><img src="image-20191012234408243.png" srcset="/img/loading.gif" alt="image-20191012234408243" style="zoom:35%;" /></center><h3 id="1-2-3-flag-bit-with-bit-stuffing"><a href="#1-2-3-flag-bit-with-bit-stuffing" class="headerlink" title="1.2.3 flag bit with bit stuffing"></a>1.2.3 flag bit with bit stuffing</h3><p>考虑到字节填充只能使用8bits的字节，这里bit填充可以使帧包含任意大小单元</p><p>flag bits 01111110</p><p>也要考虑数据中出现flag的问题，所以发送方的数据链路层在数据中每遇到连续的5个1，就添加1个0</p><p>接收方看到5个连续的1，后面紧跟1个0，就自动剔除这个0</p><center><img src="image-20191013180557730.png" srcset="/img/loading.gif" alt="image-20191013180557730" style="zoom:50%;" /> </center><h3 id="1-2-4-physical-layer-encoding-violation"><a href="#1-2-4-physical-layer-encoding-violation" class="headerlink" title="1.2.4 physical layer encoding violation"></a>1.2.4 physical layer encoding violation</h3><p>物理层有讲过4B/5B的编码，4个比特被映射成5个比特，说明有16种信号不会出现在数据中，可以用来作为flag</p><h2 id="1-3-Error-control"><a href="#1-3-Error-control" class="headerlink" title="1.3 Error control"></a>1.3 Error control</h2><p>如何保证所有帧最终传递给目标机器的网络层，并且保持正确的顺序</p><p>– To provide the sender with some feedback</p><ul><li>Positive acknowledgement (ACK) 收到信号回一个ack</li><li>Negative acknowledgement (NAK) 没收到信号回一个nack， 潜在的假设是我知道发送的包以及发送的顺序</li></ul><p>– To provide timeout timers</p><ul><li>Resend as necessary</li></ul><p>– To number frames</p><ul><li>To distinguish retransmissions from originals</li></ul><h2 id="1-4-Flow-control"><a href="#1-4-Flow-control" class="headerlink" title="1.4 Flow control"></a>1.4 Flow control</h2><p>发送方发送帧的速度超过了接收方接收的速度，该如何处理</p><ul><li><p>To introduce flow control to throttle the sender into sending no faster than the receiver can handle the traffic.</p></li><li><p>Flow control protocol contains well-defined rules about when a sender may transmit the next frame.</p></li><li><p>Two approaches<br>– <strong>Feedback-based flow control</strong> 由receiver决定发送的速度</p><p>– Rate-based flow control</p></li></ul><h1 id="2-Error-Detection-and-Correction"><a href="#2-Error-Detection-and-Correction" class="headerlink" title="2. Error Detection and Correction"></a>2. Error Detection and Correction</h1><p>Error Types</p><blockquote><p>isolated errors单个的错误</p><p>burst errors一连串的错误</p></blockquote><p>approaches: 在数据中引入一些<u>冗余</u>来进行error detection和error correction</p><h2 id="2-1-一些概念"><a href="#2-1-一些概念" class="headerlink" title="2.1 一些概念"></a>2.1 一些概念</h2><h3 id="i"><a href="#i" class="headerlink" title="i."></a>i.</h3><p>一帧有</p><ul><li>m个数据位</li><li>r个冗余位。r个校验位是由m个数据位的函数计算得到的</li></ul><p>令数据块总长度为n(n=m+r)，我们称其为(n,m)码。</p><p><u>码字</u>(codeword): 一个包含了数据位和校验位的n位单元</p><p>码率(code rate): codeword中数据部分占比m/n</p><h3 id="ii"><a href="#ii" class="headerlink" title="ii."></a>ii.</h3><p>Hamming distance of 2 codewords</p><blockquote><p> 两个codeword中不相同的bit的个数</p></blockquote><p>Hamming distance of complete code(all valid codewords)</p><blockquote><p>The minimum Hamming distance of two valid codewords in the code</p></blockquote><center><img src="image-20191013185144979.png" srcset="/img/loading.gif" alt="image-20191013185144979" style="zoom:33%;" /></center><p>To detect d errors, you need d+1 Hamming distance code.</p><blockquote><p>因为，d+1的hamming distance,说明两个codeword之间最少有d+1位不相同。所以如果d个错误出现，这个codeword也不会错成一个valid codeword.</p></blockquote><p>To correct d errors, you need 2d+1 Hamming distance code</p><blockquote><p>因为,两个codeword之间最少有2d+1个bits不相同，如果有d errors,那么偏离原codeword的hamming distance 为d, 2d+1的距离保证了与这个错误的codeword距离最近的依然是原codeword</p></blockquote><h2 id="2-2-Error-Correction-codes"><a href="#2-2-Error-Correction-codes" class="headerlink" title="2.2 Error Correction codes"></a>2.2 Error Correction codes</h2><h3 id="2-2-1-Hamming-code-for-single-error"><a href="#2-2-1-Hamming-code-for-single-error" class="headerlink" title="2.2.1 Hamming code for single error"></a>2.2.1 Hamming code for single error</h3><p>参考以下两篇blog可以有一个基本了解，我结合他们做了一个总结</p><p><a href="https://blog.csdn.net/Yonggie/article/details/83186280" target="_blank" rel="noopener">https://blog.csdn.net/Yonggie/article/details/83186280</a></p><p><a href="https://blog.csdn.net/blue_starry_sky/article/details/53997548" target="_blank" rel="noopener">https://blog.csdn.net/blue_starry_sky/article/details/53997548</a></p><p>(图片中应该是redundancy)</p><table>  <tr>    <td><img src="IMG_5ACFEACB9F7D-1.png" srcset="/img/loading.gif" alt="IMG_5ACFEACB9F7D-1" style="zoom: 30%;" /></td>    <td>    <img src="IMG_AA14DF432E13-1.png" srcset="/img/loading.gif" alt="IMG_AA14DF432E13-1" style="zoom:40%;" /></td>  </tr></table><p>为什么上述纠错可行呢？</p><p>因为如果没有出现错误的话$hi\oplus(P_i组内异或结果)=0$，因为我们计算的时候$h_i=P_i组内异或结果$, 自己和自己异或为0。如果出现了一个错误的话，与这个错误相关的组$hi\oplus(P_i组内异或结果)=1$, 这些组别标识了错误的位置</p><p><br/></p><p><br/></p><p>-你知道吗，Hamming codes也可以用来correct burst error呢？</p><p>-哦？怎么做呢</p><p>-嘿嘿嘿，有一点tricky</p><ul><li>one codeword per row. k consecutive codewords</li><li>–Transmit the matrix by one column at a time.</li></ul><p>这样一行的连串错误，在列看来就是一列可以有一个错误</p><center><img src="image-20191229155224546.png" srcset="/img/loading.gif" alt="image-20191229155224546" style="zoom:50%;" /></center><h2 id="2-3-Error-Detection-codes"><a href="#2-3-Error-Detection-codes" class="headerlink" title="2.3 Error Detection codes"></a>2.3 Error Detection codes</h2><p>相比error correction, error detection代价更小。</p><p>error correction引入太多redundancy bit, 不如用error detection，如果检测到error,就retransmission这样代价小。</p><h3 id="2-3-1-Parity"><a href="#2-3-1-Parity" class="headerlink" title="2.3.1 Parity"></a>2.3.1 Parity</h3><blockquote><p>Append a parity bit to detect single error.</p></blockquote><p>奇校验：数据bit 1的个数为奇数就加一个0bit, 是偶数就加一个1bit。保持1的个数为奇数</p><p>偶校验：数据bit 1的个数为偶数就加一个0bit, 是奇数就加一个1bit。保持1点个数为偶数</p><p>single error显然是可以检测出来，其实burst error也是可以的，如下图，上文提到的按列发送</p><center><img src="image-20191024153859898.png" srcset="/img/loading.gif" alt="image-20191024153859898" style="zoom:50%;" /></center><h3 id="2-3-2-Checksum"><a href="#2-3-2-Checksum" class="headerlink" title="2.3.2 Checksum"></a>2.3.2 Checksum</h3><blockquote><p>将数据分成若干段，做加法，取模</p></blockquote><p>一个internet checksum的例子</p><center><img src="IMG_7FC95B48427A-1.png" srcset="/img/loading.gif" alt="IMG_7FC95B48427A-1" style="zoom: 33%;" />                  </center><p>性质</p><p>– Improved error detection over parity bits</p><p>– Vulnerable to systematic errors, 比如：在后面加了一连串0，检测不出错</p><h3 id="2-3-3-CRC"><a href="#2-3-3-CRC" class="headerlink" title="2.3.3 CRC"></a>2.3.3 CRC</h3><center><img src="IMG_BB50334654CE-1.png" srcset="/img/loading.gif" alt="IMG_BB50334654CE-1" style="zoom:36%;" /></center><center><img src="IMG_B37D4802C2E6-1.png" srcset="/img/loading.gif" alt="IMG_B37D4802C2E6-1" style="zoom:40%;" /></center><center><img src="IMG_CAA2C1958BE2-1.png" srcset="/img/loading.gif" alt="IMG_CAA2C1958BE2-1" style="zoom:31%;" /></center><p>注意一个$x^{k-1}+\cdots+1$是一个$k-1$阶多项式</p><p>选择余数的位数为除数的阶。比如$x^4+x+1$是一个4阶多项式，选择余数为4阶。</p><p><br/></p><h1 id="3-基本数据链路层协议"><a href="#3-基本数据链路层协议" class="headerlink" title="3. 基本数据链路层协议"></a>3. 基本数据链路层协议</h1><center><img src="image-20191024230806384.png" srcset="/img/loading.gif" alt="image-20191024230806384" style="zoom:25%;" /></center><h2 id="3-1-Elementary-Data-Link-Protocol"><a href="#3-1-Elementary-Data-Link-Protocol" class="headerlink" title="3.1 Elementary Data Link Protocol"></a>3.1 Elementary Data Link Protocol</h2><h3 id="3-1-2-Some-Assumptions"><a href="#3-1-2-Some-Assumptions" class="headerlink" title="3.1.2 Some Assumptions"></a>3.1.2 Some Assumptions</h3><ul><li>物理层、数据链路层、网络层都是独立的进程，通过来回传递消息进行通信。</li><li>机器A希望用一个可靠的、面向连接的服务向机器B发送一个长数据流</li><li>机器不会崩溃</li></ul><h3 id="3-1-3-声明"><a href="#3-1-3-声明" class="headerlink" title="3.1.3 声明"></a>3.1.3 声明</h3><p><code>seq_nr</code>对帧进行编号，0~MAX_SEQ</p><p>一个帧由4个字段组成:kind, seq, ack, info 前三个包含控制信息，最后一个可能包含要传输的实际数据，这些字段合起来称为 <strong>帧头</strong></p><blockquote><p>kind指出帧中是否有数据</p><p>seq序号</p><p>ack确认</p><p>info数据包</p></blockquote><p>信道传输，有时会丢失帧，发送方会启动计时器，在预设时间间隔没有收到应答，则时钟超时，链路层发出终端信号。实现</p><blockquote><p>让过程 <code>wait for event</code>返回 <code>event= timeout</code> </p><p>过程 <code>start_timer</code> 和 <code>stop_timer</code> 分别打开和关闭计时器。</p><p>只有当计时器在运行并且调用 <code>stop_timer</code> 之前，超时事件才有可能发生。在计时器运行的同时，允许显式地调用 start_timer: 这样的调用只是重置时钟，等到再经过一个完整的时钟间隔之后引发下一次超时事件（除 非它再次被重置，或者被关闭〉。</p></blockquote><p>过程 <code>start_ack_timer</code> 和 <code>stop_ack_timer</code> 控制一个辅助计时器，该定时器被用于在特定条件下产生确认。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_PKT 1024</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>&#125; boolean;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> seq_nr;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> data[MAX_PKT];&#125; packet;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;data, ack, nak&#125; frame_kind;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  frame_kind kind;  seq_nr seq;  seq_nr ack;  packet info;&#125; frame;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_for_event</span><span class="hljs-params">(event_type* event)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">from_network_layer</span><span class="hljs-params">(packet* p)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">to_network_layer</span><span class="hljs-params">(packet* p)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">from_physical_layer</span><span class="hljs-params">(frame* r)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start_timer</span><span class="hljs-params">(seq_nr k)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop_timer</span><span class="hljs-params">(seq_nr k)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start_ack_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop_ack_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enable_network_layer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disable_network_layer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-comment">//increment k circularly</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(k) <span class="hljs-meta-keyword">if</span>(k &lt; MAX_SEQ) k = k + 1; <span class="hljs-meta-keyword">else</span> k = 0</span></code></pre></div><h3 id="3-1-4-一个乌托邦式的单工协议"><a href="#3-1-4-一个乌托邦式的单工协议" class="headerlink" title="3.1.4 一个乌托邦式的单工协议"></a>3.1.4 一个乌托邦式的单工协议</h3><ul><li><p>Data are transmitted in <u>one direction only</u>.</p></li><li><p>The communication channel <u>never damages or loses frames</u>.</p></li><li><p>Both the transmitting and receiving network layers are <u>always ready</u>.</p></li><li><p>Processing time can be ignored.</p></li><li><p>Infinite buffer space is available.</p></li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;frame_arrival&#125; event_type;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"protocol.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sender1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  <span class="hljs-comment">//buffer for an outbound frame</span>  frame s;  <span class="hljs-comment">//buffer for an outbound packet</span>  packet buffer;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    <span class="hljs-comment">//从网络层拿一个包</span>    from_network_layer(&amp;buffer);    <span class="hljs-comment">//放到frame</span>    s.info = buffer;    <span class="hljs-comment">//传包</span>    to_physical_layer(&amp;s);  &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receiver1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  frame r;  <span class="hljs-comment">//filled in by wait, but not used here</span>  event_type event;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    <span class="hljs-comment">//only possibility is frame_arrival</span>    wait_for_event(&amp;event);    <span class="hljs-comment">//go get the inbound frame</span>    from_physical_layer(&amp;r);    <span class="hljs-comment">//pass the data to the network layer</span>    to_network_layer(&amp;r.info);  &#125;&#125;</code></pre></div><h3 id="3-1-5-A-simplex-stop-and-wait-protocol"><a href="#3-1-5-A-simplex-stop-and-wait-protocol" class="headerlink" title="3.1.5 A simplex stop-and-wait protocol"></a>3.1.5 A simplex stop-and-wait protocol</h3><ul><li><p>Data traffic is still <u>simplex protocol</u></p></li><li><p>The communication channel is assumed to be <u>error free</u>. </p></li><li><p>The sender is always ready. <strong><em><u>The receiver is NOT always ready or the receiver has limited buffer space</u></em></strong>.这里放宽了protocol的限制</p><ul><li>The sender simply inserts a delay into protocol 1 to slow it down sufficiently to keep from swamping the receiver. —&gt; low utilization of bandwidth.</li><li>The receiver provides <u>feedback</u> to the sender, permitting the sender to transmit the next frame.</li></ul></li><li><p>Protocol(p2) ensures sender can’t outspace receiver:</p><ul><li>Receiver returns a dummy frame (ack) when ready</li><li>Only one frame out at a time ± called stop-and-wait</li><li>We added flow control!</li></ul></li></ul><center><img src="image-20191025105854425.png" srcset="/img/loading.gif" alt="image-20191025105854425" style="zoom:30%;" /></center><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;frame_arrival&#125; event_type;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"protocol.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sender2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  frame s;  packet buffer;  event_type event;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    from_network_layer(&amp;buffer);    s.info = buffer;    to_physical_layer(&amp;s);    wait_for_event(&amp;event);  &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receiver2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  frame r, s;  event_type event;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    wait_for_event(&amp;event);    from_physical_layer(&amp;r);    to_network_layer(&amp;r.info);    to_physical_layer(&amp;s);  &#125;&#125;</code></pre></div><h3 id="3-1-6-A-simplex-protocol-for-a-noisy-channel"><a href="#3-1-6-A-simplex-protocol-for-a-noisy-channel" class="headerlink" title="3.1.6 A simplex protocol for a noisy channel"></a>3.1.6 A simplex protocol for a noisy channel</h3><ul><li>Data traffic is <u>still simplex</u></li><li>The communication channel is <strong><em><u>NOT free of errors</u></em></strong>.</li><li>The receiver is <strong><em><u>Not always ready</u></em></strong>.</li></ul><p>possible solutions:</p><ul><li><p>Protocol2 + timer —-&gt; duplicate packets</p></li><li><p>Protocol2 + timer + to number the frame</p></li></ul><p>如果在一个协议中，发送方在前移到下一个数据之前必须等待一个肯定确认，这样的协议称为自动重复请求(ARQ, Automatic Repeat Request)或者带有重传的肯定确认(PAR, Positive Acknowledgement with Retransmission)</p><table>  <tr>    <td>      <img src="image-20191025200128444.png" srcset="/img/loading.gif" alt="image-20191025200128444" style="zoom:50%;" />    </td>    <td>      <img src="image-20191025195618998.png" srcset="/img/loading.gif" alt="image-20191025195618998" style="zoom:50%;" />    </td>     <td>      <img src="image-20191025200041993.png" srcset="/img/loading.gif" alt="image-20191025200041993" style="zoom:50%;" />    </td>  </tr></table><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAZ_SEQ1</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;frame_arrival, cksum_err, timeout&#125; event_type;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"protocol.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sender3</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  <span class="hljs-comment">//seq number of next outgoing frame</span>  seq_nr next_frame_to_send;  <span class="hljs-comment">//scratch variable</span>  frame s;  <span class="hljs-comment">//buffer for an outbound packet</span>  packet buffer;  event_type event;  <span class="hljs-comment">//initialize outbound sequence numbers</span>  next_frame_to_send = <span class="hljs-number">0</span>;  <span class="hljs-comment">//fetch first packet</span>  from_network_layer(&amp;buffer);    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    <span class="hljs-comment">//construct a frame for transmission</span>    s.info = buffer;    <span class="hljs-comment">//insert sequence number in frame</span>    s.seq = next_frame_to_send;    <span class="hljs-comment">//send it on its way</span>    to_physical_layer(&amp;s);    <span class="hljs-comment">//if answer takes too long, timeout</span>    start_timer(s.seq);    <span class="hljs-comment">//frame_arrival, cksum_err, timeout</span>    wait_for_event(&amp;event);    <span class="hljs-keyword">if</span>(event == frame_arrival)&#123;      <span class="hljs-comment">//get the acknowledgement</span>        from_physical_layer(&amp;s);        <span class="hljs-keyword">if</span>(s.ack == next_frame_to_send) &#123;          <span class="hljs-comment">//turn the timer off</span>          stop_timer(s.ack);          <span class="hljs-comment">//get the next one to send</span>          from_network_layer(&amp;buffer);          <span class="hljs-comment">//invert next_frame_to_send</span>          inc(next_frame_to_send);      &#125;    &#125;  &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receiver3</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  frame r, s;  event_type event;  frame_expected = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    wait_for_event(&amp;event);<span class="hljs-comment">//frame_arrival, cksum_err</span>    <span class="hljs-keyword">if</span>(event == frame_arrival) &#123;      from_physical_layer(&amp;r);      <span class="hljs-keyword">if</span>(r.seq == frame_expected) &#123;        to_network_layer(&amp;r.info);        inc(frame_expected);      &#125;    &#125;  &#125;  s.ack = <span class="hljs-number">1</span> - frame_expected;&#125;</code></pre></div><table>  <tr>    <td>      <img src="IMG_DA892339BCCD-1.png" srcset="/img/loading.gif" alt="IMG_DA892339BCCD-1" style="zoom:60%;" />    </td>        <td>  <img src="IMG_430578E193A6-1.png" srcset="/img/loading.gif" alt="IMG_430578E193A6-1" style="zoom:70%;" />      </td>   </tr></table><p>​     </p><h3 id="3-1-7-Sliding-window-protocol"><a href="#3-1-7-Sliding-window-protocol" class="headerlink" title="3.1.7 Sliding window protocol"></a>3.1.7 Sliding window protocol</h3><p>前面的协议中，数据帧单向传输，但是大多数情况，需要双向传输。</p><p>实现全双工的一种方法是运行前面协议的两个实例，每个实例使用一条独立的链路进行单工数据传输。但是这样每条链路由一个“前向”信道(用于数据)和一个”逆向”信道(用于确认)组成。两种情况下的逆向带宽几乎被完全浪费了。</p><p>一种更好的做法是使用同一条链路来传输两个方向上的数据。</p><p>机器A向机器B发送数据帧和确认帧[确认收到机器B上一次发送的帧]混合，接收方只需检查帧头部kind字段，就可以分辨数据帧和确认帧</p><p><br/></p><p><strong>i. 捎带确认[piggybacking]</strong>：</p><blockquote><p>暂时延缓确认以便将确认信息搭载在下一个出境数据帧上的技术。确认信息被附加在往外发送的数据帧上[使用帧头的ack字段]</p><p>优化了上述发送数据帧和确认帧的方法，减轻了接收方的处理负担</p></blockquote><p><strong>ii. 滑动窗口[sliding window]</strong>:</p><blockquote><p>所有滑动窗口协议的本质是在任何时刻发送方总是维持一组序号，对应于允许它发送的帧。称这些帧落在<u>发送窗口</u>[sliding window]内。</p><p>接收方也维持一个<u>接受窗口</u>[receiving window]，对应于一组允许它接受的帧。</p><p>发送方的窗口和接收方的窗口不必有同样的上下界，甚至也不必有同样的大小</p><p>任何一个出境帧都包含一个序号， 范围从 0 到某个最大值。序号的最大值通常是$2^n-1$，这样序号正好可以填入到一个n位的字段中。停-等式滑动窗口协议使用n=1，限制了序号只能是 0 和 1 ，但是更加复杂的协议版本可以使用任意的n</p></blockquote><p><a href="https://blog.csdn.net/wdscq1234/article/details/52444277" target="_blank" rel="noopener">https://blog.csdn.net/wdscq1234/article/details/52444277</a></p><p>数据链路层协议将数据包递交给网络层的次序必须  和  发送机器上数据包从网络层传递给数据链路层的次序相同。</p><center><img src="image-20191026220230537.png" srcset="/img/loading.gif" alt="image-20191026220230537" style="zoom:50%;" /></center><p><strong><u>A. 一位滑动窗口协议</u></strong></p><p>窗口尺寸为1，发送方发出一帧以后，必须等待前一帧的确认的到来才能发送下一帧，这个协议使用了停-等式办法</p><table>  <tr>    <td>      <img src="IMG_BE2535BE4B0D.png" srcset="/img/loading.gif" alt="IMG_BE2535BE4B0D-1" style="zoom:55%;" />    </td>    <td>      <img src="https://miaochenlu.github.io/picture/IMG_7FBAD2BAF798-1.png" srcset="/img/loading.gif" alt="IMG_7FBAD2BAF798-1" style="zoom:50%;" />     </td>    </tr></table><center><img src="image-20191025202700163.png" srcset="/img/loading.gif" alt="image-20191025202700163" style="zoom:50%;" /></center><p><strong><u>B. Go back N</u></strong></p><p><a href="http://www.ccs-labs.org/teaching/rn/animations/gbn_sr/" target="_blank" rel="noopener">go back N动画</a></p><p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html" target="_blank" rel="noopener">GBN animination</a></p><p><a href="https://blog.csdn.net/qq_34501940/article/details/51180268" target="_blank" rel="noopener">https://blog.csdn.net/qq_34501940/article/details/51180268</a></p><center><img src="image-20191229212229327.png" srcset="/img/loading.gif" alt="image-20191229212229327" style="zoom:50%;" /></center><blockquote><p>在发送完一个帧后，不用停下来等待确认，而是可以连续发送多个数据帧。收到确认帧时，任可发送数据，这样就减少了等待时间，整个通信的通吞吐量提高。<br>如果前一个帧在超时时间内未得到确认，就认为丢失或被破坏，需要重发出错帧及其后面的所有数据帧。这样有可能有把正确的数据帧重传一遍，降低了传送效率。<br>线路很差时，使用退后N帧的协议会浪费大量的带宽重传帧。</p></blockquote><p><br/></p><p><br/></p><p><strong><u>C. Selective Repeat ARQ</u></strong></p><p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html" target="_blank" rel="noopener">ARQ</a></p><p>如果错误很少发生，则回退 n 协议可以工作得很好：但是，如果线路质量很差，那么重传的帧要浪费大量带宽。另一种处理错误的策略是选择重传协议，允许接收方<strong><em>接受并缓存坏帧</em></strong>或者丢失帧后面的所有帧。</p><center><img src="image-20191229210854474.png" srcset="/img/loading.gif" alt="image-20191229210854474" style="zoom:50%;" /><</center><blockquote><p>NAK：非确认帧，当在一定时间内没有收到某个数据帧的ACK时，回复一个NACK。<br>在发送过程中，如果一个数据帧计时器超时，就认为该帧丢失或者被破坏，接收端只把出错的的帧丢弃，其后面的数据帧保存在缓存中，并向发送端回复NAK。发送端接收到NAK时，只发送出错的帧。<br>如果落在窗口的帧从未接受过，那么存储起来，等比它序列号小的所有帧都按次序交给网络层，那么此帧才提交给网络层。<br>接收端收到的数据包的顺序可能和发送的数据包顺序不一样。因此在数据包里必须含有顺序字符来帮助接受端来排序。<br>选择重传协议可以避免重复传送那些正确到达接收端的数据帧。但是接收端要设置具有相当容量的缓存空间，这在许多情况下是不够经济的。</p></blockquote><p><strong><em>Window size</em></strong></p><ul><li><p>Send Window $Size &lt;= (MAX_SEQ+1)/2$ 注意Max_seq是指最大序号，不是最大数量</p></li><li><p>Receive Window Size = Send Window Size</p></li></ul><blockquote><p>这个问题的本质在于当接收方向前移动它的窗口后，新的有效序号范围与老的序号范围有重叠。因此，后续的一批帧可能是重复的帧（如果所有的确认都丢失了），也可能是新的帧（如果所有的确认都接收到了)。接收方根本无法区分这两种情形。</p></blockquote><center><img src="image-20191229205721964.png" srcset="/img/loading.gif" alt="image-20191229205721964" style="zoom:50%;" /></center><p><img src="image-20200104140132312.png" srcset="/img/loading.gif" alt="image-20200104140132312" style="zoom:50%;" /></p><ol><li>从t0-&gt;t1, Node-B返回的最后一个包是R3,3</li></ol><p>说明Node-B收到了0～2号包，所有下一个期待A发送3号包</p><p>因此，收到的有S0,0 &amp; S1,0 &amp; S2,0</p><ol><li>注意，题目中说，transmission sequence number and acknowledgment sequence number是3bit</li></ol><p>所有一共有8个序号</p><p>在GBN协议中，序号个数≥发送窗口+1</p><p>所以，发送窗口为7</p><p><img src="image-20200104140642889.png" srcset="/img/loading.gif" alt="image-20200104140642889" style="zoom:50%;" /></p><p>A还可以发送5个数据包</p><p>当发送第一个序号为5的数据帧时，可以同时对乙方发来的且按序到达的1号数据帧进行捎带确认，确认序号为2，因此甲方发送的第一个数据帧为S5,2；</p><p>同理，当发送最后一个序号为1的数据帧时，可以同时对乙方发来的且按序到达的1号数据帧进行捎带确认，确认序号为2，因此甲方发送的最后一个数据帧时S1,2。需要注意的是，尽管甲方收到了R3,3，也就是乙方发来的序号为3的数据帧，但是该数据帧并未按序到达，因为甲方之前没有收到序号为2的数据帧，因此甲方不能对R3,3进行捎带确认。</p><ol><li><p>方在t0时刻到t1时刻期间共发送了序号为0~4的5个数据帧。在t1时刻甲方超时重传2号数据帧，这表明甲方没有收到乙方对2号数据帧的确认，这可能是由于2号数据帧未按序到达乙方或按序到达乙方但出现了误码。由于甲乙双方都使用GBN协议，因此甲方需要重传超时的数据帧及其后续数据帧，也就是甲方需要重传序号为2~4的3个数据帧。重传的第一个帧的序号为2，由于之前已经按序正确收到乙方发来的序号为2的数据帧，因此可以进行捎带确认，确认号为3，因此重传的第一个帧为S2,3。</p></li><li></li></ol><script type="math/tex; mode=display">\frac{7\times 1000\times 8/100Mbps}{0.96ms+ 1000\times 8/100Mbps}=50\%</script><h1 id="4-数据链路层协议实例"><a href="#4-数据链路层协议实例" class="headerlink" title="4. 数据链路层协议实例"></a>4. 数据链路层协议实例</h1><h2 id="4-1-PPP"><a href="#4-1-PPP" class="headerlink" title="4.1 PPP"></a>4.1 PPP</h2><p>A standard protocol called PPP (Point to Point Protocol) is used to send packets over the links, including the SONET fiber optic links and ADSL links</p><center><img src="image-20191229214521665.png" srcset="/img/loading.gif" alt="image-20191229214521665" style="zoom:50%;" /></center><p>PPP 功能包括处理错误检测链路的配置、支持多种协议、允许身份认证等。它是一个 早期简化协议的改进，那个协议称为串行线路 Internet 协议 （SLIP, Serial Line Internet Protocol ）。伴随着一组广泛选项， PPP 提供了 3 个主要特性：</p><ul><li><p>一种成帧方法。它可以毫无歧义地区分出一帧的结束和下一帧的开始．</p></li><li><p>一个链路控制协议．它可用于启动线路、测试线路、协商参数， 以及当线路不再需要时温和地关闭线路。该协议称为<strong><em><u>链路控制协议 （LCP, Link Control Protocol）</u></em></strong>。</p></li><li><p>一种协商网络层选项的方式。协商方式独立于网络层协议．所选择的方法是针对每一种支持的网络层都有一个不同的<strong><em><u>网络控制协议 （NCP, Network Control Protocol)</u></em></strong>。</p></li></ul><p>因为没有必要重新发明轮子，所以 PPP 帧格式的选择酷似 HDLC 帧格式。 HDLC 是<strong><em><u>高级数据链路控制协议 （ High-level Data Link Control ）</u></em></strong>，是一个早期被广泛使用的家庭协议实例。</p><p>PPP 和 HDLC 之间的主要区别在于：</p><ul><li><p>PPP 是面向字节而不是面向比特的．特别是 PPP 使用字节填充技术，所有帧的长度均是字节的整数倍。 HDLC 协议则使用比特填充技术， 允许帧的长度不是字节的倍数，例如 30.25 字节。</p></li><li><p>HDLC 协议提供了可靠的数据传输，所采用的方式正是我们已熟悉的滑动窗口、确认和超时机制等。 PPP 也可以在诸如无线网络等嘈杂的环境里提供可靠传输，具体细节由盯Cl663 定义。然而，实际上很少这样做．相反， Internet几乎都是采用一种“无编号模式”来提供无连接无确认的服务．</p></li></ul><center><img src="image-20191229214119334.png" srcset="/img/loading.gif" alt="image-20191229214119334" style="zoom:45%;" /></center><h2 id="4-2-ADSL"><a href="#4-2-ADSL" class="headerlink" title="4.2 ADSL"></a>4.2 ADSL</h2><center><img src="image-20191229214707273.png" srcset="/img/loading.gif" alt="image-20191229214707273" style="zoom:40%;" /></center><center><img src="image-20191229215124692.png" srcset="/img/loading.gif" alt="image-20191229215124692" style="zoom:50%;" /></center>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CA - Pipeline</title>
    <link href="/2019/10/13/ComputerArchitecture/pipeline/"/>
    <url>/2019/10/13/ComputerArchitecture/pipeline/</url>
    
    <content type="html"><![CDATA[<h1><a name="pipline">附录C流水线</a></h1><h2 id="1-什么是流水线"><a href="#1-什么是流水线" class="headerlink" title="1 什么是流水线"></a>1 什么是流水线</h2><p>流水线是一种将多条指令 <strong><em>重叠执行</em></strong> 的实现技术  </p><p>一条执行包含多种操作，流水线充分利用了这些 <strong><em>操作之间的并行性</em></strong><br><br/></p><p>为了能更形象地理解这个问题，不妨用汽车装配线来做类比    </p><blockquote><p>汽车装配线的每一环节负责一项任务，所有环节是并行的（也就是不同的汽车同时在不同的环节上）  </p><p>在流水线中，指令就像是一辆待装配的汽车，不同环节完成指令的一部分,这些环节的每一步称为 <strong><em>流水级或者流水段</em></strong>。流水级前后相连形成流水线  </p><p>汽车装配线的 <strong><em>吞吐量</em></strong> 定义为单位时间生产的汽车数量，由完整汽车退出装配线的频率决定</p><p>流水线的吞吐量由指令退出流水线的频率决定。一条指令在流水线中下移一步需要的时间为 <strong><em>处理器周期</em></strong> 。因为各个环节同时执行，所以处理器周期由最缓慢的流水线级确定。</p></blockquote><p>可以想见，要使流水线性能高，平衡各流水线级很重要  </p><blockquote><p>因为处理器周期由最缓慢的流水线级确定，我们想要使最缓慢环节的加快，就要平衡各流水线级。  [木桶原理]</p></blockquote><p>如果各级达到完美平衡，那么每条指令在流水线处理器中的时间为  </p><script type="math/tex; mode=display">\frac{非流水线机器上每条指令的时间}{流水级的数目}</script><p>在这些条件下，流水线加速比=流水级的数目</p><p><br/></p><h1 id="2-RISC指令集"><a href="#2-RISC指令集" class="headerlink" title="2 RISC指令集"></a>2 RISC指令集</h1><p>我们以RISC指令集为例来了解一下流水线实现。一下，我们会介绍RISC指令集以及没有流水线的实现方式。</p><p>RISC指令集子集中每条指令都可以在5个时钟周期以内实现。以MIPS指令集为例介绍这5个时钟周期</p><ul><li><strong><em>指令提取周期(IF(Instruction Fetch))</em></strong>  </li><li><strong><em>指令译码/寄存器提取周期(ID)</em></strong>  </li><li><strong><em>执行/有效地址周期(EX)</em></strong>  </li><li><strong><em>存储器访问(MEM)</em></strong></li><li><strong><em>写回周期(WB)</em></strong></li></ul><center><img="/Users/jones/Library/Application Support/typora-user-images/image-20191219230108716.png" alt="image-20191219230108716" style="zoom:50%;" /></center><p><a href="http://web.cs.iastate.edu/~prabhu/Tutorial/PIPELINE/DLXimplem.html" target="_blank" rel="noopener">http://web.cs.iastate.edu/~prabhu/Tutorial/PIPELINE/DLXimplem.html</a></p><p><br/></p><h1 id="3-RISC处理器经典五级流水线"><a href="#3-RISC处理器经典五级流水线" class="headerlink" title="3 RISC处理器经典五级流水线"></a>3 RISC处理器经典五级流水线</h1><center><img src="ca20190908-1.png" srcset="/img/loading.gif" width="600"></center><center><img src="ca20190908-2.png" srcset="/img/loading.gif" width="600"></center><p><br/></p><p>在RISC流水线中，多条指令的执行重叠不会引入多少冲突，因为以下三点</p><h4 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h4><p>使用分离的指令存储器和数据存储器。</p><p>这样做是因为指令提取和数据访问都需要访问存储器，会引发冲突，所以分离指令和数据存储器。</p><p>注意：如果流水线处理器时钟周期=多周期处理器时钟周期，存储器需要提供<strong>5倍带宽</strong></p><h4 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h4><p>两个阶段使用了寄存器堆：<strong>ID</strong>阶段decode, <strong>WB</strong>阶段writeback写入</p><p>因此，每个时钟周期寄存器需要两次读取(A=Reg[rs], B=Reg[rt]) 和一次写入</p><p>为了出气对相同寄存器堆多次读取和一次写入，<strong><em>我们在时钟周期的前半部分写寄存器，后半部分读寄存器</em></strong></p><h4 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h4><p>程序计数器在IF阶段要递增</p><p>ID阶段要计算潜在的分支目标。若分支在ID改变程序计数器？</p><p><br/></p><p>除了要确保流水线中的指令不会在相同时间使用相同的硬件资源，还要确保不同流水级的指令不会互相干扰。这是通过在流水级之间引入 <u>流水线寄存器</u>来实现的。将一个给定的流水级得出的结果存储到流水线寄存器，并在下一个时钟周期作为下一个流水级的输入。</p><center><img src="image-20191013133054888.png" srcset="/img/loading.gif" alt="image-20191013133054888" style="zoom: 30%;" /></center><h1 id="4-流水化的主要阻碍-流水线冒险"><a href="#4-流水化的主要阻碍-流水线冒险" class="headerlink" title="4 流水化的主要阻碍-流水线冒险"></a>4 流水化的主要阻碍-流水线冒险</h1><p>冒险降低来了流水化所能带来的理想加速比<br>冒险共有一下三类  </p><ol><li><p>结构冒险  </p><p>在重叠执行模式下，硬件无法同时支持指令的所有可能组合，就会出现资源冲突 [比如大家都想访问存储器]</p></li><li><p>数据冒险  </p><p>指令之间存在先后顺序，一条指令取决于先前指令的结果</p></li><li><p>控制冒险 </p><p>分支指令以及其他改变程序计数器的指令会导致控制冒险</p></li></ol><p>为了避免冒险，要求流水线中的一些指令延迟时，其他指令能够继续执行 。</p><div class="note note-warning">            <p>这里讨论的流水线，当一条指令被stall时，在指令停顿之后发射的<strong><em>所有指令也会被停顿</em></strong>，之前发射的指令不会被停顿</p>          </div><p><br/></p><h2 id="4-1-带有停顿的流水线性能"><a href="#4-1-带有停顿的流水线性能" class="headerlink" title="4.1 带有停顿的流水线性能"></a>4.1 带有停顿的流水线性能</h2><p>$<br>流水化加速比=\frac{非流水化指令平均执行时间}{流水化指令平均执行时间}$<br>$=\frac{非流水化CPI\times 非流水化时钟周期}{流水化CPI\times 流水化时钟周期}$<br>$=\frac{非流水化CPI}{流水化CPI}\times \frac{非流水化时钟周期}{流水化时钟周期}$</p><p><br/></p><p>流水化处理器的理想CPI几乎总是等于1，算上停顿<br>$<br>流水化CPI=理想CPI+每条指令的流水线停顿时钟周期$<br>$=1+每条指令的流水线停顿时间周期$</p><p>所以</p><script type="math/tex; mode=display">加速比=\frac{非流水化CPI}{1+每条指令的流水线停顿周期}</script><p>如果所有指令周期数相同，等于流水级数目(流水线深度)，那么非流水化CPI=流水线深度</p><script type="math/tex; mode=display">加速比=\frac{流水深度}{1+每条指令的流水线停顿周期}</script><div class="note note-warning">            <p><u>所以，如果没有流水线停顿，加速比=流水线深度</u></p>          </div><h2 id="4-2-结构冒险"><a href="#4-2-结构冒险" class="headerlink" title="4.2 结构冒险"></a>4.2 结构冒险</h2><p>i. 什么是结构冒险</p><blockquote><p>指令重叠执行需要实现功能单元的流水化和资源的复制，以允许在流水线中出现所有可能的指令组合</p><p>如果由于资源冲突而不能容许某些指令组合，就说出现结构冒险</p></blockquote><p>ii. 解决方式</p><p>在发生结构冒险时，使流水线停顿一个时钟周期</p><p>停顿称为 <u>流水线气泡</u>，他们漂浮穿过流水线，占有空间但是不执行有效工作。导致CPI增大</p><p><br/></p><h2 id="4-3-数据冒险"><a href="#4-3-数据冒险" class="headerlink" title="4.3 数据冒险"></a>4.3 数据冒险</h2><p>i. 数据冒险是什么</p><blockquote><p>有些指令依赖于之前指令的结果</p></blockquote><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">DADD</span> <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R3</span><span class="hljs-symbol">DSUB</span> <span class="hljs-built_in">R4</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R5</span><span class="hljs-keyword">AND </span> <span class="hljs-built_in">R6</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R7</span><span class="hljs-symbol">OR</span>   <span class="hljs-built_in">R8</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R9</span><span class="hljs-symbol">XOR</span>  <span class="hljs-built_in">R10</span>,<span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R11</span></code></pre></div><p>DADD后的所有指令都用到了DADD指令的结果R1</p><p>所以在DADD的结果writeback之前，下面的指令都是不能execute的</p><center><img src="image-20191013143518878.png" srcset="/img/loading.gif" alt="image-20191013143518878" style="zoom:30%;" /></center><p>ii. 解决方法</p><p>A. 转发(forwarding)</p><p>转发是一个什么思想呢？ </p><blockquote><p>DSUB需要DADD的结果x, 那么不妨DADD在算出x之后，就把结果给到DSUB需要这个x的位置，而不用等到writeback</p></blockquote><p>转发的工作方式</p><ol><li>来自EX/MEM和MEM/WB流水线寄存器的输入总是被反馈回ALU的输入端</li><li>如果转发硬件检测到前一个ALU操作已经对当前ALU操作的原寄存器进行了写入操作，则控制逻辑选择转发结果作为ALU输入，而不是选择从寄存器堆中读区的值</li></ol><center><img src="https://miaochenlu.github.io/picture/屏幕快照 2019-10-13 下午2.56.04.png" srcset="/img/loading.gif" style="zoom: 30%;" /></center><p>B, 需要停顿的数据冒险</p><p>并非所有的潜在数据冒险都可以通过转发处理</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">LD</span>   <span class="hljs-built_in">R1</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">R2</span>)<span class="hljs-symbol">DSUB</span> <span class="hljs-built_in">R4</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R5</span><span class="hljs-keyword">AND </span> <span class="hljs-built_in">R6</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R7</span><span class="hljs-symbol">OR</span>   <span class="hljs-built_in">R8</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R9</span></code></pre></div><center><img src="image-20191013151122898.png" srcset="/img/loading.gif" alt="image-20191013151122898" style="zoom:30%;" /></center><center><img src="image-20191013151314878.png" srcset="/img/loading.gif" alt="image-20191013151314878" style="zoom:25%;" /></center><h3 id="More-about-data-dependences-and-hazards"><a href="#More-about-data-dependences-and-hazards" class="headerlink" title="More about data dependences and hazards"></a>More about data dependences and hazards</h3><h4 id="A-data-dependences"><a href="#A-data-dependences" class="headerlink" title="A. data dependences"></a>A. data dependences</h4><ol><li>数据相关[真数据相关]</li></ol><p>指令i生成的结果可能会被指令j用到</p><p>指令j数据相关于指令k, 指令k数据相关于指令i</p><center><img="https://miaochenlu.github.io/picture/image-20191223102354535.png" alt="image-20191223102354535" style="zoom:50%;" /></center><ol><li>名称相关</li></ol><p>当两条指令使用相同的寄存器或者存储器位置[称为名称]， 但与该名称相关的指令之间并没有数据流动时，就会发生名称相关。</p><ul><li><p>Anti-dependence: S1 -&gt; S2 </p><p>(i)  S1 executes before S2<br>(ii) S1 reads from a location that is overwritten later by S2</p></li></ul><div class="note note-warning">            <p>WAR</p><ul><li><p>Output dependence: S1 -&gt; S2 </p><p>(i)  S1 executes before S2<br>(ii) S1 and S2 write to the same location </p></li></ul>          </div><p>WAW</p><p>由于没有在指令之间传递值, 所以antidependence和output dependence只是名称相关，不是真数据相关。改变这些指令中使用的名称[寄存器号或者存储器位置],  就可以使这些指令不再冲突。</p><h4 id="B-data-hazards"><a href="#B-data-hazards" class="headerlink" title="B. data hazards"></a>B. data hazards</h4><ul><li>RAW</li><li>WAW: 对应于output dependence。 只有在前一指令stall时允许后一指令继续执行的流水线中，才会存在WAW冒险</li><li>WAR: 对应于antidependence。</li></ul><h2 id="4-4-分支冒险"><a href="#4-4-分支冒险" class="headerlink" title="4.4 分支冒险"></a>4.4 分支冒险</h2><h3 id="i-分支冒险是什么"><a href="#i-分支冒险是什么" class="headerlink" title="i. 分支冒险是什么"></a>i. 分支冒险是什么</h3><p>执行分支指令时，修改后的PC可能等于也可能不等于PC+4。</p><p>如果分支讲PC改到其目标地址，就是选中了分支；否则就是没有选中分支。一般等到ID末尾，完成地址计算和对比之后才会改变PC</p><p>那么还不知到分支指令跳到哪里，pipeline按顺序执行的指令可能不会被执行到。</p><h3 id="ii-解决方法"><a href="#ii-解决方法" class="headerlink" title="ii. 解决方法"></a>ii. 解决方法</h3><p>一旦在ID期间检测到分支，就对该分支之后的指令重新取值。但是这样处理的问题是，如果分支没有被选中，所以事实上已经正确提取了指令，所以IF的重复没有必要</p><p><img src="image-20191021095111.png" srcset="/img/loading.gif" alt="image-20191021095111" style="zoom:50%;" /></p><p>所以，如何降低流水线分支代价？</p><p>4种简单的编译时机制</p><h4 id="A-冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标"><a href="#A-冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标" class="headerlink" title="A. 冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标"></a>A. 冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标</h4><h4 id="B-将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。"><a href="#B-将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。" class="headerlink" title="B. 将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。"></a>B. 将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。</h4><p>这种预测未选中机制的实现方式是继续提取指令，就好像分支指令时一条正常指令一样。但是，如果分支被选中，就要将已经提取的指令转化为空操作，重新开始在目标地址提取指令。</p><p>这一机制的复杂性在于要知道处理器可能何时被指令改变，以及如何撤销这种改变</p><center><img src="image-20191014112116582.png" srcset="/img/loading.gif" alt="image-20191014112116582" style="zoom:35%;" /></center><h4 id="C-将所有分支都看作选中分支"><a href="#C-将所有分支都看作选中分支" class="headerlink" title="C. 将所有分支都看作选中分支"></a>C. 将所有分支都看作选中分支</h4><p>只要对分支指令进行了译码并且计算了目标地址，就假定该分支被选中，开始在目标位置提取和执行。</p><p>但是在我们的五级流水线中，不可能在知道分支输出结果之前知道目标地址，所以这对我们没什么用。</p><h4 id="D-延迟分支"><a href="#D-延迟分支" class="headerlink" title="D. 延迟分支"></a>D. 延迟分支</h4><blockquote><p>分支指令</p><p>依序后续指令[位于delay slots]</p><p>选中时的分支指令</p></blockquote><p>获得编译器支持，编译器让后续指令有效并且可用</p><center><img src="image-20191021095901298.png" srcset="/img/loading.gif" alt="image-20191021095901298" style="zoom: 40%;" ></center><p>延迟调度有局限性，这个局限性是因为</p><blockquote><ol><li>可以排在延迟时隙[delay slots]中的指令有限制</li><li>编译时预测一个分支是否可能被选中的能力有限。为了提高编译器填充delay slots的能力，大多数具有条件分支的处理器引入了<em>canceling</em> or <em>nullifying</em> branch . 在取消分支中，指令包含了预测分支的方向。当分支行为和预期一致时，分支延迟时隙中的指令就想普通的延迟分支一样执行。预测错误时，分支延迟时隙中的指令转为空操作。</li></ol></blockquote><p>看一下这些不同的解决方法效率有什么差别</p><center><img src="image-20191021101747938.png" srcset="/img/loading.gif" alt="image-20191021101747938" style="zoom:50%;" ></center><p>考虑flush pipeline</p><p>unconditional branch指的是像j, jal这种的，这些直到Decode才会知道分支目标，所以penalty=2</p><p>其他conditional，像beq等，需要EXE才知道是否要跳转，所以penalty=3</p><p>这样，考虑predicted untaken</p><p>unconditional 指令被预测不执行，但是一定会执行，代价是2</p><p>conditional的如果没有执行，和预测一致，代价为0。如果和预测不一致，代价为3</p><p>考虑predicted taken</p><p>如果和预测一致。那么在Branch指令的EXE阶段才能知道分支目标，所以要stall 2个时钟周期才能跳转</p><p><br></p><p>当流水线越来越深，分支的潜在代价增加，使用延迟分支是不够的。要更积极地去预测分支。静态机制[依赖编译时信息，成本低]，动态预测[依据程序特性]</p><h4 id="i-静态分支预测"><a href="#i-静态分支预测" class="headerlink" title="i. 静态分支预测"></a>i. 静态分支预测</h4><p>事先收集数据，根据数据来预测分支</p><h4 id="ii-动态分支预测"><a href="#ii-动态分支预测" class="headerlink" title="ii. 动态分支预测"></a>ii. 动态分支预测</h4><p>使用分支预测缓冲区[Branch-Prediction Buffer].</p><p>这是一个cache，分支指令地址的低位部分用来索引，所有访问都会hit。</p><p>这个存储器包含一个bit来标示这个分支最近是否被选中。这个bit可以用来为接下来的这条分支提供指导。如果预测结果和bit不一致，反转bit; 一致则不反转</p><p>但是只有1bit来标示会存在一点问题，比如分支一直被选中，但是某一次没有被选中，bit也会反转，这种反转其实没有必要，会影响效率。</p><p>所以这里提出了2位预测机制。</p><p>两位预测机制，预测必须连续错过两次才会进行修改。</p><center><img src="image-20191021103246990.png" srcset="/img/loading.gif" alt="image-20191021103246990" style="zoom:50%;" ></center><h1 id="5-如何实现流水线"><a href="#5-如何实现流水线" class="headerlink" title="5. 如何实现流水线"></a>5. 如何实现流水线</h1><p>MIPS CPU多周期实现</p><center><img src="image-20191021105802697.png" srcset="/img/loading.gif" alt="image-20191021105802697" style="zoom:45%;" ></center><h2 id="Basic-Pipeline"><a href="#Basic-Pipeline" class="headerlink" title="Basic Pipeline"></a>Basic Pipeline</h2><center><img src="image-20191021110018403.png" srcset="/img/loading.gif" alt="image-20191021110018403" style="zoom:45%;" ></center><h3 id="i-IF"><a href="#i-IF" class="headerlink" title="i. IF"></a>i. IF</h3><div class="hljs"><pre><code class="hljs cpp">IF/ID.IR = Mem[PC];<span class="hljs-comment">//取指令</span><span class="hljs-keyword">if</span>((EX/MEM.opcode == branch) &amp;&amp; EX/MEM.cond) &#123;  IF/IR.NPC = EX/MEM.ALUOutput;  PC = EX/MEM.ALUOutput;&#125; <span class="hljs-keyword">else</span> &#123;  IF/IR.NPC = PC + <span class="hljs-number">4</span>;  PC = PC + <span class="hljs-number">4</span>;&#125;</code></pre></div><h3 id="ii-ID"><a href="#ii-ID" class="headerlink" title="ii. ID"></a>ii. ID</h3><div class="hljs"><pre><code class="hljs cpp">ID/EX.A = Regs[IF/ID.IR[rs]];ID/EX.B = Regs[IF/ID.IR[rt]];ID/EX.NPC = IF/ID.NPC;ID/EX.IR = IF/ID.IR;ID/EX.Imm = sign-extend(IF/ID.IR[immediate]);</code></pre></div><h3 id="iii-EX"><a href="#iii-EX" class="headerlink" title="iii. EX"></a>iii. EX</h3><h4 id="A-ALU-EX"><a href="#A-ALU-EX" class="headerlink" title="A. ALU EX"></a>A. ALU EX</h4><div class="hljs"><pre><code class="hljs cpp">EX/MEM.IR = ID/EX.IR;执行以下之一<span class="hljs-number">1.</span> EX/MEM.ALUOutput = ID/EX.A func ID/EX.B;<span class="hljs-number">2.</span> EX/MEM.ALUOutput = ID/EX.A op ID/EX.Imm</code></pre></div><h4 id="B-Load-Store-EX"><a href="#B-Load-Store-EX" class="headerlink" title="B. Load Store EX"></a>B. Load Store EX</h4><div class="hljs"><pre><code class="hljs cpp">EX/MEM.IR to ID/EX.IR;EX/MEM.ALUOutput = ID/EX.A + ID/EX.imm;EX/MEM.B = ID/EX.B;</code></pre></div><h4 id="C-Branch-EX"><a href="#C-Branch-EX" class="headerlink" title="C. Branch EX"></a>C. Branch EX</h4><div class="hljs"><pre><code class="hljs cpp">EX/MEM.ALUOutput = ID/EX.NPC + (ID/EX.Imm &lt;&lt; <span class="hljs-number">2</span>);EX/MEM.cond = (ID/EX.A == <span class="hljs-number">0</span>);</code></pre></div><h3 id="iv-MEM"><a href="#iv-MEM" class="headerlink" title="iv. MEM"></a>iv. MEM</h3><h4 id="A-ALU-MEM"><a href="#A-ALU-MEM" class="headerlink" title="A. ALU MEM"></a>A. ALU MEM</h4><div class="hljs"><pre><code class="hljs cpp">MEM/WB.IR = EX/MEM.IR;MEM/WB.ALUOutput = EX/MEM.ALUOutput;</code></pre></div><h4 id="B-Load-Store-MEM"><a href="#B-Load-Store-MEM" class="headerlink" title="B. Load Store MEM"></a>B. Load Store MEM</h4><div class="hljs"><pre><code class="hljs cpp">MEM/WB.OR = EX/MEM.IR;<span class="hljs-number">1.</span> MEM/WB.LMD = Mem[EX/MEM.ALUOutput];<span class="hljs-number">2.</span> Mem[EX/MEM.ALUOutput] = EX/MEM.B;</code></pre></div><h3 id="v-WB"><a href="#v-WB" class="headerlink" title="v. WB"></a>v. WB</h3><h4 id="A-ALU-WB"><a href="#A-ALU-WB" class="headerlink" title="A. ALU WB"></a>A. ALU WB</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> Regs[MEM/WB.IR[rd]] = MEM/WB.ALUOutput;<span class="hljs-number">2.</span> Resg[MEM/WB.IR[rt]] = MEM/WB.ALUOutput;</code></pre></div><h4 id="B-Load-Store-WB"><a href="#B-Load-Store-WB" class="headerlink" title="B. Load Store WB"></a>B. Load Store WB</h4><div class="hljs"><pre><code class="hljs cpp">For load onlyRegs[MEM/WB.IR[rt]] = MEM/WB.LMD;</code></pre></div><h2 id="Control-the-Pipeline"><a href="#Control-the-Pipeline" class="headerlink" title="Control the Pipeline"></a>Control the Pipeline</h2><p>instruction issue:</p><blockquote><p>一条指令从ID移入EX的过程</p></blockquote><p>对于整数流水线，所有数据冒险都可以在ID进行检查。</p><p>如果存在数据冒险，这个指令将会在issue之前停顿。</p><p>同样，我们可以确定在ID期间需要哪种转发，并设定适当的控制。</p><center><img src="image-20191021115323894.png" srcset="/img/loading.gif" alt="image-20191021115323894" style="zoom:35%;" /></center><p>pipeline overhead</p><p>due to stage imbalance, pipeline register setup</p><h3 id="Deal-with-forwarding"><a href="#Deal-with-forwarding" class="headerlink" title="Deal with forwarding"></a>Deal with forwarding</h3><center><img="https://miaochenlu.github.io/picture/image-20191222210658336.png" alt="image-20191222210658336" style="zoom:50%;" /></center><h1 id="6-扩展MIPS流水线，以处理多周期操作"><a href="#6-扩展MIPS流水线，以处理多周期操作" class="headerlink" title="6. 扩展MIPS流水线，以处理多周期操作"></a>6. 扩展MIPS流水线，以处理多周期操作</h1><p>扩展mips流水线，以处理浮点运算</p><p>浮点运算的问题</p><blockquote><p>要求所有浮点运算在1个周期内完成时不现实的，甚至2个时钟周期都不太可能</p><p>如果想要在一个时钟周期内完成，就必须降低clock rate, 或者增加大量的逻辑单元。</p><p>所以</p><ul><li>为了完成操作，EX周期可能要根据需要重复多次</li><li>可能存在多个浮点功能单元，如果待发射指令会导致浮点所用功能单元的结构冒险，或者数据冒险，就会出现停顿。</li></ul></blockquote><p>4个独立的功能单元</p><ul><li>主整数单元，处理load, store, 整数ALU operation, branch</li><li>浮点与整数乘法器</li><li>浮点加法器，处理浮点加、减和转换</li><li>浮点和整型除法器</li></ul><p>假定这些功能单元的执行级没有实现流水化</p><center><img="https://miaochenlu.github.io/picture/image-20191111101801471.png" alt="image-20191111101801471" style="zoom:50%;" /></center><p>两个指标</p><ul><li><p>latency</p><p>the number of intervening cycles between an instruction that produces a result and an instruction that uses the result. 一条指令产生结果后，下一条指令等待多久才可以使用这个结果。注意，是等待。</p><blockquote><p>Essentially, pipeline <strong>latency</strong> is 1 cycle less than the depth of the execution pipeline, which is the number of stages from the <strong>EX stage</strong> to the stage that produces the result </p></blockquote></li><li><p>initiation/repeat interval</p><p>同一类型的指令执行之间必须间隔的周期数。比如，integer ALU的一条指令开始执行，下一条integer ALU指令需要在他后面一个周期才能开始执行</p></li></ul><center><img="https://miaochenlu.github.io/picture/IMG_C3E4F59B24C4-1.png" alt="IMG_C3E4F59B24C4-1" style="zoom:50%;" /></center><p><img src="IMG_C3E4F59B24C4.png" srcset="/img/loading.gif" alt="IMG_C3E4F59B24C4-1" style="zoom:50%;" /></p><p>instruction issue: 从ID到EX的阶段</p><p><center><img="image-20191111103138887.png" alt="image-20191111103138887" style="zoom:50%;" /></center></p><p><center><img="image-20191111104720076.png" alt="image-20191111104720076" style="zoom:50%;" /></center></p><table>  <tr>    <td>      <img src="image-20191111103409484.png" srcset="/img/loading.gif" alt="image-20191111103409484" style="zoom:50%;" />    </td>    <td>      <img src="image-20191111103455864.png" srcset="/img/loading.gif" alt="image-20191111103455864" style="zoom:50%;" />    </td>  </tr></table><table>  <tr>    <td>      <img src="image-20191111103637824.png" srcset="/img/loading.gif" alt="image-20191111103637824" style="zoom:50%;" />    </td>    <td>      <img src="image-20191111104058863.png" srcset="/img/loading.gif" alt="image-20191111104058863" style="zoom:50%;" />    </td>  </tr></table>]]></content>
    
    
    <categories>
      
      <category>Computer Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer network--物理层</title>
    <link href="/2019/09/17/ComputerNetwork/PhysicalLayer/"/>
    <url>/2019/09/17/ComputerNetwork/PhysicalLayer/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据通信的理论基础"><a href="#1-数据通信的理论基础" class="headerlink" title="1 数据通信的理论基础"></a>1 数据通信的理论基础</h1><h2 id="1-1傅里叶分析"><a href="#1-1傅里叶分析" class="headerlink" title="1.1傅里叶分析"></a>1.1傅里叶分析</h2><p>任何一个行为合理周期为T的函数g(t)，都可以表示成正弦函数和余弦函数组成的无穷级数</p><script type="math/tex; mode=display">g(t)=\frac{1}{2}c+\sum_{n=1}^{\infty}a_nsin(2\pi nft)+\sum_{n=1}^{\infty}b_ncos(2\pi nft)</script><p>其中$f=\frac{1}{T}$是基本频率，$a_n$和$b_n$是n次谐波的正弦振幅和余弦振幅,c是常数</p><p><br/></p><h2 id="1-2-带宽有限的信号"><a href="#1-2-带宽有限的信号" class="headerlink" title="1.2 带宽有限的信号"></a>1.2 带宽有限的信号</h2><p>我们考虑一个特殊的例子：</p><p>传输ASCII字符b,这个字符被编码成一个8比特长的字节，01100010</p><p>可以得到系数</p><center><img src="image-20190917211816031.png" srcset="/img/loading.gif" alt="image-20190917211816031" style="zoom:50%;" /></center><blockquote><p> 所有传输设施在传输过程中都要损失一些能量    </p><p> 如果所有傅里叶分量都等量衰减，则结果信号将会在振幅上有所减小，但形状不会变。  </p><p>但是，实际情况是，所有传输设施对于不同傅里叶分量的衰减程度并不相同，这会导致接收端接收到的信号发生<strong>变形</strong>。  </p><p>一般对导线来说，在[0,$f_c$]的频率范围，振幅在传输过程中不回衰减，而在$f_c$这个截止频率之上的所有频率的振幅都会有不同程度的减弱。    </p><p>这个在传输过程中振幅不回明显减弱的频率的宽度就称为<strong>带宽</strong>   </p><p>但是截止频率不是一个突变的量，不是说到达某个阈值，振幅就突然减弱了，所以通常引用的带宽是指从0到接收能量保留一半到那个频率位置</p></blockquote><p>带宽是传输介质的一种物理特性，取决于介质  </p><p>一般将从0到某个最大频率的信号称为<strong>基带信号</strong>，将被搬移并占用某个更大频率范围的信号称为<strong>通带信号</strong>  </p><center><img src="image-20190917211449784.png" srcset="/img/loading.gif" alt="image-20190917211449784" style="zoom: 67%;" /></center><p><br/></p><h4 id="带宽很低，会发生什么？"><a href="#带宽很低，会发生什么？" class="headerlink" title="带宽很低，会发生什么？"></a>带宽很低，会发生什么？</h4><p>如果带宽很低，则只有几个最低频率才能被传输</p><p>假设比特率为$b$ bit/s[每秒发送8个比特]</p><p>则发送8个比特所需要的时间是$\frac{8}{b}$秒</p><p>所以第一个谐波频率是$\frac{b}{8}$赫兹</p><p>如果截止频率是3000hz,则可以通过的最高谐波数为</p><script type="math/tex; mode=display">\frac{3000}{\frac{8}{b}}</script><center><img src="image-20190917213738345.png" srcset="/img/loading.gif" alt="image-20190917213738345" style="zoom:50%;" /></center><p>如上图所示，如果能发送的频率数很少，我们就没办法精确表示周期函数</p><p><br/></p><h2 id="1-3-信道的最大数据速率"><a href="#1-3-信道的最大数据速率" class="headerlink" title="1.3 信道的最大数据速率"></a>1.3 信道的最大数据速率</h2><p><a href="https://blog.csdn.net/supreme42/article/details/7734763" target="_blank" rel="noopener">一些概念</a></p><p>波特率[baud rate/ symbol rate]</p><blockquote><p>波特率指的是信号每秒钟电平变化的次数，单位是<em>Hz</em></p></blockquote><p>比特率</p><blockquote><p>信号每秒钟传输的数据的位数。计算机中数据都是用<em>0</em>，<em>1</em>表示的，所以比特率也就是每秒钟传输<em>0</em>和<em>1</em>的个数，单位是<em>bps</em>[<em>bit per second</em>]</p></blockquote><p>波特率和比特率的关系</p><blockquote><p>我们可以假设一个信号只有两个电平，那么这个时候可以把低电平理解为<em>“0”</em>，高电平理解为<em>“1”</em>，这样每秒钟电平变化的次数也就是传输的<em>0</em>，<em>1</em>个数了，即比特率 <em>=</em> 波特率。</p><p>但是有些信号可能不止两个电平，比如一个四电平的信号，那么每个电平就可以被理解成<em>“00”</em>，<em>“01”</em>，<em>“10”</em>，<em>“11”</em>，这样每次电平变化就能传输两位的数据了，即比特率 <em>= 2 ×</em> 波特率。</p><p>一般的，$bit\,rate = buad\,rate × log_2V$，这里V就是信号电平的个数。</p></blockquote><p>Nyquist证明：如果一个任意信号通过一个带宽为B的低通滤波器，那么只要进行每秒2B次确切采样[一个周期采样2次]，就可以完全重构出被过滤的信号</p><p>不考虑噪声，如果信号包含了V个离散等级，那么公式可以写为</p><script type="math/tex; mode=display">最大数据速率=2Blog_2V(bit/s)</script><p>[最大symbol rate=$2B\,symbol/s$]</p><blockquote><p>每秒采样2B次，也就是采样了2B个电平信号</p><p>也就是采样了2BlogV个bits</p></blockquote><p>事实上，要想重构出信号，每秒2B次采样是不够的，要多一些才够。</p><center><img src="9FC21EC72573A17040AD0FCD3C37A790.png" srcset="/img/loading.gif" alt="9FC21EC72573A17040AD0FCD3C37A790" style="zoom:10%;" /></center><p><br/></p><h4 id="接下来考虑如果存在随机噪声"><a href="#接下来考虑如果存在随机噪声" class="headerlink" title="接下来考虑如果存在随机噪声"></a>接下来考虑如果存在随机噪声</h4><script type="math/tex; mode=display">信噪比(SNR)=\frac{信号功率}{噪声功率}=\frac{S}{N}</script><p>通常将其写成对数形式$10log_{10}\frac{S}{N}$,单位为分贝. </p><p>香农得出：对于一条带宽为B赫兹，噪声比是$\frac{S}{N}$的有噪声通道，他的最大数据传输速率是. </p><script type="math/tex; mode=display">最大比特率=Blog_2{(1+\frac{S}{N})}</script><h2 id="2-引导性传输介质-有线传输"><a href="#2-引导性传输介质-有线传输" class="headerlink" title="2 引导性传输介质[有线传输]"></a>2 引导性传输介质[有线传输]</h2><p>物理层的作用是将bit从一条机器传输到另一台机器。传输所用的物理介质会在传输带宽、延迟、成本等方面产生差别。</p><p>可以将介质分为</p><ul><li>引导性介质：如铜线、光纤</li><li>非引导性介质：如卫星、激光</li></ul><p><br/></p><h3 id="2-1-磁介质"><a href="#2-1-磁介质" class="headerlink" title="2.1 磁介质"></a>2.1 磁介质</h3><p>Never underestimate the bandwidth of station wagon full of tapes hurtling down the highway.</p><h3 id="2-2-双绞线"><a href="#2-2-双绞线" class="headerlink" title="2.2 双绞线"></a>2.2 双绞线</h3><p>构成</p><blockquote><p>双绞线由两根铜线以螺旋状的形式紧紧地绞在一起。</p></blockquote><p>之所以要绞在一起，是因为这样不同电线产生的干扰波会相互抵消，显著降低电线的辐射。</p><p>并且，信号以两根电线的电压差来承载，这样对外部噪声有更好的免疫力，因为噪声对两根电线的干扰是相同的，因此电压差不会改变。</p><p><br/></p><p>双绞线既可以传输模拟信号，也可以传输数字信号。</p><p>传输方向：</p><ul><li>全双工链路[full-duplex]：可以双向同时使用的链路</li><li>半双工链路half-duplex]：可以双向使用但一次只能使用一个方向</li><li>单工链路[simplex]：只允许一个方向上传输</li></ul><p>双绞线的type:</p><blockquote><p>– Category 5 [100Mbps, 1Gbps]<br>– Category 6 [10Gbps]<br>– Category 7 [Shielded Twisted Pair]</p></blockquote><center><img src="image-20191007125121828.png" srcset="/img/loading.gif" alt="image-20191007125121828" style="zoom:33%;" /></center><p>双绞线的缺点是：</p><p>传输距离远的话，信号衰减很厉害，需要使用中继器</p><h3 id="2-3-同轴电缆-coaxial-cable"><a href="#2-3-同轴电缆-coaxial-cable" class="headerlink" title="2.3 同轴电缆[coaxial cable]"></a>2.3 同轴电缆[coaxial cable]</h3><p>构成：</p><blockquote><p>硬的铜芯，外面包上一层绝缘材料，绝缘材料的外面是网状圆柱导体，外层导体再覆盖上一层保护塑料外套</p></blockquote><center><img src="image-20191007133601513.png" srcset="/img/loading.gif" alt="image-20191007133601513" style="zoom: 33%;" /></center><p>特点：</p><blockquote><p>同轴电缆的结构和屏蔽性使得它既有很高的带宽，又有很好的抗噪性。</p><p>这点比双绞线更优秀，因此也比双绞线传的远</p></blockquote><h3 id="2-4-电力线-power-line"><a href="#2-4-电力线-power-line" class="headerlink" title="2.4 电力线[power line]"></a>2.4 电力线[power line]</h3><center><img src="image-20191007133946196.png" srcset="/img/loading.gif" alt="image-20191007133946196" style="zoom: 33%;" /></center><h3 id="2-5-Fiber-optics"><a href="#2-5-Fiber-optics" class="headerlink" title="2.5 Fiber optics"></a>2.5 Fiber optics</h3><center><img src="page40image34686176.png" srcset="/img/loading.gif" alt="page40image34686176.jpg" style="zoom:33%;" /></center><p>Types:</p><blockquote><p>Multimode多模：many different rays</p><p>Unimode单模：single rays, longer distance</p></blockquote><p>Transmission of light through fiber:</p><blockquote><p>-Attenuation [衰减] of light through fiber in the infrared region.</p><p>– Three wavelength bands are used for optical communication. They are centered at 0.85, 1.30, and 1.55 micros [微米].</p></blockquote><center><img src="page41image34714624.png" srcset="/img/loading.gif" alt="page41image34714624.jpg" style="zoom: 33%;" /></center><h4 id="光缆："><a href="#光缆：" class="headerlink" title="光缆："></a><u>光缆</u>：</h4><p>构成：</p><blockquote><p>中间core是玻璃芯，光秒冲通过它传播</p><p>玻璃芯外面是一个玻璃覆盖层[cladding]，覆盖层的折射率比玻璃低，这样可以限制所有光都限制在玻璃芯内[全反射]</p><p>最外面是一层塑料封套[jacket],用来保护里面的玻璃包层</p><p>光纤通常被扎捆成束，最外面再加一层保护套</p></blockquote><center><img src="page42image34731632.png" srcset="/img/loading.gif" alt="page42image34731632.jpg" style="zoom:35%;" /></center><p>信号源一半有两种光源：发光LED和半导体激光</p><center><img src="page44image34725184.png" srcset="/img/loading.gif" alt="page44image34725184.jpg" style="zoom:33%;" /></center><h4 id="光纤和铜线的比较"><a href="#光纤和铜线的比较" class="headerlink" title="光纤和铜线的比较"></a><u>光纤和铜线的比较</u></h4><p>– Advantages</p><ul><li>Higher bandwidths and Low attenuation.</li><li>Not being affected by power surges, electromagnetic interference, or power failures.</li><li>Not affected by corrosive chemicals in the air.</li><li>Thin and lightweight.</li><li>Fibers do not leak light and quite difficult to tap.</li></ul><p>– Disadvantages</p><ul><li><p>Less familiar technology.</p><p>要求较高的操作技能，光纤被过度弯曲容易折断</p></li><li><p>Fiber interfaces more expensive.</p></li></ul><p>– Conclusion: For new routes [longer ones], fiber win</p><h1 id="3-无线传输"><a href="#3-无线传输" class="headerlink" title="3 无线传输"></a>3 无线传输</h1><h2 id="3-1电磁频谱"><a href="#3-1电磁频谱" class="headerlink" title="3.1电磁频谱"></a>3.1电磁频谱</h2><center><img src="image-20191007140913262.png" srcset="/img/loading.gif" alt="image-20191007140913262" style="zoom:30%;" /></center><p>由香农定理我们知道一个电磁波的信号能够携带的信息量与带宽成正比，从图中可以看到光纤带宽是多么宽</p><p>Some spread its frequency over a <em>wide frequency band</em>[spread spectrum, 扩频].</p><p>– Frequency hopping spread spectrum [military, 802.11, Bluetooth]</p><p>– Direct sequence spread spectrum [3G mobile phones]</p><p>– UWB [UltraWideBand]</p><center><img src="page49image35151168.png" srcset="/img/loading.gif" alt="page49image35151168.jpg" style="zoom:33%;" /></center><h3 id="3-2-Radar"><a href="#3-2-Radar" class="headerlink" title="3.2 Radar"></a>3.2 Radar</h3><h3 id="3-3-Radio-transmission"><a href="#3-3-Radio-transmission" class="headerlink" title="3.3 Radio transmission"></a>3.3 Radio transmission</h3><p>[a] In the VLF, LF, and MF bands, radio waves follow the curvature of the earth.</p><p>[b] In the HF band, they bounce off the ionosphere [电离层].</p><center><img src="page52image35155536.png" srcset="/img/loading.gif" alt="page52image35155536.jpg" style="zoom:33%;" /></center><h3 id="3-4-Microwave-transmission"><a href="#3-4-Microwave-transmission" class="headerlink" title="3.4 Microwave transmission"></a>3.4 Microwave transmission</h3><h1 id="4-数字调制与多路复用"><a href="#4-数字调制与多路复用" class="headerlink" title="4 数字调制与多路复用"></a>4 数字调制与多路复用</h1><h4 id="什么是数字调制？"><a href="#什么是数字调制？" class="headerlink" title="什么是数字调制？"></a>什么是数字调制？</h4><blockquote><p>比特与代表他们的信号之间的转换过程称为<strong>数字调制</strong></p></blockquote><p><br/></p><p>我们首先来看如何把<strong>比特直接转换成信号</strong>的方案，这些方案导致了<strong>基带传输</strong></p><blockquote><p>基带传输是指：信号的传输占有传输介质上从0到最大值之间的全部频率</p></blockquote><p>然后我们看通过调节载波信号的幅值、相位或者频率来运载比特的模式，这些方案导致了<strong>通带传输</strong></p><blockquote><p>通带传输是指：信号占据了以载波信号频率为中心的一段频带</p></blockquote><p><br/></p><p>信道通常被多个信号共享，这种信道的共享形式称为<strong>多路复用技术</strong></p><p>多路复用技术可以通过：时分复用、频分复用、码分复用 实现</p><h2 id="4-1-基带传输"><a href="#4-1-基带传输" class="headerlink" title="4.1 基带传输"></a>4.1 基带传输</h2><center><img src="image-20200101212239647.png" srcset="/img/loading.gif" alt="image-20200101212239647" style="zoom:50%;" /></center><h3 id="NRZ"><a href="#NRZ" class="headerlink" title="NRZ"></a>NRZ</h3><p>翻转代表1，不翻转代表0</p><p>一旦NRZ信号被发出去，它沿线缆传播。另一端的接收器以一定周期对信号采样，然后把采样信号转换成比特。</p><p>Problem:</p><blockquote><p>a long run of 0s or 1s leaves the signal unchanged. </p><p>After a while it is hard to tell the bits apart, as 15 zeros look much like 16 zeros unless you have a very accurate clock.</p></blockquote><p>Accurate clock: </p><blockquote><p> For all schemes that encode bits into symbols, the receiver must know <strong>when one symbol ends and the next symbol begins</strong> to correctly decode the bits.</p></blockquote><p>一般来说，accurate clock是很难做到的，那么我们该怎么办呢？</p><h4 id="Clock-Recovery"><a href="#Clock-Recovery" class="headerlink" title="Clock Recovery"></a><u>Clock Recovery</u></h4><ul><li><p>一种方法，额外拉一根时钟线，给接收器发送单独的时钟信号</p><p>这个方法不好，因为这很浪费，用一根额外的线来发送时钟，还不如用它来发送数据呢</p></li></ul><ul><li>A clever trick is to mix the clock signal with the data signal by XORing them together so that no extra line is needed.→<strong><u>Manchester Encoding</u></strong></li></ul><p>  <strong><u>Manchester Encoding</u></strong>的方法是，时钟的频率是比特率的两倍，也就是在一个bit 时间内，时钟会产生一次跳变。时钟XOR bit，产生输出</p><p>  如上图所示</p><blockquote><p> 第一个bit时间t内，传输的bit是1，时钟在[0,t/2]内是0，与bit 1异或，编码成1; </p><p> 在[t/2, t]内时钟跳变到1，与bit 0异或，编码成0.</p><p> 因此我们在第一个bit时间看到的编码先是1后翻转到0</p></blockquote><p>  问题：需要两倍于NRZ的带宽，一个bit时间他要传输两个信号</p><ul><li>As a step in the right direction, we can simplify the situation by encoding a 1 as a transition and a 0 as no transition, or vice versa.→<strong><u>NRZI</u></strong> [Non-Return-to- Zero Inverted,不归零倒相制, Used in USB]</li></ul><p>  <strong><u>NRZI</u></strong>方法是：编码有跳变表示1，编码无跳变表示0</p><p>  这样，再长的一串1都不会产生时钟恢复问题；但是一长串的0仍然有问题</p><ul><li><p>Problem: long runs of 0s?→<strong><u>4B/5B</u></strong></p><p><strong><u>4B/5B</u></strong>的方法是：每4个bits被映射成一个5bits的模式，映射按照一张固定的转换表进行，5bits的选择使得映射结果永远不会出现连续3个0</p><center><img src="page63image36690640.png" srcset="/img/loading.gif" alt="page63image36690640.png" style="zoom:33%;" /></center><p>问题：增加了25%的带宽</p></li></ul><p><br/></p><h2 id="4-2-通带传输"><a href="#4-2-通带传输" class="headerlink" title="4.2 通带传输"></a>4.2 通带传输</h2><p>一般情况下，我们在一个信道上发送信息使用的频率范围并不是从0开始的。对于无线信道来说，发送非常低频率的信号不切实际，因为天线的大小与信号的波长成比例，低频信号需要很大的天线。</p><p>发射频率一般是由监管约束和避免干扰的需要决定的</p><h3 id="4-2-1-数字调试"><a href="#4-2-1-数字调试" class="headerlink" title="4.2.1 数字调试"></a>4.2.1 数字调试</h3><center><img src="image-20191007153614734.png" srcset="/img/loading.gif" alt="image-20191007153614734" style="zoom:50%;" /></center><h4 id="A-幅移键控-ASK-Amplitude-Shift-Keying"><a href="#A-幅移键控-ASK-Amplitude-Shift-Keying" class="headerlink" title="A 幅移键控[ASK, Amplitude Shift Keying]"></a>A 幅移键控[ASK, Amplitude Shift Keying]</h4><p>通过采用不同的振幅表示0和1</p><blockquote><p>如上图(b)所示，这里采用非零幅值和一个零幅值</p></blockquote><h4 id="B-频移键控-FSK-Frequency-Shift-Keying"><a href="#B-频移键控-FSK-Frequency-Shift-Keying" class="headerlink" title="B 频移键控[FSK, Frequency Shift Keying]"></a>B 频移键控[FSK, Frequency Shift Keying]</h4><p>采用两个或更多的频率</p><blockquote><p>如上图[c]所示，使用两个频率表示0和1</p></blockquote><h4 id="C-相移键控-PSK-Phase-Shift-Keying"><a href="#C-相移键控-PSK-Phase-Shift-Keying" class="headerlink" title="C 相移键控[PSK, Phase Shift Keying]"></a>C 相移键控[PSK, Phase Shift Keying]</h4><p>在每个符号的周期中，系统把载波波形偏移0度或者180度。由于只有两个相位，这种调制方法称为二进制相移键控[BPSK]，这里的二进制表示的是两个符号</p><blockquote><p>如上图[d]所示，使用两种相位量表示0和1</p></blockquote><p>当然，我们可以用更多数量的偏移。比如用4个偏移，45，135，225，315，那么每个符号可以表示2bit。这种称为正交相移键控[QPSK, Quadrature]</p><h4 id="D-集大成者"><a href="#D-集大成者" class="headerlink" title="D 集大成者"></a>D 集大成者</h4><p>我们可以综合以上调制方式，使得每个符号表示更多的bit.</p><p>我们选择综合振幅和相位。为什么不考虑频率呢？因为频率和相位有关</p><p><br/></p><p>我们给出星座图</p><blockquote><p> 一个点的相位是以他为起点到原点的线与x轴正方向的夹角</p><p> 一个点的振幅是他到原点的距离</p></blockquote><center><img src="image-20191007154637608.png" srcset="/img/loading.gif" alt="image-20191007154637608" style="zoom: 33%;" /></center><blockquote><p>如图[b], QAM-16：</p><p>一共有16个符号，16个符号可以表示出4bits的所有组合</p><p>因此一个符号可以传输4个比特</p><p>同样，如图[c], QAM-64</p><p>一共有64个符号，一个符号可以传输6bits [..$2^6=64$]</p></blockquote><h2 id="4-3-Multiplexing"><a href="#4-3-Multiplexing" class="headerlink" title="4.3 Multiplexing"></a>4.3 Multiplexing</h2><h3 id="4-3-1-频分复用-FDM-Frequency-Division-Multiplexing"><a href="#4-3-1-频分复用-FDM-Frequency-Division-Multiplexing" class="headerlink" title="4.3.1 频分复用[FDM,Frequency Division Multiplexing]"></a>4.3.1 频分复用[FDM,Frequency Division Multiplexing]</h3><p>利用通带传输的优势使多个用户共享一个信道。</p><p>FDM将频谱分成几个频段，每个用户完全拥有其中一个频段来发送自己的信号</p><center><img src="image-20191005234836200.png" srcset="/img/loading.gif" alt="image-20191005234836200" style="zoom: 40%;" /></center><h4 id="正交频分复用-OFDM-orthogonal"><a href="#正交频分复用-OFDM-orthogonal" class="headerlink" title="正交频分复用[OFDM,orthogonal]"></a>正交频分复用[OFDM,orthogonal]</h4><p>信道带宽被分成许多独立发送数据的子载波，每个子载波之间频率的间隔是$\Delta f$</p><p>每个子载波发出的信号虽然可以扩散到相邻子载波，但是每个子载波的频率响应被设计成在相邻子载波的中心为0。因此，可以在子载波中心频率采样而不会收到其邻居的干扰</p><center><img src="image-20191007160446233.png" srcset="/img/loading.gif" alt="image-20191007160446233" style="zoom:40%;" /></center><h3 id="4-3-2-时分复用"><a href="#4-3-2-时分复用" class="headerlink" title="4.3.2 时分复用"></a>4.3.2 时分复用</h3><p>用户以循环的方式轮流工作。每个用户周期性获得整个带宽非常短的一个时间</p><center><img src="image-20191005234914576.png" srcset="/img/loading.gif" alt="image-20191005234914576" style="zoom:40%;" /></center><h3 id="4-3-3-码分复用"><a href="#4-3-3-码分复用" class="headerlink" title="4.3.3 码分复用"></a>4.3.3 码分复用</h3><p>传输一个bit的时间被划分成m个更短的时间间隔，称这个时间间隔为<u>码片</u>[chip]。每个站分配得到唯一的m位码，称为 <u>码片序列</u></p><p>如果要发送bit 1,站就发送分配给他的码片序列；如果要发送bit 0,站就发送分配给他的码片序列的反码。</p><blockquote><p>m=8,即一个bit时间传输的码片序列是8位的。</p><p>如果A站分配到的码片序列为[-1-1-1+1+1-1+1+1]</p><p>那么如果A想发送bit 1，就发送码片序列[-1-1-1+1+1-1+1+1]</p><p>如果A想发送 bit 0, 就发送码片序列[+1+1+1-1-1+1-1-1]</p></blockquote><p>码片序列的要求：</p><blockquote><p> 所有的码片序列都要两两正交</p></blockquote><center><img src="image-20191006000007082.png" srcset="/img/loading.gif" alt="image-20191006000007082" style="zoom:35%;" /></center><p>A,B,C,D 是发送信号的4个station，他们的码片序列两两正交。</p><p>S1,S2,…S6是6个例子,S6表示这个比特时间A,B,D发送了bit 1，C发送了bit 0。但是我们收到的是S6这个不同站的信号都混淆在一起的整体。怎么把C站发送的比特提取出来呢？</p><p>方法是S6与C做归一化内积。即$S_6\cdot C=[2-2+0-2+0-2-4+0]/8=-1$</p><p>因此我们知道在S6所处的这个比特时间内，C站传输了bit 0。</p><blockquote><p>内积结果</p><p>=1 说明该站发送了 bit 1</p><p>=-1说明该站发送了bit 0</p><p>=0 说明该站没有发送数据</p></blockquote><h1 id="5-公共电话交换网络"><a href="#5-公共电话交换网络" class="headerlink" title="5 公共电话交换网络"></a>5 公共电话交换网络</h1><p>How to connect computers?</p><blockquote><p>For small number of computers and a local area</p><ul><li>LAN </li></ul><p>For a large number of computers or a wide area or lacking right of way</p><ul><li>PSTN [Public Switched Telephone Network]</li></ul></blockquote><h2 id="5-1-Structure-of-the-Telephone-System"><a href="#5-1-Structure-of-the-Telephone-System" class="headerlink" title="5.1 Structure of the Telephone System"></a>5.1 Structure of the Telephone System</h2><p>电话网络的变迁</p><center><img src="image-20191007161859322.png" srcset="/img/loading.gif" alt="image-20191007161859322" style="zoom:40%;" /></center><p>Bell system model</p><p>Levels:</p><ul><li>End office 本地局</li><li>toll office 长途局</li><li>primary office 初级局</li><li>Sectional office 地区局</li><li>Regional office 区域局</li></ul><p>Major components </p><ul><li><p>Local loops [本地回路]: 进入家庭和公司的模拟双绞线</p></li><li><p>Trunks [干线]: 连接交换局的数字光纤</p></li><li><p>Switching offices [交换局]:电话呼叫在这里从一条中继线被接入另一条中继线</p></li></ul><center><img src="image-2019100742053.png" srcset="/img/loading.gif" alt="屏幕快照 2019-10-07 下午4.20.53" style="zoom:50%;" /></center><h2 id="5-1-本地回路：调制解调器、ADSL、光纤"><a href="#5-1-本地回路：调制解调器、ADSL、光纤" class="headerlink" title="5.1 本地回路：调制解调器、ADSL、光纤"></a>5.1 本地回路：调制解调器、ADSL、光纤</h2><h3 id="A-电话调制解调器"><a href="#A-电话调制解调器" class="headerlink" title="A 电话调制解调器"></a>A 电话调制解调器</h3><p>要在物理信道上发送比特，必须把比特转换为可以在信道上传输的模拟信号。这个方式我们在上一节已经学过。</p><p>在信号的另一端，模拟信号要被还原成比特</p><p><br/></p><p><strong><u>调制解调器</u></strong></p><p>是什么</p><blockquote><p>执行数字比特流和模拟信号流之间转换的设备就是调制解调器[modem]</p><p>调制解调器是调制器[modulator]和解调器[demodulator]的缩写</p></blockquote><center><img src="page102image35767104.png" srcset="/img/loading.gif" alt="page102image35767104.png" style="zoom:70%;" /> </center>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CA - Instruction Set</title>
    <link href="/2019/09/08/ComputerArchitecture/instructionSet/"/>
    <url>/2019/09/08/ComputerArchitecture/instructionSet/</url>
    
    <content type="html"><![CDATA[<h1 id="附录A-指令集基本原理"><a href="#附录A-指令集基本原理" class="headerlink" title="附录A 指令集基本原理 "></a><a name="ISA">附录A 指令集基本原理 </a></h1><h1 id="1-What-is-ISA"><a href="#1-What-is-ISA" class="headerlink" title="1 What is ISA?"></a>1 What is ISA?</h1><p>ISA: Instruction Set Architecture</p><p><img src="image-20190930101228492.png" srcset="/img/loading.gif" alt="image-20190930101228492" style="zoom:50%;" /></p><h1 id="2-What-types-of-ISA"><a href="#2-What-types-of-ISA" class="headerlink" title="2 What types of ISA?"></a>2 What types of ISA?</h1><h3 id="2-1-Basis"><a href="#2-1-Basis" class="headerlink" title="2.1 Basis"></a>2.1 Basis</h3><ul><li>type of internal storage</li></ul><blockquote><p>stack</p><p>accumulator</p><p>Register-memory</p><p>Register-register/load-store</p></blockquote><p><br/></p><p>先来解释一下implicit operand和explicit operand</p><ul><li>explicit operand</li></ul><p>明确到哪个地方去取的操作数，比如到某一个由指令确定的<strong><em>寄存器</em></strong>，或者内存中一个由指令确定的<strong><em>存储器地址</em></strong></p><ul><li>implicit operand</li></ul><p>不明确的取值位置，但是系统默认了。比如stack architecture就是默认到stack头部去取，accumulator architecture就是默认到accumulator中去取。</p><p><br/></p><p><img src="image-20191218224444341.png" srcset="/img/loading.gif" alt="image-20191218224444341" style="zoom:50%;" /></p><p>C=A+B的代码示例</p><p><img src="image-20191218224500000.png" srcset="/img/loading.gif" alt="image-20191218224500000" style="zoom:50%;" /></p><p>example problem</p><p><img src="image-20191218224924929.png" srcset="/img/loading.gif" alt="image-20191218224924929" style="zoom:50%;" /></p><h4 id="2-1-1-Stack-Architecture"><a href="#2-1-1-Stack-Architecture" class="headerlink" title="2.1.1 Stack Architecture"></a>2.1.1 Stack Architecture</h4><p><strong><em><u>operand</u></em></strong>:</p><blockquote><p> 2 <strong><em><u>implicit</u></em></strong> operands on the top of the stack(<strong><em>TOS</em></strong>)</p></blockquote><p>用图来看一下以下操作的过程</p><div class="hljs"><pre><code class="hljs armasm">C = A + <span class="hljs-keyword">B </span>(memory locations)<span class="hljs-keyword">Push </span>A<span class="hljs-keyword">Push </span><span class="hljs-keyword">B</span><span class="hljs-keyword">Add </span><span class="hljs-keyword">Pop </span>C</code></pre></div> <table>   <tr>     <td>       <img src="image-20190930102555608.png" srcset="/img/loading.gif" alt="image-20190930102555608" title="original"/>     </td>     <td>  <img src="image-20190930102855084.png" srcset="/img/loading.gif" alt="image-20190930102855084" title="push A"/>     </td>     <td>  <img src="image-20190930103000391.png" srcset="/img/loading.gif" alt="image-20190930103000391" title="push B"  />     </td>     <td>  <img src="image-20190930103037853.png" srcset="/img/loading.gif" alt="image-20190930103037853" title="Add"  />     </td>     <td>  <img src="image-20190930103101742.png" srcset="/img/loading.gif" alt="image-20190930103101742" title="pop C" />     </td>   </tr> </table><h4 id="2-1-2-Accumulator-Architecture"><a href="#2-1-2-Accumulator-Architecture" class="headerlink" title="2.1.2 Accumulator Architecture"></a>2.1.2 Accumulator Architecture</h4><p><strong><em><u>operand</u></em></strong></p><blockquote><p>one implicit operand: accumulator</p><p>one explicit operand: mem location</p></blockquote><p>看一下以下操作的过程</p><div class="hljs"><pre><code class="hljs fortran">C = A + BLoad AAdd BStore Caccumulator is both an <span class="hljs-keyword">implicit</span> input operand and a result</code></pre></div><table>  <tr>    <td>      <img src="image-20190930115553486.png" srcset="/img/loading.gif" alt="image-20190930115553486" title="original"/>    </td>    <td>  <img src="image-20190930115635931.png" srcset="/img/loading.gif" alt="image-20190930115635931" title="load A"/>    </td>      <td>  <img src="image-20190930115734010.png" srcset="/img/loading.gif" alt="image-20190930115734010" title="add B"/>    </td>    <td>  <img src="image-20190930115804883.png" srcset="/img/loading.gif" alt="image-20190930115804883" title="store C"/>    </td>  </tr></table><h1 id="3-存储器寻址"><a href="#3-存储器寻址" class="headerlink" title="3. 存储器寻址"></a>3. 存储器寻址</h1><h2 id="3-1-解释存储器地址"><a href="#3-1-解释存储器地址" class="headerlink" title="3.1 解释存储器地址"></a>3.1 解释存储器地址</h2><p>i. 关于如何对一个较大对象中的字节排序：</p><ul><li>Little Endian : store least significant byte in the smallest address</li></ul><p><img src="image-20191014101250484.png" srcset="/img/loading.gif" alt="image-20191014101250484" style="zoom:40%;" /></p><ul><li>Big Endian : store most significant byte in the smallest address</li></ul><p><img src="image-20191014101429477.png" srcset="/img/loading.gif" alt="image-20191014101429477" style="zoom:40%;" /></p><p>ii. 字节对齐</p><p>大小为s bytes的对象，字节地址为A, 如果$A\; mod\;s = 0$ , 那么是字节对齐的</p><p><img src="image-20191014101703881.png" srcset="/img/loading.gif" alt="image-20191014101703881" style="zoom:40%;" /></p><p>为什么要对齐</p><blockquote><p>When well aligned, requires only one memory access to read one object;</p><p>If address is not well aligned, each misaligned object requires two memory accesses to fetch.</p></blockquote><h2 id="3-2-Addressing-modes"><a href="#3-2-Addressing-modes" class="headerlink" title="3.2  Addressing modes"></a>3.2  Addressing modes</h2><p><img src="image-20191014102744097-6809392.png" srcset="/img/loading.gif" alt="image-20191014102744097-6809392" style="zoom:50%;" /></p><p>References:  </p><p>[1]计算机体系结构 量化研究方法</p>]]></content>
    
    
    <categories>
      
      <category>Computer Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
