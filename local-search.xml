<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Template Method</title>
    <link href="/2020/08/05/DesignPatterns/TemplateMethod/"/>
    <url>/2020/08/05/DesignPatterns/TemplateMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因 （比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p><p>核心在于在稳定与变化之间求得一个平衡，如果全部稳定或者全部变化都是不需要设计模式的。</p><p>如何在确定<strong>稳定操作结构</strong>的前提下，来灵活应对<strong>各个子步骤的变化</strong>或者<strong>晚期实现需求</strong>？</p><p>假设整个代码的操作结构如下图所示，其中红色是Library开发人员完成的，蓝色部分是Application开发人员完成的</p><img src="image-20200710191024075.png" srcset="/img/loading.gif" alt="image-20200710191024075" style="zoom:33%;" /><h2 id="结构化软件流程设计"><a href="#结构化软件流程设计" class="headerlink" title="结构化软件流程设计"></a>结构化软件流程设计</h2><img src="image-20200710191212499.png" srcset="/img/loading.gif" alt="image-20200710191212499" style="zoom:50%;" /><p>lib.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>app.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//应用程序开发人员</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>主程序</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Library <span class="hljs-title">lib</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Application <span class="hljs-title">app</span><span class="hljs-params">()</span></span>;        lib.Step1();        <span class="hljs-keyword">if</span>(app.Step2()) &#123;        lib.Step3();    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;        app.Step4();    &#125;    lib.Step5();&#125;</code></pre></div><h2 id="用模板方法的代码重构为"><a href="#用模板方法的代码重构为" class="headerlink" title="用模板方法的代码重构为"></a>用模板方法的代码重构为</h2><img src="image-20200710191917988.png" srcset="/img/loading.gif" alt="image-20200710191917988" style="zoom:50%;" /><p>lib.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span> </span>&#123;        Step1();        <span class="hljs-keyword">if</span>(Step2()) &#123;            Step3();        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            Step4();        &#125;        Step5();    &#125;        <span class="hljs-keyword">virtual</span> ~Library() &#123;&#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>&#125;</code></pre></div><p>app.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//应用程序开发人员</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span>:</span> <span class="hljs-keyword">public</span> Library &#123;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;;</code></pre></div><p>主程序</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Library* pLib = <span class="hljs-keyword">new</span> Application();    lib.Run();    <span class="hljs-keyword">delete</span> pLib;&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两者的区别在于早绑定和晚绑定。前者属于早绑定，而template method属于晚绑定</p><img src="image-20200710192039991.png" srcset="/img/loading.gif" alt="image-20200710192039991" style="zoom:50%;" /><p>定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟 (变化)到子类中。Template Method使得子类可以不改变 (复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Strategy Method</title>
    <link href="/2020/08/05/DesignPatterns/StrategyMethod/"/>
    <url>/2020/08/05/DesignPatterns/StrategyMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂； 而且有时候支持不使用的算法也是一个性能负担</p><p>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</p><h2 id="Strategy-Method定义"><a href="#Strategy-Method定义" class="headerlink" title="Strategy Method定义"></a>Strategy Method定义</h2><p>定义一系列算法，把它们一个个封装起来，并且使它们可互 相替换（变化）。该模式使得算法可独立于使用它的客户程 序(稳定)而变化（扩展，子类化）。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>考虑一下计算税的例子</p><ul><li>第一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> TaxBase &#123;    CN_Tax,    US_Tax,    DE_Tax&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span>    TaxBase tax;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>                <span class="hljs-keyword">if</span>(tax == CN_Tax) &#123;            <span class="hljs-comment">//CN*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == US_Tax) &#123;            <span class="hljs-comment">//US*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == DE_Tax) &#123;            <span class="hljs-comment">//DE*****</span>        &#125;        <span class="hljs-comment">//***</span>    &#125;&#125;</code></pre></div><p>有些时候，静态地去观察是看不出来的，加入时间轴，考虑到未来的动态变化，问题就会暴露出来。考虑上述例子，如果要加入一个国家，比如法国，那么我们不仅要在<code>TaxBase</code>中中增加一个<code>FR_Tax</code>, 还需要在<code>SalesOrder</code>中增加判断语句。这样的更改违背了开闭原则： 对扩展开放，对修改封闭 (避免去修改源代码</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> TaxBase &#123;    CN_Tax,    US_Tax,    DE_Tax,    <span class="hljs-comment">/***加入France***/</span>    FR_Tax,&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span>    TaxBase tax;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>                <span class="hljs-keyword">if</span>(tax == CN_Tax) &#123;            <span class="hljs-comment">//CN*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == US_Tax) &#123;            <span class="hljs-comment">//US*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == DE_Tax) &#123;            <span class="hljs-comment">//DE*****</span>        &#125;        <span class="hljs-comment">/***加入France***/</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == FR_Tax) &#123;                  &#125;        <span class="hljs-comment">//***</span>    &#125;&#125;</code></pre></div><ul><li>考虑另一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxStrategy</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~TaxStrategy() &#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DETax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span><span class="hljs-keyword">private</span>:    TaxStrategy* strategy;<span class="hljs-keyword">public</span>:    SalesOrder(StrategyFactory* strategyFactory) &#123;        <span class="hljs-keyword">this</span>-&gt;strategy = strategyFactory-&gt;NewStrategy();    &#125;        ~SalesOrder() &#123;        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>        <span class="hljs-function">Context <span class="hljs-title">context</span><span class="hljs-params">()</span></span>;                <span class="hljs-keyword">double</span> val =             srtategy-&gt;Calculate(context);<span class="hljs-comment">//多态调用</span>    &#125;&#125;</code></pre></div><p>如果要增加法国，只需增加一个<code>FRTax</code>类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> doubel <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>这是一种扩展的做法，在这里只需要增加一个FRTax类，不需要更改SalesOrder。</p><p>复用性一般是指二进制层面下的复用性，如果使用第一种方法，那么整个系统需要重新编译，重新测试。虽然修改后保留了一部分原来的代码，但是这个并不是复用。而策略方法不需要重新编译之前编译好的文件，只需要重新编译FRTax这个文件</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200805135526277.png" srcset="/img/loading.gif" alt="image-20200805135526277"> </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使 得类型在运行时方便地根据需要在各个算法之间进行切换。</p></li><li><p>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件 判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需 要Strategy模式。</p></li><li><p>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
