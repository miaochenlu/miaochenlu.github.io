<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Decorator</title>
    <link href="/2020/08/07/DesignPatterns/Decorator/"/>
    <url>/2020/08/07/DesignPatterns/Decorator/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在某些情况下我们可能会”过度地使用继承来扩展对象的功能”， 由于继承为类型引入的<strong>静态特质</strong>，使得这种扩展方式缺乏灵活性； 并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</p><p>如何使”对象功能的扩展”能够根据需要来动态地实现？同时避免”扩展功能的增多”带来的子类膨胀问题？从而使得任何”功能扩展变化”所导致的影响将为最低？</p><p>所谓静态特质, 比如在CryptoNetworkStream的Read函数中定死了调用NetworkStream::Read(), 而我们重构后的CryptoStream中的Read函数调用stream-&gt;Read(), 支持多态，可以产生变化。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面给出一个Stream代码示例，其继承关系如下所示</p><img src="image-20200807143722316.png" srcset="/img/loading.gif" alt="image-20200807143722316" style="zoom:30%;" /><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//业务操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stream</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Stream() &#123;&#125;&#125;;<span class="hljs-comment">//主体类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读文件流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位文件流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写文件流</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读网络流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位网络流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写网络流</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读内存流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位内存流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写内存流</span>    &#125;&#125;;<span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoNetworkStream</span>:</span> <span class="hljs-keyword">public</span> NetworkStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoMemoryStream</span>:</span> <span class="hljs-keyword">public</span> MemoryStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedNetworkStream</span>:</span> <span class="hljs-keyword">public</span> NetworkStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedMemoryStream</span>:</span> <span class="hljs-keyword">public</span> MemoryStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoBufferedFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Read(number);<span class="hljs-comment">//读文件流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Seek(position);<span class="hljs-comment">//定位文件流</span>        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Write(position);<span class="hljs-comment">//写文件流</span>        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//编译时装配</span>    CryptoFileStream* fs1 = <span class="hljs-keyword">new</span> CryptoFileStream();        BufferedFileStream* fs2 = <span class="hljs-keyword">new</span> BufferedFileStream();        CryptoBufferedFileStream* fs3 = <span class="hljs-keyword">new</span> CryptoBufferedFileStream();&#125;</code></pre></div><p>这样设计的代码存在大量的冗余，比如对于不同的stream, 无论是FileStream还是NetworkStream还是MemoryStream, 他们的加密操作都是一样的。</p><ul><li>重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoFileStream</span> &#123;</span>    FileStream* stream;<span class="hljs-comment">//=new FileStream()</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoNetworkStream</span> &#123;</span>    NetworkStream* stream;<span class="hljs-comment">//=new NetworkStream();</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoMemoryStream</span> &#123;</span>    MemoryStream* stream;<span class="hljs-comment">//=new MemoryStream();</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;</code></pre></div><ul><li>继续重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;    Stream* stream;<span class="hljs-comment">//...</span><span class="hljs-keyword">public</span>:    CryptoStream(Stream* stm): stream(stm) &#123;            &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;    Stream* stream; <span class="hljs-comment">//...</span>    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//运行时装配</span>    FileStream* s1 = <span class="hljs-keyword">new</span> FileStream();    CryptoStream* s2 = <span class="hljs-keyword">new</span> CryptoStream(s1);    BufferedStream* s3 = <span class="hljs-keyword">new</span> BufferedStream(s1);    BufferedStream* s4 = <span class="hljs-keyword">new</span> BufferedStream(s2);&#125;</code></pre></div><p>很神奇，CryptoStream既有Stream基类，也有Stream字段。这里还需要继承Stream是因为他定义了基类的接口规范</p><ul><li>继续重构</li></ul><p>CryptoStream, BufferedStream都有Stream这个字段，把他们提到一个中间类中，</p><p>设置一个DecoratorStream中间类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoratorStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">protected</span>:    Stream* stream; <span class="hljs-comment">//...</span>    DecoratorStream(Stream* stm): DecoratorStream(stm) &#123;            &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> DecoratorStream &#123;<span class="hljs-keyword">public</span>:    CryptoStream(Stream* stm): DecoratorStream(stm) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span>:</span> <span class="hljs-keyword">public</span> DecoratorStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//运行时装配</span>    FileStream* s1 = <span class="hljs-keyword">new</span> FileStream();    CryptoStream* s2 = <span class="hljs-keyword">new</span> CryptoStream(s1);    BufferedStream* s3 = <span class="hljs-keyword">new</span> BufferedStream(s1);    BufferedStream* s4 = <span class="hljs-keyword">new</span> BufferedStream(s2);&#125;</code></pre></div><p>新的类关系</p><img src="image-20200807143823919.png" srcset="/img/loading.gif" alt="image-20200807143823919" style="zoom:30%;" /><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><img src="image-20200807160507597.png" srcset="/img/loading.gif" alt="image-20200807160507597" style="zoom:50%;" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免 了使用继承带来的”灵活性差”和”多子类衍生问题”。</p></li><li><p>Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又 表现为has-a Component的组合关系，即Decorator类又使用了 另外一个Component类。</p></li><li><p>Decorator模式的目的并非解决”多子类衍生的多继承”问题，Decorator模式应用的要点在于解决”主体类在多个方向上的扩展 功能”——是为”装饰”的含义。</p></li></ul><h2 id="Decorator属于单一职责模式"><a href="#Decorator属于单一职责模式" class="headerlink" title="Decorator属于单一职责模式"></a>Decorator属于单一职责模式</h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码， 这时候的关键是划清责任。</p><ul><li><p>典型模式</p><p>• Decorator</p><p>• Bridge</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="/2020/08/06/DesignPatterns/Principle/"/>
    <url>/2020/08/06/DesignPatterns/Principle/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>变化是复用的天敌！ 面向对象设计最大的优势在于：<u><strong><em>抵御变化</em></strong></u></p>          </div><h4 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 (DIP)"></a>依赖倒置原则 (DIP)</h4><ul><li><p>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。</p></li><li><p>抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。</p></li></ul><br><h4 id="开放封闭原则-OCP"><a href="#开放封闭原则-OCP" class="headerlink" title="开放封闭原则 (OCP)"></a>开放封闭原则 (OCP)</h4><ul><li><p>对扩展开放，对更改封闭。</p></li><li><p>类模块应该是可扩展的，但是不可修改。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Observer 观察者模式</title>
    <link href="/2020/08/06/DesignPatterns/Observer/"/>
    <url>/2020/08/06/DesignPatterns/Observer/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，我们需要为某些对象建立一种”通知依赖关系” </p><p><u>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密， 将使软件不能很好地抵御变化</u>。</p><p>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>定义对象间的一种<u><strong><em>一对多</em></strong></u>（变化）的依赖关系，以便当一个 对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并<u><strong><em>自动更新</em></strong></u>。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>考虑一个文件分割器程序，将一个大文件分割成几个小文件。</p><p>我们有一个主界面MainForm (在这里是一个观察者), 里面有两个对象，一个是文件路径，一个是分割成的文件都个数。当button click时就会调用filesplitter将文件分割</p><p>代码如下</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;<span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber):    m_filePath(filePath),    m_fileNumber(fileNumber) &#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>        &#125;    &#125;&#125;</code></pre></div><h4 id="需求1：文件分割进度条"><a href="#需求1：文件分割进度条" class="headerlink" title="需求1：文件分割进度条"></a>需求1：文件分割进度条</h4><ul><li>第一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;<span class="hljs-comment">/***增加progress bar***/</span>    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;<span class="hljs-comment">/***增加progres bar***/</span>    ProgressBar* m_progressBar;<span class="hljs-keyword">public</span>:<span class="hljs-comment">/***增加初始化参数***/</span>    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, ProgressBar* progressBar):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_progressBar(progressBar)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span><span class="hljs-comment">/***更新progress bar***/</span>            <span class="hljs-keyword">if</span>(m_progressBar != <span class="hljs-literal">NULL</span>) &#123;                m_progressBar-&gt;setValue((i + <span class="hljs-number">1</span>) / m_fileNumber);            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="note note-warning">            <p>但是这种实现方式违反了<u>依赖倒置原则</u>。FileSplitter依赖ProgressBar 这样一种具体的实现细节，但是进度条的种类和展现形式是变化的，如果我们想将进度条换一种展现形式，比如不断打点，那么就会面临需求变更的困扰。</p>          </div><ul><li>第二种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    <span class="hljs-comment">//ProgressBar* m_progressBar; 这是一个通知控件</span>    IProgress* m_iprogress; <span class="hljs-comment">//抽象通知机制</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, IProgress* iprogress):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_iprogress(iprogress)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">if</span>(m_iprogress != <span class="hljs-literal">NULL</span>) &#123;                <span class="hljs-keyword">float</span> progressValue = m_fileNumber;                progressValue = (i + <span class="hljs-number">1</span>) / progressValue;                m_iprogress-&gt;DoProgress(progressValue); <span class="hljs-comment">//更新进度条</span>            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress&#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressbar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        progressBar-&gt;setValue(value);    &#125;&#125;</code></pre></div><p>C++支持多继承，但是不推荐使用多继承，因为会带来很多耦合的问题。但是有一种情况是推荐使用多继承的，一个主的继承类，其他都是接口  (单继承多实现), 这里就属于这种情况</p><ul><li>再修改一下</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    <span class="hljs-comment">//ProgressBar* m_progressBar; 这是一个通知控件</span>    IProgress* m_iprogress; <span class="hljs-comment">//抽象通知机制</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, IProgress* iprogress):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_iprogress(iprogress)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">float</span> progressValue = m_fileNumber;            progressValue = (i + <span class="hljs-number">1</span>) / progressValue;            onProgress(progressValue);        &#125;    &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span>(m_iprogress != <span class="hljs-literal">NULL</span>) &#123;        m_iprogress-&gt;DoProgress(value);<span class="hljs-comment">//更新进度条</span>        &#125;    &#125;&#125;</code></pre></div><h4 id="需求2-多观察者"><a href="#需求2-多观察者" class="headerlink" title="需求2: 多观察者"></a>需求2: 多观察者</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    List&lt;IProgress*&gt; m_iprogressList; <span class="hljs-comment">//抽象通知机制, 支持多个观察者</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber):    m_filePath(filePath),    m_fileNumber(fileNumber) &#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIProgress</span><span class="hljs-params">(IProgress* iprogress)</span> </span>&#123;        m_iprogressList.add(iprogress);    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeIProgress</span><span class="hljs-params">(IProgress* iprogress)</span> </span>&#123;        m_iprogressList.remove(iprogress);    &#125;            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">float</span> progressValue = m_fileNumber;            progressValue = (i + <span class="hljs-number">1</span>) / progressValue;            onProgress(progressValue);        &#125;    &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        List&lt;IProgress*&gt;::iterator it = m_iprogressList.begin();        <span class="hljs-keyword">while</span>(it != m_iprogressList.end()) &#123;            (*it)-&gt;DoProgress(value);            it++;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress&#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressbar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                ConsoleNotifier cn;        <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;                splitter.addIprogress(<span class="hljs-keyword">this</span>);        splitter.addIprogress(&amp;cn);                splitter.split();    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        progressBar-&gt;setValue(value);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleNotifier</span>:</span> <span class="hljs-keyword">public</span> IProgress &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"."</span>;    &#125;&#125;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><img src="image-20200806160700160.png" srcset="/img/loading.gif" alt="image-20200806160700160" style="zoom: 50%;" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。 </p></li><li><p>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。</p></li><li><p>观察者自己决定是否需要订阅通知，目标对象对此一无所知。 </p></li><li><p>Observer模式是基于事件的UI框架中非常常用的设计模式，也是 MVC模式的一个重要组成部分。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Template Method</title>
    <link href="/2020/08/05/DesignPatterns/TemplateMethod/"/>
    <url>/2020/08/05/DesignPatterns/TemplateMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因 （比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p><p>核心在于在稳定与变化之间求得一个平衡，如果全部稳定或者全部变化都是不需要设计模式的。</p><p>如何在确定<strong>稳定操作结构</strong>的前提下，来灵活应对<strong>各个子步骤的变化</strong>或者<strong>晚期实现需求</strong>？</p><p>假设整个代码的操作结构如下图所示，其中红色是Library开发人员完成的，蓝色部分是Application开发人员完成的</p><img src="image-20200710191024075.png" srcset="/img/loading.gif" alt="image-20200710191024075" style="zoom:33%;" /><h2 id="结构化软件流程设计"><a href="#结构化软件流程设计" class="headerlink" title="结构化软件流程设计"></a>结构化软件流程设计</h2><img src="image-20200710191212499.png" srcset="/img/loading.gif" alt="image-20200710191212499" style="zoom:50%;" /><p>lib.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>app.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//应用程序开发人员</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>主程序</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Library <span class="hljs-title">lib</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Application <span class="hljs-title">app</span><span class="hljs-params">()</span></span>;        lib.Step1();        <span class="hljs-keyword">if</span>(app.Step2()) &#123;        lib.Step3();    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;        app.Step4();    &#125;    lib.Step5();&#125;</code></pre></div><h2 id="用模板方法的代码重构为"><a href="#用模板方法的代码重构为" class="headerlink" title="用模板方法的代码重构为"></a>用模板方法的代码重构为</h2><img src="image-20200710191917988.png" srcset="/img/loading.gif" alt="image-20200710191917988" style="zoom:50%;" /><p>lib.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span> </span>&#123;        Step1();        <span class="hljs-keyword">if</span>(Step2()) &#123;            Step3();        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            Step4();        &#125;        Step5();    &#125;        <span class="hljs-keyword">virtual</span> ~Library() &#123;&#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>&#125;</code></pre></div><p>app.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//应用程序开发人员</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span>:</span> <span class="hljs-keyword">public</span> Library &#123;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;;</code></pre></div><p>主程序</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Library* pLib = <span class="hljs-keyword">new</span> Application();    lib.Run();    <span class="hljs-keyword">delete</span> pLib;&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两者的区别在于早绑定和晚绑定。前者属于早绑定，而template method属于晚绑定</p><img src="image-20200710192039991.png" srcset="/img/loading.gif" alt="image-20200710192039991" style="zoom:50%;" /><p>定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟 (变化)到子类中。Template Method使得子类可以不改变 (复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。</p>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Strategy Method</title>
    <link href="/2020/08/05/DesignPatterns/StrategyMethod/"/>
    <url>/2020/08/05/DesignPatterns/StrategyMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂； 而且有时候支持不使用的算法也是一个性能负担</p><p>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</p><h2 id="Strategy-Method定义"><a href="#Strategy-Method定义" class="headerlink" title="Strategy Method定义"></a>Strategy Method定义</h2><p>定义一系列算法，把它们一个个封装起来，并且使它们可互 相替换（变化）。该模式使得算法可独立于使用它的客户程 序(稳定)而变化（扩展，子类化）。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>考虑一下计算税的例子</p><ul><li>第一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> TaxBase &#123;    CN_Tax,    US_Tax,    DE_Tax&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span>    TaxBase tax;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>                <span class="hljs-keyword">if</span>(tax == CN_Tax) &#123;            <span class="hljs-comment">//CN*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == US_Tax) &#123;            <span class="hljs-comment">//US*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == DE_Tax) &#123;            <span class="hljs-comment">//DE*****</span>        &#125;        <span class="hljs-comment">//***</span>    &#125;&#125;</code></pre></div><p>有些时候，静态地去观察是看不出来的，加入时间轴，考虑到未来的动态变化，问题就会暴露出来。考虑上述例子，如果要加入一个国家，比如法国，那么我们不仅要在<code>TaxBase</code>中中增加一个<code>FR_Tax</code>, 还需要在<code>SalesOrder</code>中增加判断语句。这样的更改违背了开闭原则： 对扩展开放，对修改封闭 (避免去修改源代码</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> TaxBase &#123;    CN_Tax,    US_Tax,    DE_Tax,    <span class="hljs-comment">/***加入France***/</span>    FR_Tax,&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span>    TaxBase tax;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>                <span class="hljs-keyword">if</span>(tax == CN_Tax) &#123;            <span class="hljs-comment">//CN*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == US_Tax) &#123;            <span class="hljs-comment">//US*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == DE_Tax) &#123;            <span class="hljs-comment">//DE*****</span>        &#125;        <span class="hljs-comment">/***加入France***/</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == FR_Tax) &#123;                  &#125;        <span class="hljs-comment">//***</span>    &#125;&#125;</code></pre></div><ul><li>考虑另一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxStrategy</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~TaxStrategy() &#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DETax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span><span class="hljs-keyword">private</span>:    TaxStrategy* strategy;<span class="hljs-keyword">public</span>:    SalesOrder(StrategyFactory* strategyFactory) &#123;        <span class="hljs-keyword">this</span>-&gt;strategy = strategyFactory-&gt;NewStrategy();    &#125;        ~SalesOrder() &#123;        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>        <span class="hljs-function">Context <span class="hljs-title">context</span><span class="hljs-params">()</span></span>;                <span class="hljs-keyword">double</span> val =             srtategy-&gt;Calculate(context);<span class="hljs-comment">//多态调用</span>    &#125;&#125;</code></pre></div><p>如果要增加法国，只需增加一个<code>FRTax</code>类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> doubel <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>这是一种扩展的做法，在这里只需要增加一个FRTax类，不需要更改SalesOrder。</p><p>复用性一般是指二进制层面下的复用性，如果使用第一种方法，那么整个系统需要重新编译，重新测试。虽然修改后保留了一部分原来的代码，但是这个并不是复用。而策略方法不需要重新编译之前编译好的文件，只需要重新编译FRTax这个文件</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200805135526277.png" srcset="/img/loading.gif" alt="image-20200805135526277"> </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使 得类型在运行时方便地根据需要在各个算法之间进行切换。</p></li><li><p>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件 判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需 要Strategy模式。</p></li><li><p>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CA - Pipeline</title>
    <link href="/2019/10/13/pipeline/"/>
    <url>/2019/10/13/pipeline/</url>
    
    <content type="html"><![CDATA[<h1><a name="pipline">附录C流水线</a></h1><h2 id="1-什么是流水线"><a href="#1-什么是流水线" class="headerlink" title="1 什么是流水线"></a>1 什么是流水线</h2><p>流水线是一种将多条指令 <strong><em>重叠执行</em></strong> 的实现技术  </p><p>一条执行包含多种操作，流水线充分利用了这些 <strong><em>操作之间的并行性</em></strong><br><br/></p><p>为了能更形象地理解这个问题，不妨用汽车装配线来做类比    </p><blockquote><p>汽车装配线的每一环节负责一项任务，所有环节是并行的（也就是不同的汽车同时在不同的环节上）  </p><p>在流水线中，指令就像是一辆待装配的汽车，不同环节完成指令的一部分,这些环节的每一步称为 <strong><em>流水级或者流水段</em></strong>。流水级前后相连形成流水线  </p><p>汽车装配线的 <strong><em>吞吐量</em></strong> 定义为单位时间生产的汽车数量，由完整汽车退出装配线的频率决定</p><p>流水线的吞吐量由指令退出流水线的频率决定。一条指令在流水线中下移一步需要的时间为 <strong><em>处理器周期</em></strong> 。因为各个环节同时执行，所以处理器周期由最缓慢的流水线级确定。</p></blockquote><p>可以想见，要使流水线性能高，平衡各流水线级很重要  </p><blockquote><p>因为处理器周期由最缓慢的流水线级确定，我们想要使最缓慢环节的加快，就要平衡各流水线级。  [木桶原理]</p></blockquote><p>如果各级达到完美平衡，那么每条指令在流水线处理器中的时间为  </p><p>$$\frac{非流水线机器上每条指令的时间}{流水级的数目}$$  </p><p>在这些条件下，流水线加速比=流水级的数目</p><br/><h1 id="2-RISC指令集"><a href="#2-RISC指令集" class="headerlink" title="2 RISC指令集"></a>2 RISC指令集</h1><p>我们以RISC指令集为例来了解一下流水线实现。一下，我们会介绍RISC指令集以及没有流水线的实现方式。</p><p>RISC指令集子集中每条指令都可以在5个时钟周期以内实现。以MIPS指令集为例介绍这5个时钟周期</p><ul><li><strong><em>指令提取周期(IF(Instruction Fetch))</em></strong>  </li><li><strong><em>指令译码/寄存器提取周期(ID)</em></strong>  </li><li><strong><em>执行/有效地址周期(EX)</em></strong>  </li><li><strong><em>存储器访问(MEM)</em></strong></li><li><strong><em>写回周期(WB)</em></strong></li></ul><center><img="/Users/jones/Library/Application Support/typora-user-images/image-20191219230108716.png" alt="image-20191219230108716" style="zoom:50%;" /></center><p><a href="http://web.cs.iastate.edu/~prabhu/Tutorial/PIPELINE/DLXimplem.html" target="_blank" rel="noopener">http://web.cs.iastate.edu/~prabhu/Tutorial/PIPELINE/DLXimplem.html</a></p><br/><h1 id="3-RISC处理器经典五级流水线"><a href="#3-RISC处理器经典五级流水线" class="headerlink" title="3 RISC处理器经典五级流水线"></a>3 RISC处理器经典五级流水线</h1><center><img src="ca20190908-1.png" srcset="/img/loading.gif" width="600"></center><center><img src="ca20190908-2.png" srcset="/img/loading.gif" width="600"></center><br/><p>在RISC流水线中，多条指令的执行重叠不会引入多少冲突，因为以下三点</p><h4 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h4><p>使用分离的指令存储器和数据存储器。</p><p>这样做是因为指令提取和数据访问都需要访问存储器，会引发冲突，所以分离指令和数据存储器。</p><p>注意：如果流水线处理器时钟周期=多周期处理器时钟周期，存储器需要提供<strong>5倍带宽</strong></p><h4 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h4><p>两个阶段使用了寄存器堆：<strong>ID</strong>阶段decode, <strong>WB</strong>阶段writeback写入</p><p>因此，每个时钟周期寄存器需要两次读取(A=Reg[rs], B=Reg[rt]) 和一次写入</p><p>为了出气对相同寄存器堆多次读取和一次写入，<strong><em>我们在时钟周期的前半部分写寄存器，后半部分读寄存器</em></strong></p><h4 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h4><p>程序计数器在IF阶段要递增</p><p>ID阶段要计算潜在的分支目标。若分支在ID改变程序计数器？</p><br/><p>除了要确保流水线中的指令不会在相同时间使用相同的硬件资源，还要确保不同流水级的指令不会互相干扰。这是通过在流水级之间引入 <u>流水线寄存器</u>来实现的。将一个给定的流水级得出的结果存储到流水线寄存器，并在下一个时钟周期作为下一个流水级的输入。</p><center><img src="image-20191013133054888.png" srcset="/img/loading.gif" alt="image-20191013133054888" style="zoom: 30%;" /></center><h1 id="4-流水化的主要阻碍-流水线冒险"><a href="#4-流水化的主要阻碍-流水线冒险" class="headerlink" title="4 流水化的主要阻碍-流水线冒险"></a>4 流水化的主要阻碍-流水线冒险</h1><p>冒险降低来了流水化所能带来的理想加速比<br>冒险共有一下三类  </p><ol><li><p>结构冒险  </p><p>在重叠执行模式下，硬件无法同时支持指令的所有可能组合，就会出现资源冲突 [比如大家都想访问存储器]</p></li><li><p>数据冒险  </p><p>指令之间存在先后顺序，一条指令取决于先前指令的结果</p></li><li><p>控制冒险 </p><p>分支指令以及其他改变程序计数器的指令会导致控制冒险</p></li></ol><p>为了避免冒险，要求流水线中的一些指令延迟时，其他指令能够继续执行 。</p><div class="note note-warning">            <p>这里讨论的流水线，当一条指令被stall时，在指令停顿之后发射的<strong><em>所有指令也会被停顿</em></strong>，之前发射的指令不会被停顿</p>          </div><br/><h2 id="4-1-带有停顿的流水线性能"><a href="#4-1-带有停顿的流水线性能" class="headerlink" title="4.1 带有停顿的流水线性能"></a>4.1 带有停顿的流水线性能</h2><p>$<br>流水化加速比=\frac{非流水化指令平均执行时间}{流水化指令平均执行时间}$<br>$=\frac{非流水化CPI\times 非流水化时钟周期}{流水化CPI\times 流水化时钟周期}$<br>$=\frac{非流水化CPI}{流水化CPI}\times \frac{非流水化时钟周期}{流水化时钟周期}$</p><br/><p>流水化处理器的理想CPI几乎总是等于1，算上停顿<br>$<br>流水化CPI=理想CPI+每条指令的流水线停顿时钟周期$<br>$=1+每条指令的流水线停顿时间周期$</p><p>所以</p><p>$$加速比=\frac{非流水化CPI}{1+每条指令的流水线停顿周期}$$</p><p>如果所有指令周期数相同，等于流水级数目(流水线深度)，那么非流水化CPI=流水线深度</p><p>$$加速比=\frac{流水深度}{1+每条指令的流水线停顿周期}$$</p><div class="note note-warning">            <p><u>所以，如果没有流水线停顿，加速比=流水线深度</u></p>          </div><h2 id="4-2-结构冒险"><a href="#4-2-结构冒险" class="headerlink" title="4.2 结构冒险"></a>4.2 结构冒险</h2><p>i. 什么是结构冒险</p><blockquote><p>指令重叠执行需要实现功能单元的流水化和资源的复制，以允许在流水线中出现所有可能的指令组合</p><p>如果由于资源冲突而不能容许某些指令组合，就说出现结构冒险</p></blockquote><p>ii. 解决方式</p><p>在发生结构冒险时，使流水线停顿一个时钟周期</p><p>停顿称为 <u>流水线气泡</u>，他们漂浮穿过流水线，占有空间但是不执行有效工作。导致CPI增大</p><br/><h2 id="4-3-数据冒险"><a href="#4-3-数据冒险" class="headerlink" title="4.3 数据冒险"></a>4.3 数据冒险</h2><p>i. 数据冒险是什么</p><blockquote><p>有些指令依赖于之前指令的结果</p></blockquote><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">DADD</span> <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R3</span><span class="hljs-symbol">DSUB</span> <span class="hljs-built_in">R4</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R5</span><span class="hljs-keyword">AND </span> <span class="hljs-built_in">R6</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R7</span><span class="hljs-symbol">OR</span>   <span class="hljs-built_in">R8</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R9</span><span class="hljs-symbol">XOR</span>  <span class="hljs-built_in">R10</span>,<span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R11</span></code></pre></div><p>DADD后的所有指令都用到了DADD指令的结果R1</p><p>所以在DADD的结果writeback之前，下面的指令都是不能execute的</p><center><img src="image-20191013143518878.png" srcset="/img/loading.gif" alt="image-20191013143518878" style="zoom:30%;" /></center><p>ii. 解决方法</p><p>A. 转发(forwarding)</p><p>转发是一个什么思想呢？ </p><blockquote><p>DSUB需要DADD的结果x, 那么不妨DADD在算出x之后，就把结果给到DSUB需要这个x的位置，而不用等到writeback</p></blockquote><p>转发的工作方式</p><ol><li>来自EX/MEM和MEM/WB流水线寄存器的输入总是被反馈回ALU的输入端</li><li>如果转发硬件检测到前一个ALU操作已经对当前ALU操作的原寄存器进行了写入操作，则控制逻辑选择转发结果作为ALU输入，而不是选择从寄存器堆中读区的值</li></ol><center><img src="https://miaochenlu.github.io/picture/屏幕快照 2019-10-13 下午2.56.04.png" srcset="/img/loading.gif" style="zoom: 30%;" /></center><p>B, 需要停顿的数据冒险</p><p>并非所有的潜在数据冒险都可以通过转发处理</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">LD</span>   <span class="hljs-built_in">R1</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">R2</span>)<span class="hljs-symbol">DSUB</span> <span class="hljs-built_in">R4</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R5</span><span class="hljs-keyword">AND </span> <span class="hljs-built_in">R6</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R7</span><span class="hljs-symbol">OR</span>   <span class="hljs-built_in">R8</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R9</span></code></pre></div><center><img src="image-20191013151122898.png" srcset="/img/loading.gif" alt="image-20191013151122898" style="zoom:30%;" /></center><center><img src="image-20191013151314878.png" srcset="/img/loading.gif" alt="image-20191013151314878" style="zoom:25%;" /></center><h3 id="More-about-data-dependences-and-hazards"><a href="#More-about-data-dependences-and-hazards" class="headerlink" title="More about data dependences and hazards"></a>More about data dependences and hazards</h3><h4 id="A-data-dependences"><a href="#A-data-dependences" class="headerlink" title="A. data dependences"></a>A. data dependences</h4><ol><li>数据相关[真数据相关]</li></ol><p>指令i生成的结果可能会被指令j用到</p><p>指令j数据相关于指令k, 指令k数据相关于指令i</p><center><img="https://miaochenlu.github.io/picture/image-20191223102354535.png" alt="image-20191223102354535" style="zoom:50%;" /></center><ol start="2"><li>名称相关</li></ol><p>当两条指令使用相同的寄存器或者存储器位置[称为名称]， 但与该名称相关的指令之间并没有数据流动时，就会发生名称相关。</p><ul><li><p>Anti-dependence: S1 -&gt; S2 </p><p>(i)  S1 executes before S2<br>(ii) S1 reads from a location that is overwritten later by S2</p></li></ul><div class="note note-warning">            <p>WAR</p><ul><li><p>Output dependence: S1 -&gt; S2 </p><p>(i)  S1 executes before S2<br>(ii) S1 and S2 write to the same location </p></li></ul>          </div><p>WAW</p><p>由于没有在指令之间传递值, 所以antidependence和output dependence只是名称相关，不是真数据相关。改变这些指令中使用的名称[寄存器号或者存储器位置],  就可以使这些指令不再冲突。</p><h4 id="B-data-hazards"><a href="#B-data-hazards" class="headerlink" title="B. data hazards"></a>B. data hazards</h4><ul><li>RAW</li><li>WAW: 对应于output dependence。 只有在前一指令stall时允许后一指令继续执行的流水线中，才会存在WAW冒险</li><li>WAR: 对应于antidependence。</li></ul><h2 id="4-4-分支冒险"><a href="#4-4-分支冒险" class="headerlink" title="4.4 分支冒险"></a>4.4 分支冒险</h2><h3 id="i-分支冒险是什么"><a href="#i-分支冒险是什么" class="headerlink" title="i. 分支冒险是什么"></a>i. 分支冒险是什么</h3><p>执行分支指令时，修改后的PC可能等于也可能不等于PC+4。</p><p>如果分支讲PC改到其目标地址，就是选中了分支；否则就是没有选中分支。一般等到ID末尾，完成地址计算和对比之后才会改变PC</p><p>那么还不知到分支指令跳到哪里，pipeline按顺序执行的指令可能不会被执行到。</p><h3 id="ii-解决方法"><a href="#ii-解决方法" class="headerlink" title="ii. 解决方法"></a>ii. 解决方法</h3><p>一旦在ID期间检测到分支，就对该分支之后的指令重新取值。但是这样处理的问题是，如果分支没有被选中，所以事实上已经正确提取了指令，所以IF的重复没有必要</p><img src="image-20191021095111.png" srcset="/img/loading.gif" alt="image-20191021095111" style="zoom:50%;" /><p>所以，如何降低流水线分支代价？</p><p>4种简单的编译时机制</p><h4 id="A-冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标"><a href="#A-冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标" class="headerlink" title="A. 冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标"></a>A. 冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标</h4><h4 id="B-将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。"><a href="#B-将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。" class="headerlink" title="B. 将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。"></a>B. 将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。</h4><p>这种预测未选中机制的实现方式是继续提取指令，就好像分支指令时一条正常指令一样。但是，如果分支被选中，就要将已经提取的指令转化为空操作，重新开始在目标地址提取指令。</p><p>这一机制的复杂性在于要知道处理器可能何时被指令改变，以及如何撤销这种改变</p><center><img src="image-20191014112116582.png" srcset="/img/loading.gif" alt="image-20191014112116582" style="zoom:35%;" /></center><h4 id="C-将所有分支都看作选中分支"><a href="#C-将所有分支都看作选中分支" class="headerlink" title="C. 将所有分支都看作选中分支"></a>C. 将所有分支都看作选中分支</h4><p>只要对分支指令进行了译码并且计算了目标地址，就假定该分支被选中，开始在目标位置提取和执行。</p><p>但是在我们的五级流水线中，不可能在知道分支输出结果之前知道目标地址，所以这对我们没什么用。</p><h4 id="D-延迟分支"><a href="#D-延迟分支" class="headerlink" title="D. 延迟分支"></a>D. 延迟分支</h4><blockquote><p>分支指令</p><p>依序后续指令[位于delay slots]</p><p>选中时的分支指令</p></blockquote><p>获得编译器支持，编译器让后续指令有效并且可用</p><center><img src="image-20191021095901298.png" srcset="/img/loading.gif" alt="image-20191021095901298" style="zoom: 40%;" ></center><p>延迟调度有局限性，这个局限性是因为</p><blockquote><ol><li>可以排在延迟时隙[delay slots]中的指令有限制</li><li>编译时预测一个分支是否可能被选中的能力有限。为了提高编译器填充delay slots的能力，大多数具有条件分支的处理器引入了<em>canceling</em> or <em>nullifying</em> branch . 在取消分支中，指令包含了预测分支的方向。当分支行为和预期一致时，分支延迟时隙中的指令就想普通的延迟分支一样执行。预测错误时，分支延迟时隙中的指令转为空操作。</li></ol></blockquote><p>看一下这些不同的解决方法效率有什么差别</p><center><img src="image-20191021101747938.png" srcset="/img/loading.gif" alt="image-20191021101747938" style="zoom:50%;" ></center><p>考虑flush pipeline</p><p>unconditional branch指的是像j, jal这种的，这些直到Decode才会知道分支目标，所以penalty=2</p><p>其他conditional，像beq等，需要EXE才知道是否要跳转，所以penalty=3</p><p>这样，考虑predicted untaken</p><p>unconditional 指令被预测不执行，但是一定会执行，代价是2</p><p>conditional的如果没有执行，和预测一致，代价为0。如果和预测不一致，代价为3</p><p>考虑predicted taken</p><p>如果和预测一致。那么在Branch指令的EXE阶段才能知道分支目标，所以要stall 2个时钟周期才能跳转</p><br><p>当流水线越来越深，分支的潜在代价增加，使用延迟分支是不够的。要更积极地去预测分支。静态机制[依赖编译时信息，成本低]，动态预测[依据程序特性]</p><h4 id="i-静态分支预测"><a href="#i-静态分支预测" class="headerlink" title="i. 静态分支预测"></a>i. 静态分支预测</h4><p>事先收集数据，根据数据来预测分支</p><h4 id="ii-动态分支预测"><a href="#ii-动态分支预测" class="headerlink" title="ii. 动态分支预测"></a>ii. 动态分支预测</h4><p>使用分支预测缓冲区[Branch-Prediction Buffer].</p><p>这是一个cache，分支指令地址的低位部分用来索引，所有访问都会hit。</p><p>这个存储器包含一个bit来标示这个分支最近是否被选中。这个bit可以用来为接下来的这条分支提供指导。如果预测结果和bit不一致，反转bit; 一致则不反转</p><p>但是只有1bit来标示会存在一点问题，比如分支一直被选中，但是某一次没有被选中，bit也会反转，这种反转其实没有必要，会影响效率。</p><p>所以这里提出了2位预测机制。</p><p>两位预测机制，预测必须连续错过两次才会进行修改。</p><center><img src="image-20191021103246990.png" srcset="/img/loading.gif" alt="image-20191021103246990" style="zoom:50%;" ></center><h1 id="5-如何实现流水线"><a href="#5-如何实现流水线" class="headerlink" title="5. 如何实现流水线"></a>5. 如何实现流水线</h1><p>MIPS CPU多周期实现</p><center><img src="image-20191021105802697.png" srcset="/img/loading.gif" alt="image-20191021105802697" style="zoom:45%;" ></center><h2 id="Basic-Pipeline"><a href="#Basic-Pipeline" class="headerlink" title="Basic Pipeline"></a>Basic Pipeline</h2><center><img src="image-20191021110018403.png" srcset="/img/loading.gif" alt="image-20191021110018403" style="zoom:45%;" ></center><h3 id="i-IF"><a href="#i-IF" class="headerlink" title="i. IF"></a>i. IF</h3><div class="hljs"><pre><code class="hljs cpp">IF/ID.IR = Mem[PC];<span class="hljs-comment">//取指令</span><span class="hljs-keyword">if</span>((EX/MEM.opcode == branch) &amp;&amp; EX/MEM.cond) &#123;  IF/IR.NPC = EX/MEM.ALUOutput;  PC = EX/MEM.ALUOutput;&#125; <span class="hljs-keyword">else</span> &#123;  IF/IR.NPC = PC + <span class="hljs-number">4</span>;  PC = PC + <span class="hljs-number">4</span>;&#125;</code></pre></div><h3 id="ii-ID"><a href="#ii-ID" class="headerlink" title="ii. ID"></a>ii. ID</h3><div class="hljs"><pre><code class="hljs cpp">ID/EX.A = Regs[IF/ID.IR[rs]];ID/EX.B = Regs[IF/ID.IR[rt]];ID/EX.NPC = IF/ID.NPC;ID/EX.IR = IF/ID.IR;ID/EX.Imm = sign-extend(IF/ID.IR[immediate]);</code></pre></div><h3 id="iii-EX"><a href="#iii-EX" class="headerlink" title="iii. EX"></a>iii. EX</h3><h4 id="A-ALU-EX"><a href="#A-ALU-EX" class="headerlink" title="A. ALU EX"></a>A. ALU EX</h4><div class="hljs"><pre><code class="hljs cpp">EX/MEM.IR = ID/EX.IR;执行以下之一<span class="hljs-number">1.</span> EX/MEM.ALUOutput = ID/EX.A func ID/EX.B;<span class="hljs-number">2.</span> EX/MEM.ALUOutput = ID/EX.A op ID/EX.Imm</code></pre></div><h4 id="B-Load-Store-EX"><a href="#B-Load-Store-EX" class="headerlink" title="B. Load Store EX"></a>B. Load Store EX</h4><div class="hljs"><pre><code class="hljs cpp">EX/MEM.IR to ID/EX.IR;EX/MEM.ALUOutput = ID/EX.A + ID/EX.imm;EX/MEM.B = ID/EX.B;</code></pre></div><h4 id="C-Branch-EX"><a href="#C-Branch-EX" class="headerlink" title="C. Branch EX"></a>C. Branch EX</h4><div class="hljs"><pre><code class="hljs cpp">EX/MEM.ALUOutput = ID/EX.NPC + (ID/EX.Imm &lt;&lt; <span class="hljs-number">2</span>);EX/MEM.cond = (ID/EX.A == <span class="hljs-number">0</span>);</code></pre></div><h3 id="iv-MEM"><a href="#iv-MEM" class="headerlink" title="iv. MEM"></a>iv. MEM</h3><h4 id="A-ALU-MEM"><a href="#A-ALU-MEM" class="headerlink" title="A. ALU MEM"></a>A. ALU MEM</h4><div class="hljs"><pre><code class="hljs cpp">MEM/WB.IR = EX/MEM.IR;MEM/WB.ALUOutput = EX/MEM.ALUOutput;</code></pre></div><h4 id="B-Load-Store-MEM"><a href="#B-Load-Store-MEM" class="headerlink" title="B. Load Store MEM"></a>B. Load Store MEM</h4><div class="hljs"><pre><code class="hljs cpp">MEM/WB.OR = EX/MEM.IR;<span class="hljs-number">1.</span> MEM/WB.LMD = Mem[EX/MEM.ALUOutput];<span class="hljs-number">2.</span> Mem[EX/MEM.ALUOutput] = EX/MEM.B;</code></pre></div><h3 id="v-WB"><a href="#v-WB" class="headerlink" title="v. WB"></a>v. WB</h3><h4 id="A-ALU-WB"><a href="#A-ALU-WB" class="headerlink" title="A. ALU WB"></a>A. ALU WB</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> Regs[MEM/WB.IR[rd]] = MEM/WB.ALUOutput;<span class="hljs-number">2.</span> Resg[MEM/WB.IR[rt]] = MEM/WB.ALUOutput;</code></pre></div><h4 id="B-Load-Store-WB"><a href="#B-Load-Store-WB" class="headerlink" title="B. Load Store WB"></a>B. Load Store WB</h4><div class="hljs"><pre><code class="hljs cpp">For load onlyRegs[MEM/WB.IR[rt]] = MEM/WB.LMD;</code></pre></div><h2 id="Control-the-Pipeline"><a href="#Control-the-Pipeline" class="headerlink" title="Control the Pipeline"></a>Control the Pipeline</h2><p>instruction issue:</p><blockquote><p>一条指令从ID移入EX的过程</p></blockquote><p>对于整数流水线，所有数据冒险都可以在ID进行检查。</p><p>如果存在数据冒险，这个指令将会在issue之前停顿。</p><p>同样，我们可以确定在ID期间需要哪种转发，并设定适当的控制。</p><center><img src="image-20191021115323894.png" srcset="/img/loading.gif" alt="image-20191021115323894" style="zoom:35%;" /></center><p>pipeline overhead</p><p>due to stage imbalance, pipeline register setup</p><h3 id="Deal-with-forwarding"><a href="#Deal-with-forwarding" class="headerlink" title="Deal with forwarding"></a>Deal with forwarding</h3><center><img="https://miaochenlu.github.io/picture/image-20191222210658336.png" alt="image-20191222210658336" style="zoom:50%;" /></center><h1 id="6-扩展MIPS流水线，以处理多周期操作"><a href="#6-扩展MIPS流水线，以处理多周期操作" class="headerlink" title="6. 扩展MIPS流水线，以处理多周期操作"></a>6. 扩展MIPS流水线，以处理多周期操作</h1><p>扩展mips流水线，以处理浮点运算</p><p>浮点运算的问题</p><blockquote><p>要求所有浮点运算在1个周期内完成时不现实的，甚至2个时钟周期都不太可能</p><p>如果想要在一个时钟周期内完成，就必须降低clock rate, 或者增加大量的逻辑单元。</p><p>所以</p><ul><li>为了完成操作，EX周期可能要根据需要重复多次</li><li>可能存在多个浮点功能单元，如果待发射指令会导致浮点所用功能单元的结构冒险，或者数据冒险，就会出现停顿。</li></ul></blockquote><p>4个独立的功能单元</p><ul><li>主整数单元，处理load, store, 整数ALU operation, branch</li><li>浮点与整数乘法器</li><li>浮点加法器，处理浮点加、减和转换</li><li>浮点和整型除法器</li></ul><p>假定这些功能单元的执行级没有实现流水化</p><center><img="https://miaochenlu.github.io/picture/image-20191111101801471.png" alt="image-20191111101801471" style="zoom:50%;" /></center><p>两个指标</p><ul><li><p>latency</p><p>the number of intervening cycles between an instruction that produces a result and an instruction that uses the result. 一条指令产生结果后，下一条指令等待多久才可以使用这个结果。注意，是等待。</p><blockquote><p>Essentially, pipeline <strong>latency</strong> is 1 cycle less than the depth of the execution pipeline, which is the number of stages from the <strong>EX stage</strong> to the stage that produces the result </p></blockquote></li><li><p>initiation/repeat interval</p><p>同一类型的指令执行之间必须间隔的周期数。比如，integer ALU的一条指令开始执行，下一条integer ALU指令需要在他后面一个周期才能开始执行</p></li></ul><center><img="https://miaochenlu.github.io/picture/IMG_C3E4F59B24C4-1.png" alt="IMG_C3E4F59B24C4-1" style="zoom:50%;" /></center><img src="IMG_C3E4F59B24C4.png" srcset="/img/loading.gif" alt="IMG_C3E4F59B24C4-1" style="zoom:50%;" /><p>instruction issue: 从ID到EX的阶段</p><center><img="image-20191111103138887.png" alt="image-20191111103138887" style="zoom:50%;" /></center><center><img="image-20191111104720076.png" alt="image-20191111104720076" style="zoom:50%;" /></center><table>  <tr>    <td>      <img src="image-20191111103409484.png" srcset="/img/loading.gif" alt="image-20191111103409484" style="zoom:50%;" />    </td>    <td>      <img src="image-20191111103455864.png" srcset="/img/loading.gif" alt="image-20191111103455864" style="zoom:50%;" />    </td>  </tr></table><table>  <tr>    <td>      <img src="image-20191111103637824.png" srcset="/img/loading.gif" alt="image-20191111103637824" style="zoom:50%;" />    </td>    <td>      <img src="image-20191111104058863.png" srcset="/img/loading.gif" alt="image-20191111104058863" style="zoom:50%;" />    </td>  </tr></table>]]></content>
    
    
    <categories>
      
      <category>Computer Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CA - Instruction Set</title>
    <link href="/2019/09/08/instructionSet/"/>
    <url>/2019/09/08/instructionSet/</url>
    
    <content type="html"><![CDATA[<h1 id="附录A-指令集基本原理"><a href="#附录A-指令集基本原理" class="headerlink" title="附录A 指令集基本原理 "></a><a name="ISA">附录A 指令集基本原理 </a></h1><h1 id="1-What-is-ISA"><a href="#1-What-is-ISA" class="headerlink" title="1 What is ISA?"></a>1 What is ISA?</h1><p>ISA: Instruction Set Architecture</p><img src="image-20190930101228492.png" srcset="/img/loading.gif" alt="image-20190930101228492" style="zoom:50%;" /><h1 id="2-What-types-of-ISA"><a href="#2-What-types-of-ISA" class="headerlink" title="2 What types of ISA?"></a>2 What types of ISA?</h1><h3 id="2-1-Basis"><a href="#2-1-Basis" class="headerlink" title="2.1 Basis"></a>2.1 Basis</h3><ul><li>type of internal storage</li></ul><blockquote><p>stack</p><p>accumulator</p><p>Register-memory</p><p>Register-register/load-store</p></blockquote><br/><p>先来解释一下implicit operand和explicit operand</p><ul><li>explicit operand</li></ul><p>明确到哪个地方去取的操作数，比如到某一个由指令确定的<strong><em>寄存器</em></strong>，或者内存中一个由指令确定的<strong><em>存储器地址</em></strong></p><ul><li>implicit operand</li></ul><p>不明确的取值位置，但是系统默认了。比如stack architecture就是默认到stack头部去取，accumulator architecture就是默认到accumulator中去取。</p><br/><img src="image-20191218224444341.png" srcset="/img/loading.gif" alt="image-20191218224444341" style="zoom:50%;" /><p>C=A+B的代码示例</p><img src="image-20191218224500000.png" srcset="/img/loading.gif" alt="image-20191218224500000" style="zoom:50%;" /><p>example problem</p><img src="image-20191218224924929.png" srcset="/img/loading.gif" alt="image-20191218224924929" style="zoom:50%;" /><h4 id="2-1-1-Stack-Architecture"><a href="#2-1-1-Stack-Architecture" class="headerlink" title="2.1.1 Stack Architecture"></a>2.1.1 Stack Architecture</h4><p><strong>*<u>operand</u>*</strong>:</p><blockquote><p> 2 <strong>*<u>implicit</u>*</strong> operands on the top of the stack(<strong><em>TOS</em></strong>)</p></blockquote><p>用图来看一下以下操作的过程</p><div class="hljs"><pre><code class="hljs armasm">C = A + <span class="hljs-keyword">B </span>(memory locations)<span class="hljs-keyword">Push </span>A<span class="hljs-keyword">Push </span><span class="hljs-keyword">B</span><span class="hljs-keyword">Add </span><span class="hljs-keyword">Pop </span>C</code></pre></div> <table>   <tr>     <td>       <img src="image-20190930102555608.png" srcset="/img/loading.gif" alt="image-20190930102555608" title="original"/>     </td>     <td>  <img src="image-20190930102855084.png" srcset="/img/loading.gif" alt="image-20190930102855084" title="push A"/>     </td>     <td>  <img src="image-20190930103000391.png" srcset="/img/loading.gif" alt="image-20190930103000391" title="push B"  />     </td>     <td>  <img src="image-20190930103037853.png" srcset="/img/loading.gif" alt="image-20190930103037853" title="Add"  />     </td>     <td>  <img src="image-20190930103101742.png" srcset="/img/loading.gif" alt="image-20190930103101742" title="pop C" />     </td>   </tr> </table><h4 id="2-1-2-Accumulator-Architecture"><a href="#2-1-2-Accumulator-Architecture" class="headerlink" title="2.1.2 Accumulator Architecture"></a>2.1.2 Accumulator Architecture</h4><p><strong>*<u>operand</u>*</strong></p><blockquote><p>one implicit operand: accumulator</p><p>one explicit operand: mem location</p></blockquote><p>看一下以下操作的过程</p><div class="hljs"><pre><code class="hljs fortran">C = A + BLoad AAdd BStore Caccumulator is both an <span class="hljs-keyword">implicit</span> input operand and a result</code></pre></div><table>  <tr>    <td>      <img src="image-20190930115553486.png" srcset="/img/loading.gif" alt="image-20190930115553486" title="original"/>    </td>    <td>  <img src="image-20190930115635931.png" srcset="/img/loading.gif" alt="image-20190930115635931" title="load A"/>    </td>      <td>  <img src="image-20190930115734010.png" srcset="/img/loading.gif" alt="image-20190930115734010" title="add B"/>    </td>    <td>  <img src="image-20190930115804883.png" srcset="/img/loading.gif" alt="image-20190930115804883" title="store C"/>    </td>  </tr></table><h1 id="3-存储器寻址"><a href="#3-存储器寻址" class="headerlink" title="3. 存储器寻址"></a>3. 存储器寻址</h1><h2 id="3-1-解释存储器地址"><a href="#3-1-解释存储器地址" class="headerlink" title="3.1 解释存储器地址"></a>3.1 解释存储器地址</h2><p>i. 关于如何对一个较大对象中的字节排序：</p><ul><li>Little Endian : store least significant byte in the smallest address</li></ul><img src="image-20191014101250484.png" srcset="/img/loading.gif" alt="image-20191014101250484" style="zoom:40%;" /><ul><li>Big Endian : store most significant byte in the smallest address</li></ul><img src="image-20191014101429477.png" srcset="/img/loading.gif" alt="image-20191014101429477" style="zoom:40%;" /><p>ii. 字节对齐</p><p>大小为s bytes的对象，字节地址为A, 如果$A; mod;s = 0$ , 那么是字节对齐的</p><img src="image-20191014101703881.png" srcset="/img/loading.gif" alt="image-20191014101703881" style="zoom:40%;" /><p>为什么要对齐</p><blockquote><p>When well aligned, requires only one memory access to read one object;</p><p>If address is not well aligned, each misaligned object requires two memory accesses to fetch.</p></blockquote><h2 id="3-2-Addressing-modes"><a href="#3-2-Addressing-modes" class="headerlink" title="3.2  Addressing modes"></a>3.2  Addressing modes</h2><img src="image-20191014102744097-6809392.png" srcset="/img/loading.gif" alt="image-20191014102744097-6809392" style="zoom:50%;" /><p>References:  </p><p>[1]计算机体系结构 量化研究方法</p>]]></content>
    
    
    <categories>
      
      <category>Computer Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
