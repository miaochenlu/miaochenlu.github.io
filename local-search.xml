<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Decorator</title>
    <link href="/2020/08/07/Decorator/"/>
    <url>/2020/08/07/Decorator/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在某些情况下我们可能会”过度地使用继承来扩展对象的功能”， 由于继承为类型引入的<strong>静态特质</strong>，使得这种扩展方式缺乏灵活性； 并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</p><p>如何使”对象功能的扩展”能够根据需要来动态地实现？同时避免”扩展功能的增多”带来的子类膨胀问题？从而使得任何”功能扩展变化”所导致的影响将为最低？</p><p>所谓静态特质, 比如在CryptoNetworkStream的Read函数中定死了调用NetworkStream::Read(), 而我们重构后的CryptoStream中的Read函数调用stream-&gt;Read(), 支持多态，可以产生变化。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面给出一个Stream代码示例，其继承关系如下所示</p><img src="image-20200807143722316.png" srcset="/img/loading.gif" alt="image-20200807143722316" style="zoom:30%;" /><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//业务操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stream</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Stream() &#123;&#125;&#125;;<span class="hljs-comment">//主体类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读文件流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位文件流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写文件流</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读网络流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位网络流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写网络流</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读内存流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位内存流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写内存流</span>    &#125;&#125;;<span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoNetworkStream</span>:</span> <span class="hljs-keyword">public</span> NetworkStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoMemoryStream</span>:</span> <span class="hljs-keyword">public</span> MemoryStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedNetworkStream</span>:</span> <span class="hljs-keyword">public</span> NetworkStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedMemoryStream</span>:</span> <span class="hljs-keyword">public</span> MemoryStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoBufferedFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Read(number);<span class="hljs-comment">//读文件流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Seek(position);<span class="hljs-comment">//定位文件流</span>        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Write(position);<span class="hljs-comment">//写文件流</span>        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//编译时装配</span>    CryptoFileStream* fs1 = <span class="hljs-keyword">new</span> CryptoFileStream();        BufferedFileStream* fs2 = <span class="hljs-keyword">new</span> BufferedFileStream();        CryptoBufferedFileStream* fs3 = <span class="hljs-keyword">new</span> CryptoBufferedFileStream();&#125;</code></pre></div><p>这样设计的代码存在大量的冗余，比如对于不同的stream, 无论是FileStream还是NetworkStream还是MemoryStream, 他们的加密操作都是一样的。</p><ul><li>重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoFileStream</span> &#123;</span>    FileStream* stream;<span class="hljs-comment">//=new FileStream()</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoNetworkStream</span> &#123;</span>    NetworkStream* stream;<span class="hljs-comment">//=new NetworkStream();</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoMemoryStream</span> &#123;</span>    MemoryStream* stream;<span class="hljs-comment">//=new MemoryStream();</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;</code></pre></div><ul><li>继续重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;    Stream* stream;<span class="hljs-comment">//...</span><span class="hljs-keyword">public</span>:    CryptoStream(Stream* stm): stream(stm) &#123;            &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;    Stream* stream; <span class="hljs-comment">//...</span>    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//运行时装配</span>    FileStream* s1 = <span class="hljs-keyword">new</span> FileStream();    CryptoStream* s2 = <span class="hljs-keyword">new</span> CryptoStream(s1);    BufferedStream* s3 = <span class="hljs-keyword">new</span> BufferedStream(s1);    BufferedStream* s4 = <span class="hljs-keyword">new</span> BufferedStream(s2);&#125;</code></pre></div><p>很神奇，CryptoStream既有Stream基类，也有Stream字段。这里还需要继承Stream是因为他定义了基类的接口规范</p><ul><li>继续重构</li></ul><p>CryptoStream, BufferedStream都有Stream这个字段，把他们提到一个中间类中，</p><p>设置一个DecoratorStream中间类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoratorStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">protected</span>:    Stream* stream; <span class="hljs-comment">//...</span>    DecoratorStream(Stream* stm): DecoratorStream(stm) &#123;            &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> DecoratorStream &#123;<span class="hljs-keyword">public</span>:    CryptoStream(Stream* stm): DecoratorStream(stm) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span>:</span> <span class="hljs-keyword">public</span> DecoratorStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//运行时装配</span>    FileStream* s1 = <span class="hljs-keyword">new</span> FileStream();    CryptoStream* s2 = <span class="hljs-keyword">new</span> CryptoStream(s1);    BufferedStream* s3 = <span class="hljs-keyword">new</span> BufferedStream(s1);    BufferedStream* s4 = <span class="hljs-keyword">new</span> BufferedStream(s2);&#125;</code></pre></div><p>新的类关系</p><img src="image-20200807143823919.png" srcset="/img/loading.gif" alt="image-20200807143823919" style="zoom:30%;" /><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><img src="image-20200807160507597.png" srcset="/img/loading.gif" alt="image-20200807160507597" style="zoom:50%;" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免 了使用继承带来的”灵活性差”和”多子类衍生问题”。</p></li><li><p>Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又 表现为has-a Component的组合关系，即Decorator类又使用了 另外一个Component类。</p></li><li><p>Decorator模式的目的并非解决”多子类衍生的多继承”问题，Decorator模式应用的要点在于解决”主体类在多个方向上的扩展 功能”——是为”装饰”的含义。</p></li></ul><h2 id="Decorator属于单一职责模式"><a href="#Decorator属于单一职责模式" class="headerlink" title="Decorator属于单一职责模式"></a>Decorator属于单一职责模式</h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码， 这时候的关键是划清责任。</p><ul><li><p>典型模式</p><p>• Decorator</p><p>• Bridge</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="/2020/08/06/Principle/"/>
    <url>/2020/08/06/Principle/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>变化是复用的天敌！ 面向对象设计最大的优势在于：<u><strong><em>抵御变化</em></strong></u></p>          </div><h4 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 (DIP)"></a>依赖倒置原则 (DIP)</h4><ul><li><p>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。</p></li><li><p>抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。</p></li></ul><br><h4 id="开放封闭原则-OCP"><a href="#开放封闭原则-OCP" class="headerlink" title="开放封闭原则 (OCP)"></a>开放封闭原则 (OCP)</h4><ul><li><p>对扩展开放，对更改封闭。</p></li><li><p>类模块应该是可扩展的，但是不可修改。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Observer 观察者模式</title>
    <link href="/2020/08/06/DesignPatterns/Observer/"/>
    <url>/2020/08/06/DesignPatterns/Observer/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，我们需要为某些对象建立一种”通知依赖关系” </p><p><u>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密， 将使软件不能很好地抵御变化</u>。</p><p>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>定义对象间的一种<u><strong><em>一对多</em></strong></u>（变化）的依赖关系，以便当一个 对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并<u><strong><em>自动更新</em></strong></u>。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>考虑一个文件分割器程序，将一个大文件分割成几个小文件。</p><p>我们有一个主界面MainForm (在这里是一个观察者), 里面有两个对象，一个是文件路径，一个是分割成的文件都个数。当button click时就会调用filesplitter将文件分割</p><p>代码如下</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;<span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber):    m_filePath(filePath),    m_fileNumber(fileNumber) &#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>        &#125;    &#125;&#125;</code></pre></div><h4 id="需求1：文件分割进度条"><a href="#需求1：文件分割进度条" class="headerlink" title="需求1：文件分割进度条"></a>需求1：文件分割进度条</h4><ul><li>第一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;<span class="hljs-comment">/***增加progress bar***/</span>    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;<span class="hljs-comment">/***增加progres bar***/</span>    ProgressBar* m_progressBar;<span class="hljs-keyword">public</span>:<span class="hljs-comment">/***增加初始化参数***/</span>    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, ProgressBar* progressBar):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_progressBar(progressBar)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span><span class="hljs-comment">/***更新progress bar***/</span>            <span class="hljs-keyword">if</span>(m_progressBar != <span class="hljs-literal">NULL</span>) &#123;                m_progressBar-&gt;setValue((i + <span class="hljs-number">1</span>) / m_fileNumber);            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="note note-warning">            <p>但是这种实现方式违反了<u>依赖倒置原则</u>。FileSplitter依赖ProgressBar 这样一种具体的实现细节，但是进度条的种类和展现形式是变化的，如果我们想将进度条换一种展现形式，比如不断打点，那么就会面临需求变更的困扰。</p>          </div><ul><li>第二种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    <span class="hljs-comment">//ProgressBar* m_progressBar; 这是一个通知控件</span>    IProgress* m_iprogress; <span class="hljs-comment">//抽象通知机制</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, IProgress* iprogress):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_iprogress(iprogress)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">if</span>(m_iprogress != <span class="hljs-literal">NULL</span>) &#123;                <span class="hljs-keyword">float</span> progressValue = m_fileNumber;                progressValue = (i + <span class="hljs-number">1</span>) / progressValue;                m_iprogress-&gt;DoProgress(progressValue); <span class="hljs-comment">//更新进度条</span>            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress&#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressbar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        progressBar-&gt;setValue(value);    &#125;&#125;</code></pre></div><p>C++支持多继承，但是不推荐使用多继承，因为会带来很多耦合的问题。但是有一种情况是推荐使用多继承的，一个主的继承类，其他都是接口  (单继承多实现), 这里就属于这种情况</p><ul><li>再修改一下</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    <span class="hljs-comment">//ProgressBar* m_progressBar; 这是一个通知控件</span>    IProgress* m_iprogress; <span class="hljs-comment">//抽象通知机制</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, IProgress* iprogress):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_iprogress(iprogress)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">float</span> progressValue = m_fileNumber;            progressValue = (i + <span class="hljs-number">1</span>) / progressValue;            onProgress(progressValue);        &#125;    &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span>(m_iprogress != <span class="hljs-literal">NULL</span>) &#123;        m_iprogress-&gt;DoProgress(value);<span class="hljs-comment">//更新进度条</span>        &#125;    &#125;&#125;</code></pre></div><h4 id="需求2-多观察者"><a href="#需求2-多观察者" class="headerlink" title="需求2: 多观察者"></a>需求2: 多观察者</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    List&lt;IProgress*&gt; m_iprogressList; <span class="hljs-comment">//抽象通知机制, 支持多个观察者</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber):    m_filePath(filePath),    m_fileNumber(fileNumber) &#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIProgress</span><span class="hljs-params">(IProgress* iprogress)</span> </span>&#123;        m_iprogressList.add(iprogress);    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeIProgress</span><span class="hljs-params">(IProgress* iprogress)</span> </span>&#123;        m_iprogressList.remove(iprogress);    &#125;            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">float</span> progressValue = m_fileNumber;            progressValue = (i + <span class="hljs-number">1</span>) / progressValue;            onProgress(progressValue);        &#125;    &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        List&lt;IProgress*&gt;::iterator it = m_iprogressList.begin();        <span class="hljs-keyword">while</span>(it != m_iprogressList.end()) &#123;            (*it)-&gt;DoProgress(value);            it++;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress&#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressbar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                ConsoleNotifier cn;        <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;                splitter.addIprogress(<span class="hljs-keyword">this</span>);        splitter.addIprogress(&amp;cn);                splitter.split();    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        progressBar-&gt;setValue(value);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleNotifier</span>:</span> <span class="hljs-keyword">public</span> IProgress &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"."</span>;    &#125;&#125;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><img src="image-20200806160700160.png" srcset="/img/loading.gif" alt="image-20200806160700160" style="zoom: 50%;" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。 </p></li><li><p>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。</p></li><li><p>观察者自己决定是否需要订阅通知，目标对象对此一无所知。 </p></li><li><p>Observer模式是基于事件的UI框架中非常常用的设计模式，也是 MVC模式的一个重要组成部分。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Template Method</title>
    <link href="/2020/08/05/DesignPatterns/TemplateMethod/"/>
    <url>/2020/08/05/DesignPatterns/TemplateMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因 （比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p><p>核心在于在稳定与变化之间求得一个平衡，如果全部稳定或者全部变化都是不需要设计模式的。</p><p>如何在确定<strong>稳定操作结构</strong>的前提下，来灵活应对<strong>各个子步骤的变化</strong>或者<strong>晚期实现需求</strong>？</p><p>假设整个代码的操作结构如下图所示，其中红色是Library开发人员完成的，蓝色部分是Application开发人员完成的</p><img src="image-20200710191024075.png" srcset="/img/loading.gif" alt="image-20200710191024075" style="zoom:33%;" /><h2 id="结构化软件流程设计"><a href="#结构化软件流程设计" class="headerlink" title="结构化软件流程设计"></a>结构化软件流程设计</h2><img src="image-20200710191212499.png" srcset="/img/loading.gif" alt="image-20200710191212499" style="zoom:50%;" /><p>lib.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>app.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//应用程序开发人员</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>主程序</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Library <span class="hljs-title">lib</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Application <span class="hljs-title">app</span><span class="hljs-params">()</span></span>;        lib.Step1();        <span class="hljs-keyword">if</span>(app.Step2()) &#123;        lib.Step3();    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;        app.Step4();    &#125;    lib.Step5();&#125;</code></pre></div><h2 id="用模板方法的代码重构为"><a href="#用模板方法的代码重构为" class="headerlink" title="用模板方法的代码重构为"></a>用模板方法的代码重构为</h2><img src="image-20200710191917988.png" srcset="/img/loading.gif" alt="image-20200710191917988" style="zoom:50%;" /><p>lib.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span> </span>&#123;        Step1();        <span class="hljs-keyword">if</span>(Step2()) &#123;            Step3();        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            Step4();        &#125;        Step5();    &#125;        <span class="hljs-keyword">virtual</span> ~Library() &#123;&#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>&#125;</code></pre></div><p>app.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//应用程序开发人员</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span>:</span> <span class="hljs-keyword">public</span> Library &#123;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;;</code></pre></div><p>主程序</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Library* pLib = <span class="hljs-keyword">new</span> Application();    lib.Run();    <span class="hljs-keyword">delete</span> pLib;&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两者的区别在于早绑定和晚绑定。前者属于早绑定，而template method属于晚绑定</p><img src="image-20200710192039991.png" srcset="/img/loading.gif" alt="image-20200710192039991" style="zoom:50%;" /><p>定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟 (变化)到子类中。Template Method使得子类可以不改变 (复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。</p>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Strategy Method</title>
    <link href="/2020/08/05/DesignPatterns/StrategyMethod/"/>
    <url>/2020/08/05/DesignPatterns/StrategyMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂； 而且有时候支持不使用的算法也是一个性能负担</p><p>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</p><h2 id="Strategy-Method定义"><a href="#Strategy-Method定义" class="headerlink" title="Strategy Method定义"></a>Strategy Method定义</h2><p>定义一系列算法，把它们一个个封装起来，并且使它们可互 相替换（变化）。该模式使得算法可独立于使用它的客户程 序(稳定)而变化（扩展，子类化）。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>考虑一下计算税的例子</p><ul><li>第一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> TaxBase &#123;    CN_Tax,    US_Tax,    DE_Tax&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span>    TaxBase tax;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>                <span class="hljs-keyword">if</span>(tax == CN_Tax) &#123;            <span class="hljs-comment">//CN*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == US_Tax) &#123;            <span class="hljs-comment">//US*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == DE_Tax) &#123;            <span class="hljs-comment">//DE*****</span>        &#125;        <span class="hljs-comment">//***</span>    &#125;&#125;</code></pre></div><p>有些时候，静态地去观察是看不出来的，加入时间轴，考虑到未来的动态变化，问题就会暴露出来。考虑上述例子，如果要加入一个国家，比如法国，那么我们不仅要在<code>TaxBase</code>中中增加一个<code>FR_Tax</code>, 还需要在<code>SalesOrder</code>中增加判断语句。这样的更改违背了开闭原则： 对扩展开放，对修改封闭 (避免去修改源代码</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> TaxBase &#123;    CN_Tax,    US_Tax,    DE_Tax,    <span class="hljs-comment">/***加入France***/</span>    FR_Tax,&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span>    TaxBase tax;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>                <span class="hljs-keyword">if</span>(tax == CN_Tax) &#123;            <span class="hljs-comment">//CN*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == US_Tax) &#123;            <span class="hljs-comment">//US*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == DE_Tax) &#123;            <span class="hljs-comment">//DE*****</span>        &#125;        <span class="hljs-comment">/***加入France***/</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == FR_Tax) &#123;                  &#125;        <span class="hljs-comment">//***</span>    &#125;&#125;</code></pre></div><ul><li>考虑另一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxStrategy</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~TaxStrategy() &#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DETax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span><span class="hljs-keyword">private</span>:    TaxStrategy* strategy;<span class="hljs-keyword">public</span>:    SalesOrder(StrategyFactory* strategyFactory) &#123;        <span class="hljs-keyword">this</span>-&gt;strategy = strategyFactory-&gt;NewStrategy();    &#125;        ~SalesOrder() &#123;        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>        <span class="hljs-function">Context <span class="hljs-title">context</span><span class="hljs-params">()</span></span>;                <span class="hljs-keyword">double</span> val =             srtategy-&gt;Calculate(context);<span class="hljs-comment">//多态调用</span>    &#125;&#125;</code></pre></div><p>如果要增加法国，只需增加一个<code>FRTax</code>类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> doubel <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>这是一种扩展的做法，在这里只需要增加一个FRTax类，不需要更改SalesOrder。</p><p>复用性一般是指二进制层面下的复用性，如果使用第一种方法，那么整个系统需要重新编译，重新测试。虽然修改后保留了一部分原来的代码，但是这个并不是复用。而策略方法不需要重新编译之前编译好的文件，只需要重新编译FRTax这个文件</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200805135526277.png" srcset="/img/loading.gif" alt="image-20200805135526277"> </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使 得类型在运行时方便地根据需要在各个算法之间进行切换。</p></li><li><p>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件 判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需 要Strategy模式。</p></li><li><p>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
