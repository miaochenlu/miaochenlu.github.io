<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>System calls [os lab2]</title>
    <link href="/2020/12/16/xv6-lab2/"/>
    <url>/2020/12/16/xv6-lab2/</url>
    
    <content type="html"><![CDATA[<p>system call的相关代码<br>user-space code: <code>user/user.h</code> , <code>user/user.pl</code><br>kernel-space code: <code>kernel/syscall.h</code> , <code>kernal/syscall.c</code><br>process-related code: <code>kernel/proc.h</code> , <code>kernel/proc.c</code> </p><p>先switch git branch到sycall</p><div class="hljs"><pre><code class="hljs bash">git fetchgit checkout syscallmake clean</code></pre></div><h1 id="1-System-call-tracing"><a href="#1-System-call-tracing" class="headerlink" title="1. System call tracing"></a>1. System call tracing</h1><div class="note note-primary">            <p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new <code>trace</code> system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>, where <code>SYS_fork</code> is a syscall number from <code>kernel/syscall.h</code>. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p>          </div><p>这个任务会增加一个system call tracing的feature。我们需要创建一个新的system call <code>trace</code> 来控制tracing。他需要接收一个参数，一个整数”mask”，代表了需要trace的system calls。</p><p>Example: </p><div class="hljs"><pre><code class="hljs bash">$ trace 32 grep hello README3: syscall <span class="hljs-built_in">read</span> -&gt; 10233: syscall <span class="hljs-built_in">read</span> -&gt; 9663: syscall <span class="hljs-built_in">read</span> -&gt; 703: syscall <span class="hljs-built_in">read</span> -&gt; 0$$ trace 2147483647 grep hello README4: syscall trace -&gt; 04: syscall <span class="hljs-built_in">exec</span> -&gt; 34: syscall open -&gt; 34: syscall <span class="hljs-built_in">read</span> -&gt; 10234: syscall <span class="hljs-built_in">read</span> -&gt; 9664: syscall <span class="hljs-built_in">read</span> -&gt; 704: syscall <span class="hljs-built_in">read</span> -&gt; 04: syscall close -&gt; 0$$ grep hello README$$ trace 2 usertests forkforkforkusertests starting<span class="hljs-built_in">test</span> forkforkfork: 407: syscall fork -&gt; 408408: syscall fork -&gt; 409409: syscall fork -&gt; 410410: syscall fork -&gt; 411409: syscall fork -&gt; 412410: syscall fork -&gt; 413409: syscall fork -&gt; 414411: syscall fork -&gt; 415...$</code></pre></div><p>In the first example above, trace invokes grep tracing just the read system call. The 32 is <code>1&lt;&lt;SYS_read</code> </p><p>In the second example, trace runs grep while tracing all system calls; the 2147583647 has all 31 low bits set. </p><p>In the third example, the program isn’t traced, so no trace output is printed. In the fourth example, the fork system calls of all the descendants of the <code>forkforkfork</code> test in <code>usertests</code> are being traced. </p><p>Your solution is correct if your program behaves as shown above (though the process IDs may be different).</p><h2 id="Some-hints"><a href="#Some-hints" class="headerlink" title="Some hints"></a>Some hints</h2><div class="note note-success">            <ul><li>Add <code>$U/_trace</code> to UPROGS in Makefile</li></ul>          </div><p><img src="Untitled.png" srcset="/img/loading.gif" alt="Lab2%20System%20calls%203e297d6823c44cf89443d35be3f382cf/Untitled.png" style="zoom:50%;" /></p><div class="note note-success">            <ul><li>Run <strong><code>make qemu</code></strong> and you will see that the compiler cannot compile <code>user/trace.c</code></li></ul>          </div><p><img src="Untitled%201.png" srcset="/img/loading.gif" alt="Lab2%20System%20calls%203e297d6823c44cf89443d35be3f382cf/Untitled%201.png" style="zoom:50%;" /></p><p>This is because the user-space stubs for the system call don’t exist yet: </p><div class="note note-success">            <ul><li>add a prototype for the system call to <code>user/user.h</code> , a stub to <code>user/usys.pl</code>,  a syscall number to <code>kernel/syscall.h</code></li></ul>          </div><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="Untitled%202.png" srcset="/img/loading.gif" alt="pic1"></div><div class="group-image-wrap"><img src="Untitled%203.png" srcset="/img/loading.gif" alt="pic1"></div><div class="group-image-wrap"><img src="Untitled%204.png" srcset="/img/loading.gif" alt="pic1"></div></div></div><p>The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V ecall instruction to transition to the kernel.</p><p>将<code>SYS_trace</code>这个syscall number放入寄存器<code>a7</code>, 然后<code>ecall</code>进入kernel mode</p><div class="hljs"><pre><code class="hljs assembly">.global tracetrace: li a7, SYS_trace ecall ret</code></pre></div><p> Once you fix the compilation issues, run <strong>trace 32 grep hello README</strong>; it will fail because you haven’t implemented the system call in the kernel yet.</p><p><img src="Untitled%205.png" srcset="/img/loading.gif" alt="Lab2%20System%20calls%203e297d6823c44cf89443d35be3f382cf/Untitled%205.png" style="zoom: 67%;" /></p><div class="note note-success">            <ul><li>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the proc structure (see <code>kernel/proc.h</code>).</li></ul>          </div><p>在 <code>kernel/proc.h</code> 中的proc结构体中新增一个mask成员变量。</p><p><img src="Untitled%206.png" srcset="/img/loading.gif" alt="Lab2%20System%20calls%203e297d6823c44cf89443d35be3f382cf/Untitled%206.png" style="zoom:50%;" /></p><p>在 <code>kernle/sysproc.c</code> 中增加 <code>sys_trace</code> 函数。The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</p><p>在 <code>syscall.c</code> 中声明 <code>sys_trace</code> 函数，然后在 <code>syscalls</code> 这个函数指针数组中增加 <code>sys_trace</code> 。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="Untitled%207.png" srcset="/img/loading.gif" alt="pic1"></div><div class="group-image-wrap"><img src="Untitled%209.png" srcset="/img/loading.gif" alt="pic1"></div></div></div><p>实现<code>sys_trace</code>函数，首先通过<code>argint</code>获取mask参数，然后将mask参数赋给proc</p><div class="hljs"><pre><code class="hljs c">uintsys_trace(<span class="hljs-keyword">void</span>) &#123;  <span class="hljs-keyword">int</span> trace_mask;  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;trace_mask) &lt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  &#125;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> = <span class="hljs-title">myproc</span>();</span>  p-&gt;mask = trace_mask;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="note note-success">            <ul><li>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</li></ul>          </div><p>在<code>fork</code>函数中增加一行copy mask的代码</p><div class="hljs"><pre><code class="hljs c">np-&gt;mask = p-&gt;mask;<span class="hljs-comment">//这行是新增的，copy mask</span></code></pre></div>{% note success%}- Modify the `syscall()` function in `kernel/syscall.c` to print the trace output. You will need to add an array of syscall names to index into.{% endnote %}<p>在<code>kernel/syscall.c</code>中增加一个 <code>syscallnames</code> 这个数组，方便打印系统调用的名字</p><p><img src="image-20201216215059739.png" srcset="/img/loading.gif" alt="image-20201216215059739" style="zoom:67%;" /></p><p><code>syscall</code>的代码修改如下: </p><p>如果 <code>(1 &lt;&lt; num) &amp; p-&gt;mask != 0</code>  说明num属于mask trace的系统调用，按照格式打印系统调用内容: pid, syscall name, return value。注意return value存储在<code>a0</code>寄存器中</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">void</span>syscall(<span class="hljs-keyword">void</span>)&#123;  <span class="hljs-keyword">int</span> num;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> = <span class="hljs-title">myproc</span>();</span>  num = p-&gt;trapframe-&gt;a7;  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;    p-&gt;trapframe-&gt;a0 = syscalls[num]();    <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span> &lt;&lt; num) &amp; p-&gt;mask) &#123;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: syscall %s -&gt; %d\n"</span>, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %s: unknown sys call %d\n"</span>,            p-&gt;pid, p-&gt;name, num);    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;  &#125;&#125;</code></pre></div><h1 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h1><div class="note note-primary">            <p>In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see <code>kernel/sysinfo.h</code>). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program <code>sysinfotest</code>; you pass this assignment if it prints “sysinfotest: OK”.</p>          </div><h2 id="Some-hints-1"><a href="#Some-hints-1" class="headerlink" title="Some hints"></a>Some hints</h2><div class="note note-success">            <ul><li>Add <code>$U/_sysinfotest</code> to <code>UPROGS</code> in Makefile</li></ul>          </div><p><img src="Untitled%2010.png" srcset="/img/loading.gif" alt="Lab2%20System%20calls%203e297d6823c44cf89443d35be3f382cf/Untitled%2010.png" style="zoom:67%;" /></p><div class="note note-success">            <ul><li>Run <strong>make qemu</strong>; <code>user/sysinfotest.c</code> will fail to compile. Add the system call <code>sysinfo</code>, following the same steps as in the previous assignment. To declare the prototype for <code>sysinfo()</code> in <code>user/user.h</code> you need predeclare the existence of struct sysinfo:</li></ul>          </div><div class="hljs"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span>;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sysinfo</span><span class="hljs-params">(struct sysinfo *)</span></span>;</code></pre></div><p>在 <code>user/user.h</code> 中声明 <code>sysinfo</code> 函数, 在 <code>user/usys.pl</code> 中增加 <code>sysinfo</code> entry, 在 <code>kernel/syscall.h</code> 中定义 <code>sysinfo</code> 的系统调用号为23</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="Untitled%2011.png" srcset="/img/loading.gif" alt="pic1"></div><div class="group-image-wrap"><img src="Untitled%2012.png" srcset="/img/loading.gif" alt="pic1"></div><div class="group-image-wrap"><img src="Untitled%2013.png" srcset="/img/loading.gif" alt="pic1"></div></div></div><p>在 <code>kernel/syscall.c</code> 中修改如下三处信息</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="Untitled%2014.png" srcset="/img/loading.gif" alt="pic1"></div><div class="group-image-wrap"><img src="Untitled%2015.png" srcset="/img/loading.gif" alt="pic1"></div><div class="group-image-wrap"><img src="image-20201216215156011.png" srcset="/img/loading.gif" alt="pic1"></div></div></div><div class="note note-success">            <ul><li><code>sysinfo</code> needs to copy a struct sysinfo back to user space; see <code>sys_fstat()</code> ( <code>kernel/sysfile.c</code>) and <code>filestat()</code> ( <code>kernel/file.c</code>) for examples of how to do that using <code>copyout()</code>.  To collect the amount of free memory, add a function to <code>kernel/kalloc.c</code>。 To collect the number of processes, add a function to <code>kernel/proc.c</code></li></ul>          </div><p><img src="Untitled%2017.png" srcset="/img/loading.gif" alt="Lab2%20System%20calls%203e297d6823c44cf89443d35be3f382cf/Untitled%2017.png" style="zoom:67%;" /></p><p>其中两个函数 <code>nfree()</code> , <code>nproc()</code> 函数需要我们自己定义</p><p><code>nfree()</code> 函数用来获取空闲内存的数量，以byte为单位返回。定义在 <code>kernel/kalloc.c</code> 中</p><p><code>nproc()</code> 函数返回非 <code>UNUSED</code> state的进程数量。定义在 <code>kernel/proc.c</code> 中</p><p><code>nfree()</code>的实现参考<code>kernel/kalloc.c/kalloc()</code>的代码，如下</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">void</span> *kalloc(<span class="hljs-keyword">void</span>)&#123;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span>  acquire(&amp;kmem.lock);  r = kmem.freelist;  <span class="hljs-keyword">if</span>(r)    kmem.freelist = r-&gt;next;  <span class="hljs-built_in">release</span>(&amp;kmem.lock);  <span class="hljs-keyword">if</span>(r)    <span class="hljs-built_in">memset</span>((<span class="hljs-keyword">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span>*)r;&#125;</code></pre></div><p><code>nproc()</code>的实现参考<code>kernel/proc.c/procdump()</code>的代码，如下</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;  <span class="hljs-keyword">if</span>(p-&gt;state == UNUSED)    <span class="hljs-keyword">continue</span>;  <span class="hljs-keyword">if</span>(p-&gt;state &gt;= <span class="hljs-number">0</span> &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state])    state = states[p-&gt;state];  <span class="hljs-keyword">else</span>    state = <span class="hljs-string">"???"</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %s %s"</span>, p-&gt;pid, state, p-&gt;name);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;</code></pre></div><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="Untitled%2018.png" srcset="/img/loading.gif" alt="pic1"></div><div class="group-image-wrap"><img src="Untitled%2019.png" srcset="/img/loading.gif" alt="pic1"></div></div></div><p>为了使用这两个函数和 <code>sysinfo</code> 这个结构体，还需要在 <code>kernel/defs.h</code> 中声明函数。然后在 <code>kernel/sysproc.c</code> 中 <code>#include &quot;sysinfo.h</code> 引入结构体信息，</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="Untitled%2020.png" srcset="/img/loading.gif" alt="pic1"></div><div class="group-image-wrap"><img src="Untitled%2021.png" srcset="/img/loading.gif" alt="pic1"></div><div class="group-image-wrap"><img src="image-20201216215452048.png" srcset="/img/loading.gif" alt="pic1"></div></div></div>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>启动xv6创建第一个进程</title>
    <link href="/2020/12/07/startXv6/"/>
    <url>/2020/12/07/startXv6/</url>
    
    <content type="html"><![CDATA[<h1 id="Xv6启动过程"><a href="#Xv6启动过程" class="headerlink" title="Xv6启动过程"></a>Xv6启动过程</h1><ul><li><p>xv6通电后先完成初始化</p></li><li><p>运行存储在ROM中的boot loader</p></li><li><p>boot loader将xv6 kernel加载到memory中。kernel被加载到0x80000000处，之所以不加载到0x0处是因为在0x0:0x80000000之间包含了I/O设备。（此时分页硬件被disable了，虚拟地址直接对应物理地址)</p></li><li><p>在machine mode下，CPU从<code>_entry</code>(<code>kernel/entry.S:6</code>)开始执行xv6。<code>_entry</code>的作用是为C代码的运行指定栈。在<code>start.c</code>中, xv6声明了初始stack的空间<code>stack0</code>。<code>_entry</code>中的代码将地址<code>stack0+4096</code>加载到stack pointer register <code>sp</code>，也就是栈顶的地址。</p></li></ul><div class="hljs"><pre><code class="hljs assembly"># qemu -kernel loads the kernel at 0x80000000        # and causes each CPU to jump there.        # kernel.ld causes the following code to        # be placed at 0x80000000..section .text_entry:# set up a stack for C.        # stack0 is declared in start.c,        # with a 4096-byte stack per CPU.        # sp &#x3D; stack0 + (hartid * 4096)        la sp, stack0        li a0, 1024*4csrr a1, mhartid        addi a1, a1, 1        mul a0, a0, a1        add sp, sp, a0# jump to start() in start.c        call startspin:        j spin</code></pre></div><ul><li>接着，<code>_entry</code>跳转到<code>start</code>的C代码。<code>start</code>做了一些只能在machine mode下做的配置。他还初始化计时器中断。接着，他切换到supervisor mode。为了转换到supervisor mode, RISCV提供了<code>mret</code>指令。这个指令通常是用来从一个之前supervisor mode转换到machine mode的调用返回。但<code>start</code>并没有从一个这样的调用返回，他假装自己从这样的一个调用返回。他在register <code>mstatus</code>中将之前的privilege mode设置为supervisor mode，在register <code>mepc</code>中将main的地址设置为返回的地址，在page-table register <code>satp</code>中写入0来disable虚拟地址转换，并且将所有的interrupts和exceptions授权给supervisor mode</li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"types.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"param.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"memlayout.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"riscv.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"defs.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">timerinit</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// entry.S needs one stack per CPU.</span>__attribute__ ((aligned (<span class="hljs-number">16</span>))) <span class="hljs-keyword">char</span> stack0[<span class="hljs-number">4096</span> * NCPU];<span class="hljs-comment">// scratch area for timer interrupt, one per CPU.</span>uint64 mscratch0[NCPU * <span class="hljs-number">32</span>];<span class="hljs-comment">// assembly code in kernelvec.S for machine-mode timer interrupt.</span><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">timervec</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// entry.S jumps here in machine mode on stack0.</span><span class="hljs-keyword">void</span>start()&#123;  <span class="hljs-comment">// set M Previous Privilege mode to Supervisor, for mret.</span>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> x = r_mstatus();  x &amp;= ~MSTATUS_MPP_MASK;  x |= MSTATUS_MPP_S;  w_mstatus(x);  <span class="hljs-comment">// set M Exception Program Counter to main, for mret.</span>  <span class="hljs-comment">// requires gcc -mcmodel=medany</span>  w_mepc((uint64)main);  <span class="hljs-comment">// disable paging for now.</span>  w_satp(<span class="hljs-number">0</span>);  <span class="hljs-comment">// delegate all interrupts and exceptions to supervisor mode.</span>  w_medeleg(<span class="hljs-number">0xffff</span>);  w_mideleg(<span class="hljs-number">0xffff</span>);  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);  <span class="hljs-comment">// ask for clock interrupts.</span>  timerinit();  <span class="hljs-comment">// keep each CPU's hartid in its tp register, for cpuid().</span>  <span class="hljs-keyword">int</span> id = r_mhartid();  w_tp(id);  <span class="hljs-comment">// switch to supervisor mode and jump to main().</span>  <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">"mret"</span>)</span></span>;&#125;<span class="hljs-comment">// set up to receive timer interrupts in machine mode,</span><span class="hljs-comment">// which arrive at timervec in kernelvec.S,</span><span class="hljs-comment">// which turns them into software interrupts for</span><span class="hljs-comment">// devintr() in trap.c.</span><span class="hljs-keyword">void</span>timerinit()&#123;  <span class="hljs-comment">// each CPU has a separate source of timer interrupts.</span>  <span class="hljs-keyword">int</span> id = r_mhartid();  <span class="hljs-comment">// ask the CLINT for a timer interrupt.</span>  <span class="hljs-keyword">int</span> interval = <span class="hljs-number">1000000</span>; <span class="hljs-comment">// cycles; about 1/10th second in qemu.</span>  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;  <span class="hljs-comment">// prepare information in scratch[] for timervec.</span>  <span class="hljs-comment">// scratch[0..3] : space for timervec to save registers.</span>  <span class="hljs-comment">// scratch[4] : address of CLINT MTIMECMP register.</span>  <span class="hljs-comment">// scratch[5] : desired interval (in cycles) between timer interrupts.</span>  uint64 *scratch = &amp;mscratch0[<span class="hljs-number">32</span> * id];  scratch[<span class="hljs-number">4</span>] = CLINT_MTIMECMP(id);  scratch[<span class="hljs-number">5</span>] = interval;  w_mscratch((uint64)scratch);  <span class="hljs-comment">// set the machine-mode trap handler.</span>  w_mtvec((uint64)timervec);  <span class="hljs-comment">// enable machine-mode interrupts.</span>  w_mstatus(r_mstatus() | MSTATUS_MIE);  <span class="hljs-comment">// enable machine-mode timer interrupts.</span>  w_mie(r_mie() | MIE_MTIE);&#125;</code></pre></div><ul><li>调用<code>mret</code>后，program counter切到<code>main</code> (<code>kernel/main.c:11</code>), 在supervisor mode在运行。</li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"types.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"param.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"memlayout.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"riscv.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"defs.h"</span></span><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> started = <span class="hljs-number">0</span>;<span class="hljs-comment">// start() jumps here in supervisor mode on all CPUs.</span><span class="hljs-keyword">void</span>main()&#123;  <span class="hljs-keyword">if</span>(cpuid() == <span class="hljs-number">0</span>)&#123;    consoleinit();    printfinit();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"xv6 kernel is booting\n"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    kinit();         <span class="hljs-comment">// physical page allocator</span>    kvminit();       <span class="hljs-comment">// create kernel page table</span>    kvminithart();   <span class="hljs-comment">// turn on paging</span>    procinit();      <span class="hljs-comment">// process table</span>    trapinit();      <span class="hljs-comment">// trap vectors</span>    trapinithart();  <span class="hljs-comment">// install kernel trap vector</span>    plicinit();      <span class="hljs-comment">// set up interrupt controller</span>    plicinithart();  <span class="hljs-comment">// ask PLIC for device interrupts</span>    binit();         <span class="hljs-comment">// buffer cache</span>    iinit();         <span class="hljs-comment">// inode cache</span>    fileinit();      <span class="hljs-comment">// file table</span>    virtio_disk_init(); <span class="hljs-comment">// emulated hard disk</span>    userinit();      <span class="hljs-comment">// first user process</span>    __sync_synchronize();    started = <span class="hljs-number">1</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">while</span>(started == <span class="hljs-number">0</span>)      ;    __sync_synchronize();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hart %d starting\n"</span>, cpuid());    kvminithart();    <span class="hljs-comment">// turn on paging</span>    trapinithart();   <span class="hljs-comment">// install kernel trap vector</span>    plicinithart();   <span class="hljs-comment">// ask PLIC for device interrupts</span>  &#125;  scheduler();        &#125;</code></pre></div><ul><li><code>main</code>初始化了一些设备和子系统，通过调用<code>userint</code>(<code>kernel/proc.c:212</code>)创建了第一个process</li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">// a user program that calls exec("/init")</span><span class="hljs-comment">// od -t xC initcode</span>uchar initcode[] = &#123;  <span class="hljs-number">0x17</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x02</span>,  <span class="hljs-number">0x97</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0x02</span>,  <span class="hljs-number">0x93</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,  <span class="hljs-number">0x93</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,  <span class="hljs-number">0xef</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0x9f</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0x2f</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x69</span>,  <span class="hljs-number">0x74</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>&#125;;<span class="hljs-comment">// Set up first user process.</span><span class="hljs-keyword">void</span>userinit(<span class="hljs-keyword">void</span>)&#123;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>  p = allocproc();  initproc = p;    <span class="hljs-comment">// allocate one user page and copy init's instructions</span>  <span class="hljs-comment">// and data into it.</span>  uvminit(p-&gt;pagetable, initcode, <span class="hljs-keyword">sizeof</span>(initcode));  p-&gt;sz = PGSIZE;  <span class="hljs-comment">// prepare for the very first "return" from kernel to user.</span>  p-&gt;trapframe-&gt;epc = <span class="hljs-number">0</span>;      <span class="hljs-comment">// user program counter</span>  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="hljs-comment">// user stack pointer</span>  safestrcpy(p-&gt;name, <span class="hljs-string">"initcode"</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;name));  p-&gt;cwd = namei(<span class="hljs-string">"/"</span>);  p-&gt;state = RUNNABLE;  <span class="hljs-built_in">release</span>(&amp;p-&gt;lock);&#125;</code></pre></div><ul><li>第一个进程执行了一个用RISC-V汇编写到小程序<code>initcode.S</code> (<code>user/initcode.S:1</code>)。他通过系统调用<code>exec</code>重新进入kernel。<code>exec</code>执行了一个新的程序<code>/init</code>。<code>/init</code>创建了一个控制台设备文件，并作为文件描述符0，1，2来打开它。然后在无限循环中，启动shell并处理僵尸进程。系统就这样启动了。</li></ul><div class="hljs"><pre><code class="hljs assembly"># Initial process that execs &#x2F;init.# This code runs in user space.#include &quot;syscall.h&quot;# exec(init, argv).globl startstart:        la a0, init        la a1, argv        li a7, SYS_exec        ecall# for(;;) exit();exit:        li a7, SYS_exit        ecall        jal exit# char init[] &#x3D; &quot;&#x2F;init\0&quot;;init:  .string &quot;&#x2F;init\0&quot;# char *argv[] &#x3D; &#123; init, 0 &#125;;.p2align 2argv:  .long init  .long 0</code></pre></div><h1 id="GDB-管中窥豹"><a href="#GDB-管中窥豹" class="headerlink" title="GDB - 管中窥豹"></a>GDB - 管中窥豹</h1><p>首先，启动QEMU，并打开gdb。本质上来说QEMU内部有一个gdb server，启动之后，QEMU会等待gdb客户端连接。然后在计算机上再启动一个gdb客户端</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="image-20201207213216980.png" srcset="/img/loading.gif" alt="pic1"></div><div class="group-image-wrap"><img src="image-20201207213311003.png" srcset="/img/loading.gif" alt="pic1"></div></div></div><p><code>b _entry</code>在程序的入口处设置一个断点。</p><p><img src="image-20201207214718702.png" srcset="/img/loading.gif" alt="image-20201207214718702" style="zoom:80%;" /></p><p>程序的起始位置应该是0x80000000, 但事实上，这里的breakpoint设置在了0x8000000a</p><p><code>c</code> 运行程序，停在了0x8000000a, 此处的指令为<code>csrr a1, mhartid</code>, 这条指令读取了控制系统寄存器（Control System Register）<code>mhartid</code>，并将结果加载到<code>a1</code>寄存器。QEMU会模拟执行这条指令，之后执行下一条指令。</p><p><img src="image-20201207215026892.png" srcset="/img/loading.gif" alt="image-20201207215026892" style="zoom:80%;" /></p><p>XV6从<code>entry.s</code>开始启动，运行在machine mode下，这个时候没有内存分页，没有隔离性。XV6运行<code>start.c</code>后切换到supervisor mode, 然后准备运行<code>main.c</code>。我们在main函数设置一个断点，main函数已经运行在supervisor mode了。接下来运行程序，程序会在main函数的第一条指令停住。</p><p><img src="image-20201207215406013.png" srcset="/img/loading.gif" alt="image-20201207215406013" style="zoom:80%;" /></p><p>接下来，输入<code>layout split</code>在gdb的layout split模式下运行，从这个视图可以看出gdb要执行的下一条指令是什么，断点具体在什么位置。</p><p><img src="image-20201207215518155.png" srcset="/img/loading.gif" alt="image-20201207215518155" style="zoom:80%;" /></p><p>这里只在一个CPU上运行QEMU（见最初的make参数），这样会使得gdb调试更加简单。因为现在只指定了一个CPU核，QEMU只会仿真一个核，可以单步执行程序（因为在单核或者单线程场景下，单个断点就可以停止整个程序的运行）</p><p>在gdb中输入n，可以执行到下一条指令。这里调用了一个名为consoleinit的函数，他的功能是设置好console。一旦console设置好了，接下来可以向console打印输出（代码16、17行）。执行完16、17行之后，可以在QEMU看到相应的输出。</p><p><img src="image-20201207215718648.png" srcset="/img/loading.gif" alt="image-20201207215718648" style="zoom:80%;" /></p><p>除了console之外，还有许多代码来做初始化</p><ul><li><code>kinit</code>：设置好页表分配器（page allocator）</li><li><code>kvminit</code>：设置好虚拟内存</li><li><code>kvminithart</code>：打开页表</li><li><code>processinit</code>：设置好初始进程或者说设置好进程表单</li><li><code>trapinit/trapinithart</code>：设置好user/kernel mode转换代码</li><li><code>plicinit/plicinithart</code>：设置好中断控制器PLIC（Platform Level Interrupt Controller），我们后面在介绍中断的时候会详细的介绍这部分，这是我们用来与磁盘和console交互方式</li><li><code>binit</code>：分配buffer cache</li><li><code>iinit</code>：初始化inode缓存</li><li><code>fileinit</code>：初始化文件系统</li><li><code>virtio_disk_init</code>：初始化磁盘</li><li><code>userinit</code>：最后当所有的设置都完成了，操作系统也运行起来了，会通过userinit运行第一个进程，这里有点意思，接下来我们看一下userinit</li></ul><p><code>userinit</code>函数启动了一个进程，调用<code>exec</code>系统调用运行了一个小程序 (定义在<code>initcode</code>数组中，左边所示，对应的汇编程序如右边所示)</p><p><img src="image-20201207220205114.png" srcset="/img/loading.gif" alt="image-20201207220205114" style="zoom:80%;" /></p><p>这个汇编程序中，它首先将init中的内容的指针加载到<code>a0</code>（<code>la a0, init</code>），<code>argv</code>中的地址加载到<code>a1</code>（<code>la a1, argv</code>），<code>exec</code>系统调用对应的数字加载到<code>a7</code>（<code>li a7, SYS_exec</code>），最后调用<code>ECALL。</code>所以这里执行了3条指令，之后在第4条指令将控制权交给了操作系统。</p><p>如果在syscall中设置一个断点，</p><p><img src="image-20201207220443312.png" srcset="/img/loading.gif" alt="image-20201207220443312" style="zoom:80%;" /></p><p>并让程序运行起来。<code>userinit</code>会创建初始进程，返回到用户空间，执行刚刚介绍的3条指令，再回到内核空间。这里是任何XV6用户会使用到的第一个系统调用。</p><p>通过在gdb中执行c，让程序运行起来，我们现在进入到了syscall函数。</p><p><img src="image-20201207220543719.png" srcset="/img/loading.gif" alt="image-20201207220543719" style="zoom:80%;" /></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">void</span>syscall(<span class="hljs-keyword">void</span>)&#123;  <span class="hljs-keyword">int</span> num;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> = <span class="hljs-title">myproc</span>();</span>  num = p-&gt;trapframe-&gt;a7;  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;    p-&gt;trapframe-&gt;a0 = syscalls[num]();  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %s: unknown sys call %d\n"</span>,            p-&gt;pid, p-&gt;name, num);    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;  &#125;&#125;</code></pre></div><p><code>num = p-&gt;trapframe-&gt;a7</code> 会读取使用的系统调用对应的整数。当代码执行完这一行之后，我们可以在gdb中打印num，可以看到是7</p><p><img src="image-20201207220710342.png" srcset="/img/loading.gif" alt="image-20201207220710342" style="zoom:80%;" /></p><p>如果我们查看<code>syscall.h</code>，可以看到7对应的是<code>exec</code>这个系统调用。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">// System call numbers</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_fork    1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_exit    2</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_wait    3</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_pipe    4</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_read    5</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_kill    6</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_exec    7</span>...</code></pre></div><p>所以，这里本质上是告诉内核，某个用户应用程序执行了<code>ECALL</code>指令，并且想要调用<code>exec</code>系统调用。</p><p><code>p-&gt;trapframe-&gt;a0 = syscall[num]()</code> 这一行是实际执行系统调用。这里可以看出，num用来索引一个数组，这个数组是一个函数指针数组，可以预期的是 <code>syscall[7]</code>对应了<code>exec</code>的入口函数。</p><p>跳到<code>sys_exec</code>函数中</p><p><img src="image-20201207220847640.png" srcset="/img/loading.gif" alt="image-20201207220847640" style="zoom:80%;" /></p><p><code>sys_exec</code>中的第一件事情是从用户空间读取参数，它会读取path，也就是要执行程序的文件名。这里首先会为参数分配空间，然后从用户空间将参数拷贝到内核空间。之后我们打印path，</p><p><img src="image-20201207220950356.png" srcset="/img/loading.gif" alt="image-20201207220950356" style="zoom:80%;" /></p><p>可以看到传入的就是<code>init</code>程序。所以，综合来看，<code>initcode</code>完成了通过<code>exec</code>调用<code>init</code>程序。</p><p>再来看<code>init</code>程序，</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">// init: The initial user-level program</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/types.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/stat.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/spinlock.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/sleeplock.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/fs.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/file.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"user/user.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/fcntl.h"</span></span><span class="hljs-keyword">char</span> *argv[] = &#123; <span class="hljs-string">"sh"</span>, <span class="hljs-number">0</span> &#125;;<span class="hljs-keyword">int</span>main(<span class="hljs-keyword">void</span>)&#123;  <span class="hljs-keyword">int</span> pid, wpid;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">open</span>(<span class="hljs-string">"console"</span>, O_RDWR) &lt; <span class="hljs-number">0</span>)&#123;    mknod(<span class="hljs-string">"console"</span>, CONSOLE, <span class="hljs-number">0</span>);    <span class="hljs-built_in">open</span>(<span class="hljs-string">"console"</span>, O_RDWR);  &#125;  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stdout</span>  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stderr</span>  <span class="hljs-keyword">for</span>(;;)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"init: starting sh\n"</span>);    pid = fork();    <span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>)&#123;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"init: fork failed\n"</span>);      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;      exec(<span class="hljs-string">"sh"</span>, argv);      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"init: exec sh failed\n"</span>);      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">for</span>(;;)&#123;      <span class="hljs-comment">// this call to wait() returns if the shell exits,</span>      <span class="hljs-comment">// or if a parentless process exits.</span>      wpid = wait((<span class="hljs-keyword">int</span> *) <span class="hljs-number">0</span>);      <span class="hljs-keyword">if</span>(wpid == pid)&#123;        <span class="hljs-comment">// the shell exited; restart it.</span>        <span class="hljs-keyword">break</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wpid &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"init: wait returned an error\n"</span>);        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// it was a parentless process; do nothing.</span>      &#125;    &#125;  &#125;&#125;</code></pre></div><p><code>init</code>会为用户空间设置好一些东西，比如配置好console，调用<code>fork</code>，并在<code>fork</code>出的子进程中执行shell。</p><p>最终的效果就是Shell运行起来了。如果再次运行代码，还会陷入到<code>syscall</code>中的断点，并且同样也是调用<code>exec</code>系统调用，只是这次是通过<code>exec</code>运行Shell。当Shell运行起来之后，可以从QEMU看到Shell。</p><p><img src="image-20201207221231563.png" srcset="/img/loading.gif" alt="image-20201207221231563" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xv6 and Unix utilities [OS lab1]</title>
    <link href="/2020/12/03/xv6-lab1/"/>
    <url>/2020/12/03/xv6-lab1/</url>
    
    <content type="html"><![CDATA[<p><a href="https://pdos.csail.mit.edu/6.828/2020/labs/util.html" target="_blank" rel="noopener">MIT Lab1: Xv6 and Unix utilities</a></p><h1 id="Find-Some-References"><a href="#Find-Some-References" class="headerlink" title="Find Some References"></a>Find Some References</h1><p><a href="https://www.cnblogs.com/nlp-in-shell/p/11909472.html" target="_blank" rel="noopener">MIT 6.828 - 1. Lab 01: Xv6 and Unix utilities</a></p><p><a href="https://blog.csdn.net/RedemptionC/article/details/106484363?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.channel_param" target="_blank" rel="noopener">MIT-6.s081-OS lab util Unix utilities_RedemptionC的博客-CSDN博客</a></p><p><a href="https://cloud.tencent.com/developer/article/1639599" target="_blank" rel="noopener">MIT6.828实验1 — Lab Utilities</a></p><p><a href="https://github.com/zhayujie/xv6-riscv-fall19/tree/util/user" target="_blank" rel="noopener">zhayujie/xv6-riscv-fall19</a></p><p><a href="https://abcdlsj.github.io/post/mit-6.828-lab1xv6-and-unix-utilities/" target="_blank" rel="noopener">MIT 6.828 Lab 1: Xv6 and Unix utilities * The Real World</a></p><p><a href="https://qinstaunch.github.io/2020/07/04/6-S081-LAB1-Xv6-and-Unix-utilities/" target="_blank" rel="noopener">6.S081-LAB1 Xv6 and Unix utilities</a></p><h1 id="Boot-xv6-easy"><a href="#Boot-xv6-easy" class="headerlink" title="Boot xv6 (easy)"></a>Boot xv6 (easy)</h1><div class="hljs"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020Cloning into <span class="hljs-string">'xv6-labs-2020'</span>......$ <span class="hljs-built_in">cd</span> xv6-labs-2020$ git checkout utilBranch <span class="hljs-string">'util'</span> <span class="hljs-built_in">set</span> up to track remote branch <span class="hljs-string">'util'</span> from <span class="hljs-string">'origin'</span>.Switched to a new branch <span class="hljs-string">'util'</span></code></pre></div><p>Build and run xv6:</p><div class="hljs"><pre><code class="hljs bash">$ make qemuriscv64-unknown-elf-gcc    -c -o kernel/entry.o kernel/entry.Sriscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o kernel/start.o kernel/start.c...  riscv64-unknown-elf-ld -z max-page-size=4096 -N -e main -Ttext 0 -o user/_zombie user/zombie.o user/ulib.o user/usys.o user/printf.o user/umalloc.oriscv64-unknown-elf-objdump -S user/_zombie &gt; user/zombie.asmriscv64-unknown-elf-objdump -t user/_zombie | sed <span class="hljs-string">'1,/SYMBOL TABLE/d; s/ .* / /; /^$/d'</span> &gt; user/zombie.symmkfs/mkfs fs.img README  user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie nmeta 46 (boot, super, <span class="hljs-built_in">log</span> blocks 30 inode blocks 13, bitmap blocks 1) blocks 954 total 1000balloc: first 591 blocks have been allocatedballoc: write bitmap block at sector 45qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="hljs-keyword">if</span>=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0xv6 kernel is bootinghart 2 startinghart 1 startinginit: starting sh$</code></pre></div><p>If you type ls at the prompt, you should see output similar to the following:</p><div class="hljs"><pre><code class="hljs bash">$ ls.              1 1 1024..             1 1 1024README         2 2 2059xargstest.sh   2 3 93cat            2 4 24256<span class="hljs-built_in">echo</span>           2 5 23080forktest       2 6 13272grep           2 7 27560init           2 8 23816<span class="hljs-built_in">kill</span>           2 9 23024ln             2 10 22880ls             2 11 26448mkdir          2 12 23176rm             2 13 23160sh             2 14 41976stressfs       2 15 24016usertests      2 16 148456grind          2 17 38144wc             2 18 25344zombie         2 19 22408console        3 20 0</code></pre></div><p>These are the files that mkfs includes in the initial file system; most are programs you can run. You just ran one of them: ls.</p><p>xv6 has no ps command, but, if you type Ctrl-p, the kernel will print information about each process. If you try it now, you’ll see two lines: one for init, and one for sh.</p><p>To quit qemu type: Ctrl-a x.</p><h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h1><div class="note note-primary">            <p>Implement the UNIX program <code>sleep</code> for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p>          </div><h3 id="Some-hints"><a href="#Some-hints" class="headerlink" title="Some hints:"></a>Some hints:</h3><div class="note note-success">            <ul><li>Before you start coding, read Chapter 1 of the <a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf" target="_blank" rel="noopener">xv6 book</a>. </li></ul>          </div><div class="note note-success">            <ul><li>Look at some of the other programs in  (e.g. <code>user/echo.c</code>, <code>user/grep.c</code>,  <code>user/rm.c</code> ) to see how you can obtain the command-line arguments passed to a program.</li></ul>          </div><p>了解command-line arguments的传递。这是通过<code>argc</code> ，<code>argv</code>完成的。<code>argc</code>记录了参数的个数，<code>argv</code>记录了每个参数的内容</p><p>看 <code>user/rm.c</code>这个例子</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/types.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/stat.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"user/user.h"</span></span><span class="hljs-keyword">int</span>main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])&#123;  <span class="hljs-keyword">int</span> i;  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"Usage: rm files...\n"</span>);    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  &#125;  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;    <span class="hljs-keyword">if</span>(unlink(argv[i]) &lt; <span class="hljs-number">0</span>)&#123;      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"rm: %s failed to delete\n"</span>, argv[i]);      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><p><code>rm</code>命令的使用方式是<code>rm filename...</code>。<code>argv</code>这个参数数组中第一个参数是<code>rm</code>这个命令，后面每一个filename是一个单独的参数。因此，如果<code>argc &lt; 2</code>说明只有<code>rm</code>这一个参数，不知道要<code>rm</code>哪个文件，这个时候应该报错, 这里通过<code>fprintf</code>向stderr输出错误，然后<code>exit(1)</code></p><p>参数个数合理的话，就对后面对每一个文件调用<code>ulink</code> system call来删除文件</p><div class="note note-success">            <ul><li>If the user forgets to pass an argument, sleep should print an error message.</li></ul>          </div><p><code>sleep</code>这个命令需要接受不了一个tick参数。参考<code>rm.c</code>的分析，应该写成</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"..."</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);&#125;</code></pre></div><p>注意: <code>2</code> 是标准错误输出，另外 <code>0</code>是标准输入, <code>1</code> 是标准输出</p><div class="note note-success">            <ul><li>是The command-line argument is passed as a string; you can convert it to an integer using <code>atoi</code> (see <code>user/ulib.c</code>).</li></ul>          </div><p><code>sleep</code>接收一个int类型的参数，而<code>argv</code>中的参数是char*类型，因此需要将其转化为int。这是通过调用<code>atoi</code>函数来实现的</p><p><code>atoi(char* s)</code></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span>atoi(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s)&#123;  <span class="hljs-keyword">int</span> n;  n = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span>(<span class="hljs-string">'0'</span> &lt;= *s &amp;&amp; *s &lt;= <span class="hljs-string">'9'</span>)    n = n*<span class="hljs-number">10</span> + *s++ - <span class="hljs-string">'0'</span>;  <span class="hljs-keyword">return</span> n;&#125;</code></pre></div><div class="note note-success">            <ul><li>Use the system call <code>sleep</code>.</li></ul>          </div><div class="note note-success">            <p>See <code>kernel/sysproc.c</code> for the xv6 kernel code that implements the  <code>sleep</code> system call (look for <code>sys_sleep</code>),  <code>user/user.h</code> for the C definition of  callable from a user program, and <code>user/usys.S</code> for the assembler code that jumps from user code into the kernel for <code>sleep.</code></p>          </div><p>我们实现的<code>user/sleep.c</code>属于user space的函数，他通过调用system call <code>sleep</code>实现他的功能。在下一个lab会知道如何从user space跳转到kernel space</p><p><code>kernel/sys_sleep</code></p><div class="hljs"><pre><code class="hljs c">uint64sys_sleep(<span class="hljs-keyword">void</span>)&#123;  <span class="hljs-keyword">int</span> n;  uint ticks0;  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  acquire(&amp;tickslock);  ticks0 = ticks;  <span class="hljs-keyword">while</span>(ticks - ticks0 &lt; n)&#123;    <span class="hljs-keyword">if</span>(myproc()-&gt;killed)&#123;      <span class="hljs-built_in">release</span>(&amp;tickslock);      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    sleep(&amp;ticks, &amp;tickslock);  &#125;  <span class="hljs-built_in">release</span>(&amp;tickslock);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><code>user/user.h</code> </p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;</code></pre></div><p><code>user/usys.S</code></p><div class="hljs"><pre><code class="hljs assembly">.global sleepsleep: li a7, SYS_sleep ecall ret</code></pre></div><p>容易发现一个问题, 在用户模式下调用 <code>sleep</code> 是有参数的，但是kernel下的调用没有参数 <code>uint64 sys_sleep(void)</code>，那么参数是如何传递的呢？</p><p>Passing arguments from user-level functions to kernel-level functions cannot be done in XV6. XV6 has its own built-in functions for passing arguments into a kernel function. For instance, to pass in an integer, the <code>argint()</code> function is called. </p><div class="hljs"><pre><code class="hljs c">argint(<span class="hljs-number">0</span>, &amp;pid);</code></pre></div><p>… to get the first argument which is the Process ID, and:</p><div class="hljs"><pre><code class="hljs c">argint(<span class="hljs-number">1</span>, &amp;pty);</code></pre></div><div class="note note-success">            <ul><li>Make sure <code>main</code> calls  <code>exit()</code> in order to exit your program.</li></ul>          </div><p>最后加一条<code>exit(0)</code> .</p><div class="note note-success">            <ul><li>Add your  <code>sleep</code> program to <code>UPROGS</code> in Makefile; once you’ve done that,  <code>make qemu</code> will compile your program and you’ll be able to run it from the xv6 shell.</li></ul>          </div><p>Run the program from the xv6 shell:</p><div class="hljs"><pre><code class="hljs bash">$ make qemu...init: starting sh$ sleep 10(nothing happens <span class="hljs-keyword">for</span> a little <span class="hljs-keyword">while</span>)$</code></pre></div><p>Your solution is correct if your program pauses when run as shown above. Run make grade to see if you indeed pass the sleep tests.</p><p>Note that make grade runs all tests, including the ones for the assignments below. If you want to run the grade tests for one assignment, type:</p><div class="hljs"><pre><code class="hljs bash">$ ./grade-lab-util sleep</code></pre></div><p>This will run the grade tests that match “sleep”. Or, you can type:</p><div class="hljs"><pre><code class="hljs bash">$ make GRADEFLAGS=sleep grade</code></pre></div><p>which does the same.</p><h2 id="Final-Code"><a href="#Final-Code" class="headerlink" title="Final Code"></a>Final Code</h2><p><span class="label label-danger">user/sleep.c</span></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/types.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"user/user.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;<span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"Usage: sleep [ticks]\n"</span>);<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">if</span>(sleep(atoi(argv[<span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>)) &#123;<span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"Failed to sleep %s ticks.\n"</span>, argv[<span class="hljs-number">1</span>]);<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><p><span class="label label-danger">Makefile</span></p><div class="hljs"><pre><code class="hljs makefile">...UPROGS=\...$U/_sleep\...</code></pre></div><h1 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h1><div class="note note-primary">            <p>Write a program that uses UNIX system calls to “ping-pong” a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print <code>&lt;pid&gt;: received ping</code>, where pid is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print <code>&lt;pid&gt;: received pong</code>, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</p>          </div><h2 id="Some-hints-1"><a href="#Some-hints-1" class="headerlink" title="Some hints:"></a>Some hints:</h2><div class="note note-success">            <ul><li>Use  <code>pipe</code> to create a pipe.</li></ul>          </div><div class="note note-success">            <ul><li>Use  <code>fork</code> to create a child.</li></ul>          </div><div class="note note-success">            <ul><li>Use  <code>read</code> to read from the pipe, and  <code>write</code> to write to the pipe.</li></ul>          </div><div class="note note-success">            <ul><li>Use  <code>getpid</code> to find the process ID of the calling process.</li></ul>          </div><div class="note note-success">            <ul><li>Add the program to  <code>UPROGS</code> in Makefile.</li></ul>          </div><div class="note note-success">            <ul><li>User programs on xv6 have a limited set of library functions available to them.</li></ul>          </div><p>Run the program from the xv6 shell and it should produce the following output:</p><div class="hljs"><pre><code class="hljs bash">$ make qemu...init: starting sh$ pingpong4: received ping3: received pong$</code></pre></div><p>Your solution is correct if your program exchanges a byte between two processes and produces output as shown above.</p><h2 id="Final-Code-1"><a href="#Final-Code-1" class="headerlink" title="Final Code"></a>Final Code</h2><p>关于pipe的内容见之前的<a href="https://miaochenlu.github.io/2020/12/01/pipe/">这篇文章</a></p><p>这里就是创建两个pipe, 一个pipe的方向是parent—&gt;child, 另一个pipe的方向是child—&gt;parent</p><p><span class="label label-danger">user/pingpong.c</span></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/types.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"user/user.h"</span></span><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[]) &#123;    <span class="hljs-keyword">int</span> parent_fd[<span class="hljs-number">2</span>], child_fd[<span class="hljs-number">2</span>];    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">10</span>];    <span class="hljs-keyword">if</span>(pipe(parent_fd) &lt; <span class="hljs-number">0</span> || pipe(child_fd) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"Error: Can't create pipe!\n"</span>);        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">int</span> pid = fork();    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//children process</span>        <span class="hljs-built_in">close</span>(parent_fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">//close write</span>        <span class="hljs-built_in">close</span>(child_fd[<span class="hljs-number">0</span>]);        <span class="hljs-built_in">read</span>(parent_fd[<span class="hljs-number">0</span>], buf, <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">'i'</span>) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: received ping\n"</span>, getpid());        &#125;        <span class="hljs-built_in">write</span>(child_fd[<span class="hljs-number">1</span>], <span class="hljs-string">"o"</span>, <span class="hljs-number">1</span>);        <span class="hljs-built_in">close</span>(parent_fd[<span class="hljs-number">0</span>]);        <span class="hljs-built_in">close</span>(child_fd[<span class="hljs-number">1</span>]);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">close</span>(parent_fd[<span class="hljs-number">0</span>]);        <span class="hljs-built_in">close</span>(child_fd[<span class="hljs-number">1</span>]);        <span class="hljs-built_in">write</span>(parent_fd[<span class="hljs-number">1</span>], <span class="hljs-string">"i"</span>, <span class="hljs-number">1</span>);        <span class="hljs-built_in">read</span>(child_fd[<span class="hljs-number">0</span>], buf, <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">'o'</span>) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: received pong\n"</span>, getpid());        &#125;        <span class="hljs-built_in">close</span>(parent_fd[<span class="hljs-number">1</span>]);        <span class="hljs-built_in">close</span>(child_fd[<span class="hljs-number">0</span>]);    &#125;    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><p><span class="label label-danger">Makefile</span></p><div class="hljs"><pre><code class="hljs makefile">...UPROGS=\...$U/_sleep\$U/_pingpong\...</code></pre></div><h1 id="Primes"><a href="#Primes" class="headerlink" title="Primes"></a>Primes</h1><div class="note note-primary">            <p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/" target="_blank" rel="noopener">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p><p><br></p><p>Your goal is to use <code>pipe</code> and <code>fork</code> to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.</p>          </div><p><a href="https://qinstaunch.github.io/2020/07/04/%E3%80%90%E8%AF%91%E6%96%87%E3%80%91Bell-Labs-and-CSP-Threads-Russ-Cox/#more" target="_blank" rel="noopener">【译文】Bell Labs and CSP Threads, Russ Cox.</a></p><center><video id="video" controls="" preload="none" width="400"><source id="mp4" src="https://miaochenlu.github.io/2020/12/03/xv6-lab1/prime3.mov">       <p>Your user agent does not support the HTML5 Video element.</p></video></center><p>思路: </p><p>以pipeline的形式来处理，和shell pipeline非常相似。</p><p>对每个进程来说，他得到的第一个数是素数。他的任务是筛选出不能整除这个素数的数，交给下一个进程处理。</p><p><span class="label label-danger">pseudocode</span></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">primes</span><span class="hljs-params">()</span> </span>&#123;  p = <span class="hljs-built_in">read</span> from left         <span class="hljs-comment">// 从左边接收到的第一个数一定是素数</span>  <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>):     primes()                 <span class="hljs-comment">// 子进程，进入递归</span>  <span class="hljs-keyword">else</span>:     loop:       n = <span class="hljs-built_in">read</span> from left     <span class="hljs-comment">// 父进程，循环接收左边的输入  </span>      <span class="hljs-keyword">if</span> (p % n != <span class="hljs-number">0</span>):         <span class="hljs-built_in">write</span> n to right     <span class="hljs-comment">// 不能被p整除则向右输出   </span>&#125;</code></pre></div><p><span class="label label-danger">user/primes.c</span></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/types.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"user/user.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">primes</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>];    <span class="hljs-keyword">int</span> num;    <span class="hljs-keyword">if</span>(read(<span class="hljs-number">0</span>, (<span class="hljs-keyword">void</span>*)&amp;num, <span class="hljs-keyword">sizeof</span>(num)) &lt;= <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"prime %d\n"</span>, num);    <span class="hljs-keyword">if</span>(pipe(p) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"Error: cannot create pipe"</span>);        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">int</span> pid = fork();    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;        close(<span class="hljs-number">0</span>);        dup(p[<span class="hljs-number">0</span>]);        close(p[<span class="hljs-number">0</span>]);        close(p[<span class="hljs-number">1</span>]);        primes();    &#125; <span class="hljs-keyword">else</span> &#123;        close(<span class="hljs-number">1</span>);        dup(p[<span class="hljs-number">1</span>]);        close(p[<span class="hljs-number">0</span>]);        close(p[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">int</span> tmpnum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(read(<span class="hljs-number">0</span>, (<span class="hljs-keyword">void</span>*)&amp;tmpnum, <span class="hljs-keyword">sizeof</span>(tmpnum))) &#123;            <span class="hljs-keyword">if</span>(tmpnum % num != <span class="hljs-number">0</span>) &#123;                write(<span class="hljs-number">1</span>, (<span class="hljs-keyword">void</span>*)&amp;tmpnum, <span class="hljs-keyword">sizeof</span>(tmpnum));            &#125;        &#125;        close(<span class="hljs-number">1</span>);        wait(&amp;pid);    &#125;    &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;    <span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>];    <span class="hljs-keyword">if</span>(pipe(p) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"Error: cannot create pipe"</span>);        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">int</span> pid = fork();    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;        close(<span class="hljs-number">0</span>);        dup(p[<span class="hljs-number">0</span>]);        close(p[<span class="hljs-number">0</span>]);        close(p[<span class="hljs-number">1</span>]);        primes();    &#125; <span class="hljs-keyword">else</span> &#123;        close(<span class="hljs-number">1</span>);        dup(p[<span class="hljs-number">1</span>]);        close(p[<span class="hljs-number">0</span>]);        close(p[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++) &#123;            write(<span class="hljs-number">1</span>, (<span class="hljs-keyword">void</span>*)&amp;i, <span class="hljs-keyword">sizeof</span>(i));        &#125;        close(<span class="hljs-number">1</span>);        wait(&amp;pid);    &#125;    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><p><span class="label label-danger">user/pingpong.c</span></p><p>抽象出了一个<code>redirect</code>函数简化代码</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/types.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"user/user.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">redirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> p[])</span> </span>&#123;    close(k);    dup(p[k]);    close(p[<span class="hljs-number">0</span>]);    close(p[<span class="hljs-number">1</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">primes</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>];    <span class="hljs-keyword">int</span> num;    <span class="hljs-keyword">if</span>(read(<span class="hljs-number">0</span>, (<span class="hljs-keyword">void</span>*)&amp;num, <span class="hljs-keyword">sizeof</span>(num)) &lt;= <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"prime %d\n"</span>, num);    <span class="hljs-keyword">if</span>(pipe(p) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"Error: cannot create pipe"</span>);        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">int</span> pid = fork();    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;        redirect(<span class="hljs-number">0</span>, p);        primes();    &#125; <span class="hljs-keyword">else</span> &#123;        redirect(<span class="hljs-number">1</span>, p);        <span class="hljs-keyword">int</span> tmpnum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(read(<span class="hljs-number">0</span>, (<span class="hljs-keyword">void</span>*)&amp;tmpnum, <span class="hljs-keyword">sizeof</span>(tmpnum))) &#123;            <span class="hljs-keyword">if</span>(tmpnum % num != <span class="hljs-number">0</span>) &#123;                write(<span class="hljs-number">1</span>, (<span class="hljs-keyword">void</span>*)&amp;tmpnum, <span class="hljs-keyword">sizeof</span>(tmpnum));            &#125;        &#125;        close(<span class="hljs-number">1</span>);        wait(&amp;pid);    &#125; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;    <span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>];    <span class="hljs-keyword">if</span>(pipe(p) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"Error: cannot create pipe"</span>);        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">int</span> pid = fork();    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;        redirect(<span class="hljs-number">0</span>, p);        primes();    &#125; <span class="hljs-keyword">else</span> &#123;        redirect(<span class="hljs-number">1</span>, p);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++) &#123;            write(<span class="hljs-number">1</span>, (<span class="hljs-keyword">void</span>*)&amp;i, <span class="hljs-keyword">sizeof</span>(i));        &#125;        close(<span class="hljs-number">1</span>);        wait(&amp;pid);    &#125;    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><div class="note note-primary">            <p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p>          </div><h2 id="Some-hints-2"><a href="#Some-hints-2" class="headerlink" title="Some hints:"></a>Some hints:</h2><div class="note note-success">            <ul><li>Look at <code>user/ls.c</code> to see how to read directories.</li></ul>          </div><p>这是<code>user/ls.c</code>的代码</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/types.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/stat.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"user/user.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/fs.h"</span></span><span class="hljs-keyword">char</span>*fmtname(<span class="hljs-keyword">char</span> *path)&#123;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[DIRSIZ+<span class="hljs-number">1</span>];  <span class="hljs-keyword">char</span> *p;  <span class="hljs-comment">// Find first character after last slash.</span>  <span class="hljs-keyword">for</span>(p=path+<span class="hljs-built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="hljs-string">'/'</span>; p--)    ;  p++;  <span class="hljs-comment">// Return blank-padded name.</span>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(p) &gt;= DIRSIZ)    <span class="hljs-keyword">return</span> p;  memmove(buf, p, <span class="hljs-built_in">strlen</span>(p));  <span class="hljs-built_in">memset</span>(buf+<span class="hljs-built_in">strlen</span>(p), <span class="hljs-string">' '</span>, DIRSIZ-<span class="hljs-built_in">strlen</span>(p));  <span class="hljs-keyword">return</span> buf;&#125;<span class="hljs-keyword">void</span>ls(<span class="hljs-keyword">char</span> *path)&#123;  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">512</span>], *p;  <span class="hljs-keyword">int</span> fd;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span>  <span class="hljs-keyword">if</span>((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"ls: cannot open %s\n"</span>, path);    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"ls: cannot stat %s\n"</span>, path);    close(fd);    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">switch</span>(st.type)&#123;  <span class="hljs-keyword">case</span> T_FILE:    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s %d %d %l\n"</span>, fmtname(path), st.type, st.ino, st.size);    <span class="hljs-keyword">break</span>;  <span class="hljs-keyword">case</span> T_DIR:    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)&#123;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ls: path too long\n"</span>);      <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-built_in">strcpy</span>(buf, path);    p = buf+<span class="hljs-built_in">strlen</span>(buf);    *p++ = <span class="hljs-string">'/'</span>;    <span class="hljs-keyword">while</span>(read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;      <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)        <span class="hljs-keyword">continue</span>;      memmove(p, de.name, DIRSIZ);      p[DIRSIZ] = <span class="hljs-number">0</span>;      <span class="hljs-keyword">if</span>(stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ls: cannot stat %s\n"</span>, buf);        <span class="hljs-keyword">continue</span>;      &#125;      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s %d %d %d\n"</span>, fmtname(buf), st.type, st.ino, st.size);    &#125;    <span class="hljs-keyword">break</span>;  &#125;  close(fd);&#125;<span class="hljs-keyword">int</span>main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])&#123;  <span class="hljs-keyword">int</span> i;  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;    ls(<span class="hljs-string">"."</span>);    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  &#125;  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)    ls(argv[i]);  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);</code></pre></div><p>总结一下就是</p><ul><li>由于需要获取文件的类型等信息，用<code>fstat</code>函数获取文件的stat信息</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"ls: cannot stat %s\n"</span>, path);    close(fd);    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><ul><li><p>根据文件类型 <code>st.type</code>分别进行处理</p><ul><li><p>如果是<code>T_FILE</code>, 直接输出文件信息</p></li><li><p>如果是<code>T_DIR</code>,  需要输出目录包含的文件的信息目录文件通过一个个struct direct (directory entry)来记录他所包含的文件</p><p>建了一个buf数组来存放目录中文件的path, 他将会存储的信息是目录path+”/“+filename+’/0’</p><p>因此，这里先对path的size做了限制，不能超过buf的大小</p><p>然后，将directory的path拷贝到buf中，并且加入了一个’/‘</p><p>接着循环读取目录中的dirent结构到de。根据de, 获得filename, filename拷贝到buf， 输出文件信息。</p></li></ul></li></ul><div class="note note-success">            <ul><li>Use recursion to allow find to descend into sub-directories.</li></ul>          </div><div class="note note-success">            <ul><li>Don’t recurse into “.” and “..”.</li></ul>          </div><p>这里如果不做处理会进入死循环</p><div class="note note-success">            <ul><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li></ul>          </div><div class="note note-success">            <ul><li>You’ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</li></ul>          </div><div class="note note-success">            <ul><li>Note that <code>==</code> does not compare strings like in Python. Use strcmp() instead.</li></ul>          </div><div class="note note-success">            <ul><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul>          </div><h2 id="Final-Code-2"><a href="#Final-Code-2" class="headerlink" title="Final Code"></a>Final Code</h2><p>思路: find命令的使用方式是<code>find dir filename</code></p><p>打开directory, 获取里面每个文件的信息</p><ul><li><p>如果是文件： 文件名字与需要查找的文件名相同，就组织成path输出</p></li><li><p>如果是目录，并且不是”.”, “..”, 就递归查找</p></li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/types.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/stat.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"user/user.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/fs.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* path, <span class="hljs-keyword">char</span>* filename)</span> </span>&#123;    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">512</span>], *p;    <span class="hljs-keyword">int</span> fd;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span>    <span class="hljs-keyword">if</span>((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"find: cannot open %s\n"</span>, path);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"find: cannot stat %s\n"</span>, path);        close(fd);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(st.type != T_DIR) &#123;        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"find: %s is not a directory\n"</span>, path);        close(fd);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"find: path too long\n"</span>);        close(fd);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-built_in">strcpy</span>(buf, path);    p = buf+<span class="hljs-built_in">strlen</span>(buf);    *p++ = <span class="hljs-string">'/'</span>;    <span class="hljs-keyword">while</span>(read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de)) &#123;        <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)             <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">"."</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">".."</span>) == <span class="hljs-number">0</span>)            <span class="hljs-keyword">continue</span>;        memmove(p, de.name, DIRSIZ);        p[DIRSIZ] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"find: cannot stat %s\n"</span>, buf);;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">switch</span> (st.type)        &#123;        <span class="hljs-keyword">case</span> T_FILE:            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(de.name, filename) == <span class="hljs-number">0</span>) &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, buf);            &#125;            <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> T_DIR:            find(buf, filename);        &#125;    &#125;    close(fd);&#125;<span class="hljs-keyword">int</span>main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])&#123;  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">3</span>)&#123;    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"Usage: find path filename\n"</span>);    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  &#125;  find(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><div class="note note-primary">            <p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p>          </div><p>The following example illustrates xarg’s behavior:</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> hello too | xargs <span class="hljs-built_in">echo</span> <span class="hljs-built_in">bye</span></span>bye hello too<span class="hljs-meta">$</span></code></pre></div><p>Note that the command here is “echo bye” and the additional arguments are “hello too”, making the command “echo bye hello too”, which outputs “bye hello too”.</p><p>Please note that xargs on UNIX makes an optimization where it will feed more than argument to the command at a time. We don’t expect you to make this optimization. To make xargs on UNIX behave the way we want it to for this lab, please run it with the -n option set to 1. For instance</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">"1\n2"</span> | xargs -n 1 <span class="hljs-built_in">echo</span> line</span>line 1line 2<span class="hljs-meta">$</span></code></pre></div><p>我感觉这个命令的意思是从标准输入读取数据作为后面命令的参数</p><h2 id="Some-hints-3"><a href="#Some-hints-3" class="headerlink" title="Some hints:"></a>Some hints:</h2><div class="note note-success">            <ul><li>Use <code>fork</code> and <code>exec</code> to invoke the command on each line of input. Use <code>wait</code> in the parent to wait for the child to complete the command.</li></ul>          </div><div class="note note-success">            <ul><li>To read individual lines of input, read a character at a time until a newline (‘\n’) appears.</li></ul>          </div><div class="note note-success">            <ul><li><code>kernel/param.h declares MAXARG</code>, which may be useful if you need to declare an argv array.</li></ul>          </div><p><code>#define MAXARG       32  // max exec arguments</code></p><div class="note note-success">            <ul><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul>          </div><div class="note note-success">            <ul><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li></ul>          </div><p>xargs, find, and grep combine well:</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> find . b | xargs grep hello</span></code></pre></div><p>will run “grep hello” on each file named b in the directories below “.”.</p><h2 id="Final-Code-3"><a href="#Final-Code-3" class="headerlink" title="Final Code"></a>Final Code</h2><p>这个命令的重点在于重新组织<code>argv</code>, 将标准输入中的内容作为参数放入<code>argv</code></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/types.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"kernel/param.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"user/user.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;    <span class="hljs-keyword">char</span> *nargs[MAXARG];    <span class="hljs-keyword">int</span> argCount = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++) &#123;        nargs[argCount++] = argv[i];    &#125;    <span class="hljs-keyword">char</span> tmpchar = <span class="hljs-number">0</span>;    <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">1024</span>];    <span class="hljs-keyword">int</span> status = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(status) &#123;        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> argStartPos = <span class="hljs-number">0</span>;                <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;            status = read(<span class="hljs-number">0</span>, &amp;tmpchar, <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(status == <span class="hljs-number">0</span>) <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span>(tmpchar != <span class="hljs-string">' '</span> &amp;&amp; tmpchar != <span class="hljs-string">'\n'</span>) &#123;                buffer[pos++] = tmpchar;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmpchar == <span class="hljs-string">' '</span>) &#123;                buffer[pos++] = <span class="hljs-number">0</span>;                nargs[argCount++] = &amp;buffer[argStartPos];                argStartPos = pos;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmpchar == <span class="hljs-string">'\n'</span>) &#123;                nargs[argCount++] = &amp;buffer[argStartPos];                argStartPos = pos;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;            exec(nargs[<span class="hljs-number">0</span>], nargs);        &#125; <span class="hljs-keyword">else</span> &#123;            wait(<span class="hljs-number">0</span>);        &#125;    &#125;    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pipe</title>
    <link href="/2020/12/01/pipe/"/>
    <url>/2020/12/01/pipe/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="File-Descriptor—操作系统是怎样操作文件的？"><a href="#File-Descriptor—操作系统是怎样操作文件的？" class="headerlink" title="File Descriptor—操作系统是怎样操作文件的？"></a>File Descriptor—操作系统是怎样操作文件的？</h1><h2 id="1-什么是file-descriptor"><a href="#1-什么是file-descriptor" class="headerlink" title="1. 什么是file descriptor"></a>1. 什么是file descriptor</h2><p>文件描述符是一个small int，它代表了一个内核管理的对象(kernel-managed object)，进程可以通过文件描述符对该对象进行读写操作。</p><p>进程可能通过如下方法获取文件描述符： 打开文件、目录或设备，创建管道，复制一个已有的描述符。为简单起见，文件描述符指向的对象都被称为是“文件”；文件描述符抽象出来文件、管道和设备的共同点，使它们看起来都像是字节流。</p><p>文件描述符从0开始计数。按照惯例，0是标准输入，1是标准输出，2是标准错误。</p><p><img src="pipe012.jpg" srcset="/img/loading.gif" alt="pipe012" style="zoom:80%;" /></p><h2 id="2-那怎么通过file-descriptor来操作文件呢"><a href="#2-那怎么通过file-descriptor来操作文件呢" class="headerlink" title="2. 那怎么通过file descriptor来操作文件呢"></a>2. 那怎么通过file descriptor来操作文件呢</h2><p><img src="organization.jpg" srcset="/img/loading.gif" alt="organization" style="zoom:80%;" /></p><p>如图有三个table: (per-process) file descriptor table, (system-wide) file table, inode table。 通过这三个table, 我们可以就可以通过file descriptor来处理文件了</p><p>内核为每个进程维护一个file descriptor table, 它保存了文件描述符并且指向一个file table entry。(per-process)</p><p>内核维护了一个全局的file table, 记录了所有被打开的文件的信息。每个entry记录了这个file所处的mode (read, write, …), 当前操作的偏移量，它指向inode table中的一个entry</p><p>inode table对应真实的underlying file的信息。</p><h2 id="3-open-close-dup-…"><a href="#3-open-close-dup-…" class="headerlink" title="3. open, close,dup …"></a>3. open, close,dup …</h2><p>system call <code>close</code>会释放一个file descriptor, 以供以后的 <code>open</code>, <code>pipe</code>, <code>dup</code>等系统调用进行使用。</p><p>在分配file descriptor时，系统总是会分配最小的、没有被使用的file descriptor。</p><div class="hljs"><pre><code class="hljs cpp">close(<span class="hljs-number">0</span>);open(<span class="hljs-string">"input.txt"</span>, O_RDONLY);</code></pre></div><p>系统调用<code>close</code>释放了file descriptor 0, 那么当前最小的，可供分配的file descriptor就是0</p><p>然后以只读的方式打开了文件<code>input.txt</code>, 他将会被分配到file descriptor 0</p><p><code>dup</code>这个系统调用会分配一个新的file descriptor，指向当前file descriptor指向的object。</p><div class="hljs"><pre><code class="hljs cpp">fd = dup(<span class="hljs-number">1</span>);</code></pre></div><p>fd得到了一个指向[file descriptor 1指向的object]的file descriptor （禁止套娃!</p><h1 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h1><div class="table-container"><table><thead><tr><th>System cal</th><th>Description</th></tr></thead><tbody><tr><td>int pipe(int p[])</td><td>Create a pipe, put read/write file descriptors in p[0] and p[1]</td></tr></tbody></table></div><p>pipe用于进程间的通信，它其实是内核里一块小的缓冲区，这个缓冲区向进程提供了一对文件描述符，一个用于读而另一个用于写。向管道的一端写数据，会使管道的另一端可以读这些数据。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>];pipe(p);</code></pre></div><p>程序调用<code>pipe</code>来创建管道，并把读和写的文件描述符记录在数组<code>p</code>里, p[0]为读端，p[1]为写端，可以通过file descriptor <code>p[1]</code>向pipe buffer写入内容，通过file descriptor <code>p[0]</code>从pipe buffer中读取内容。</p><div class="note note-warning">            <p>pipe中的内容存储在pipe buffer中，pipe buffer是kernel space中的一块空间，他的大小是有限的。</p>          </div><p>关于pipe是如何实现的，可以<a href="https://www.halolinux.us/kernel-reference/creating-and-destroying-a-pipe.html" target="_blank" rel="noopener">点我</a></p><p><img src="addpipe.jpg" srcset="/img/loading.gif" alt="addpipe" style="zoom:100%;" /></p><h2 id="pipe-amp-fork"><a href="#pipe-amp-fork" class="headerlink" title="pipe &amp; fork"></a>pipe &amp; fork</h2><p><code>pipe</code>一般会和<code>fork</code>配合使用</p><p>下面的代码是一个例子</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> p[<span class="hljs-number">2</span>];<span class="hljs-keyword">char</span> *argv[<span class="hljs-number">2</span>];argv[<span class="hljs-number">0</span>] = <span class="hljs-string">"wc"</span>;argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;pipe(p);<span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;    close(<span class="hljs-number">0</span>);    dup(p[<span class="hljs-number">0</span>]);    close(p[<span class="hljs-number">0</span>]);    close(p[<span class="hljs-number">1</span>]);    exec(<span class="hljs-string">"/bin/wc"</span>, argv);&#125; <span class="hljs-keyword">else</span> &#123;    close(p[<span class="hljs-number">0</span>]);    write(p[<span class="hljs-number">1</span>], <span class="hljs-string">"hello world\n"</span>, <span class="hljs-number">12</span>);    close(p[<span class="hljs-number">1</span>]);&#125;</code></pre></div><p>分段解析这份代码</p><ul><li>首先<code>pipe(p)</code>, <code>fork()</code>。注意fork的时候file descriptor是会被复制的</li></ul><p><img src="forkprocess.jpg" srcset="/img/loading.gif" alt="forkprocess" style="zoom:67%;" /></p><ul><li>子进程关闭了0, dup(p[0]), 这样0这个file descriptor就会指向pipe的读一端。子进程继续关闭了p[0], p[1];  父进程关闭了p[0]。形成的局面是，parent 可以通过p[1]将内容写入pipe, child可以通过file descriptor 0读pipe中的内容</li></ul><p><img src="closedup.jpg" srcset="/img/loading.gif" alt="closedup" style="zoom:67%;" /></p><ul><li>父进程将”hello world\n”写入pipe。子进程执行的<code>wc</code>程序从标准输入里读时，它就是从pipe里读。当pipe里没有数据的时候，管道上的<code>read</code>要么等数据写入，要么等写入端的文件描述符被关闭；在后一种情况下，<code>read</code>将返回0，就像到达了数据文件的尾部一样</li></ul><p><img src="afterwrite.jpg" srcset="/img/loading.gif" alt="afterwrite" style="zoom:67%;" /></p><ul><li>父进程写完后，close(p[1])。此时，这个pipe的所有写端都已关闭。子进程<code>wc</code>处理完pipe中的数据后，在标准输出显示”hello world\n”</li></ul><p><img src="eof.jpg" srcset="/img/loading.gif" alt="eof" style="zoom:67%;" /></p><div class="note note-warning">            <p> 为什么linux中的pipe end不用要关闭</p><ul><li>首先，file descriptor可以分配的数量是有限的</li><li>另外，读操作会一直读或者一直阻塞，直到看到了end of file。在pipe的所有写端都关闭时，才会有end of file信号。</li></ul>          </div><h2 id="Shell-Pipeline"><a href="#Shell-Pipeline" class="headerlink" title="Shell Pipeline"></a>Shell Pipeline</h2><p>shell的命令可以流水线执行</p><p>如下所示，<code>echo hello</code>的output作为了<code>wc</code>的input, 最终结果被输出在屏幕上</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> hello | wc</span>1 1 6</code></pre></div><p>shell中pipeline的处理和pipe&amp;fork中的代码示例的道理是一样的。</p><p>shell会fork出一个子进程z来处理<code>echo hello | wc</code>。</p><p>为了将左边的输出发送给右边，子进程z创建一个pipe来连接左边cmd和右边cmd。</p><p>接着，子进程z调用fork创建z1, 通过<code>runcmd</code>执行左边的命令，再<code>fork</code>创建z2, 通过<code>runcmd</code>执行右边的命令。子进程等待两边执行结束。使用方式，在处理pipeline的过程中shell可以创建出一棵进程树</p><div class="note note-warning">            <p>为什么需要fork两次呢，子进程z不能用来执行左边或者右边的命令吗？</p><p>A: 这样是不合理的。考虑<code>echo hello | wc</code>这行命令，z执行左边的命令。那么echo hello执行完了之后z进程直接exit, 不会再fork出进程来执行右边的命令了。因为这个问题，我们可能需要修改代码，让runcmd执行左边的命令时不调用exit，这会使code复杂化。</p><p>z执行右边也是同理的，考虑<code>sleep 10 | echo hi</code>这行命令，会直接输出”hi”然后z exit, 不会再sleep 10了。</p>          </div><p><br></p><p>如下shell pipeline可以创建出一棵进程树</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> a | b | c | d</span></code></pre></div><p><img src="pipelineprocesstree.jpg" srcset="/img/loading.gif" alt="pipelineprocesstree" style="zoom:67%;" /></p><h1 id="pipe的优势"><a href="#pipe的优势" class="headerlink" title="pipe的优势"></a>pipe的优势</h1><p>看起来管道做的事，用临时文件重定向也可以做。一下两行命令可以 达到同样的效果</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> hello | wc</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> hell &gt; /tmp/xyz; wc &lt; /tmp/xyz</span></code></pre></div><p>但实际上，管道比临时文件至少有如下优势：</p><ol><li>管道会自动清除它自己，而使用重定向则要手动清除临时文件。</li><li>管道可以传输任意长度的数据流，而重定向则要求磁盘有足够的空间来保存所有的数据。</li><li>管道可以并行执行，而重定向只能依次执行。</li><li>如果进行的是进程间通信，管道阻塞读和写这样的语义比文件的非阻塞语义更有效。</li></ol><p><br></p><p><br></p><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><p>[1]<a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/File_descriptor</a></p><p>[2]<a href="https://www.computerhope.com/jargon/f/file-descriptor.htm" target="_blank" rel="noopener">https://www.computerhope.com/jargon/f/file-descriptor.htm</a></p><p>[3]<a href="https://zhuanlan.zhihu.com/p/105086274" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105086274</a></p><p>[4]<a href="https://stackoverflow.com/questions/33151457/where-does-the-linux-kernel-keep-the-data-written-to-a-pipe" target="_blank" rel="noopener">https://stackoverflow.com/questions/33151457/where-does-the-linux-kernel-keep-the-data-written-to-a-pipe</a></p><p>[5]<a href="https://www.halolinux.us/kernel-reference/creating-and-destroying-a-pipe.html" target="_blank" rel="noopener">https://www.halolinux.us/kernel-reference/creating-and-destroying-a-pipe.html</a></p><p>[6]<a href="http://www.rozmichelle.com/pipes-forks-dups/" target="_blank" rel="noopener">http://www.rozmichelle.com/pipes-forks-dups/</a></p><p>[7]<a href="https://github.com/shzhxh/xv6-riscv-book-CN/blob/master/1_操作系统接口.md" target="_blank" rel="noopener">https://github.com/shzhxh/xv6-riscv-book-CN/blob/master/1_操作系统接口.md</a></p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统接口</title>
    <link href="/2020/11/27/OSInterfaces/"/>
    <url>/2020/11/27/OSInterfaces/</url>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>如下图所示是一个计算机系统，最底层有有一些硬件资源，比如: CPU, 内存，磁盘，网卡。</p><p>在上层运行一些应用程序，比如一个文本编辑器（VI），一个C编译器(CC), 一个Shell。这些程序都运行在一个空间中：用户空间(user space)。</p><p>除了用户空间还存在一个内核空间(kernel space)。kernel对底层管理硬件资源，为上层程序提供了大量的服务。他对用户空间程序(进程)，对内存进行分配，进行访问控制……。kernel程序总是第一个被启动的，他也是独一无二的存在。</p><p><img src="OS.jpg" srcset="/img/loading.gif" alt="OS" style="zoom:80%;" /></p><p>用户空间又如何与内核空间进行交互呢？这是通过一系列的接口来实现的。通常这通过系统调用 (system call)来实现。</p><p>如下图所示，在用户空间中有一个shell程序在运行。如果这个时候得到一条读取文件的命令，shell invoke <code>read</code> 这个system call， 跳转到内核空间，执行该命令，然后将结果返回用户空间。 [这里是这么实现的呢]</p><p><img src="image-20201127194539928.png" srcset="/img/loading.gif" alt="image-20201127194539928" style="zoom:80%;" /></p><h1 id="一些系统调用"><a href="#一些系统调用" class="headerlink" title="一些系统调用"></a>一些系统调用</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a><code>fork</code></h2><div class="table-container"><table><thead><tr><th>System Call</th><th>Description</th></tr></thead><tbody><tr><td><code>int fork()</code></td><td>Create a process, return child’s PID</td></tr></tbody></table></div><p><code>fork</code> 的作用是克隆进程，也就是将原先的一个进程再克隆出一个来，克隆出的这个进程就是原进程的子进程，这个子进程和其他的进程没有什么区别，同样拥有自己的独立的地址空间。不同的是子进程是在fork返回之后才开始执行的。</p><p>在XV6中，父子进程除了fork的返回值，其他都是一样的。除了内存是一样的以外，文件描述符的表单也从父进程拷贝到子进程。所以如果父进程打开了一个文件，子进程可以看到同一个文件描述符，尽管子进程看到的是一个文件描述符的表单的拷贝。</p><p><code>fork</code>函数有三个返回值</p><ul><li>该进程为父进程时，返回子进程的pid</li><li>该进程为子进程时，返回0</li><li>fork执行失败，返回-1</li></ul><p><img src="v2-c5c3ba7e5e1f3eb0127683faef9cce32_720w.png" srcset="/img/loading.gif" alt="img" style="zoom:67%;" /></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt; //for fork</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/wait.h&gt;//for wait</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">int</span> pid = fork();  <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"parent: child = %d\n"</span>, pid);    pid = wait(<span class="hljs-number">0</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child %d is done\n"</span>, pid);  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child: exiting\n"</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fork error\n"</span>);  &#125;&#125;</code></pre></div><p>输出</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash">./a.out</span>parent: child = 24482child: exitingchild 24482 is done</code></pre></div><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h2><div class="table-container"><table><thead><tr><th>System call</th><th>Description</th></tr></thead><tbody><tr><td><code>int exec(char* file, char* argv[])</code></td><td>Load a file and execute it with arguments; only returns if error</td></tr></tbody></table></div><p>把当前进程的内存替换为文件里保存的内存镜像并执行之。<code>exec</code>有两个参数，第一个是要执行的程序，第二个这个程序的参数(以字符串数组的形式出现)。</p><ol><li>exec系统调用会保留当前的文件描述符表单。所以任何在exec系统调用之前的文件描述符，例如0，1，2等。它们在新的程序中表示相同的东西。</li><li>通常来说exec系统调用不会返回，因为exec会完全替换当前进程的内存，相当于当前进程不复存在了，所以exec系统调用已经没有地方能返回了。</li></ol><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">char</span>* argv[] = &#123;<span class="hljs-string">"echo"</span>, <span class="hljs-string">"this"</span>, <span class="hljs-string">"is"</span>, <span class="hljs-string">"echo"</span>, <span class="hljs-number">0</span>&#125;;  execv(<span class="hljs-string">"/bin/echo"</span>, argv);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"exec failed\n"</span>);&#125;</code></pre></div><p>输出</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ./a.out  </span>this is echo</code></pre></div><h2 id="shell是怎么工作的"><a href="#shell是怎么工作的" class="headerlink" title="shell是怎么工作的"></a>shell是怎么工作的</h2><p>首先看 <code>main</code> 函数，main loop通过 <code>getcmd</code>读取一行输入</p><p>然后调用 <code>fork</code>函数，创建一个shell process的copy。子进程通过<code>runcmd</code>执行命令，父进程等待。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span>main(<span class="hljs-keyword">void</span>)&#123;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">100</span>];..      <span class="hljs-comment">// Read and run input commands.</span>    <span class="hljs-keyword">while</span>(getcmd(buf, <span class="hljs-keyword">sizeof</span>(buf)) &gt;= <span class="hljs-number">0</span>)&#123;    ...        <span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)          runcmd(parsecmd(buf));        wait(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><p>比如用户在shell中输入了 <code>echo hello</code>, <code>getcmd</code>获取了这条命令，通过fork创建了子进程，子进程调用 <code>runcmd</code>函数，<code>runcmd</code>将<code>echo hello</code>作为其参数。在<code>runcmd</code>中，他调用 <code>exec</code>函数执行<code>echo</code>。在某个时刻, <code>echo</code>调用 <code>exit</code>函数，这使父进程return from <code>wait</code></p><p><img src="OS-2.png" srcset="/img/loading.gif" alt="OS-2" style="zoom:80%;" /></p><h1 id="fork-amp-exec-OR-forkexec"><a href="#fork-amp-exec-OR-forkexec" class="headerlink" title="fork() &amp; exec() OR forkexec()"></a><code>fork()</code> &amp; <code>exec()</code> OR <code>forkexec()</code></h1><div class="note note-warning">            <p>如上面所说，<code>fork</code>了之后再需要调用<code>exec</code>将替换子进程的内存，为什么不直接将<code>fork</code>和<code>exec</code>合并成一个system call呢?</p>          </div><p>将<code>fork</code>与<code>exec</code>分成两个系统调用，方便了I/O redirection的实现</p><p>如下所示, 我们希望将echo hello的输出结果重定向到<code>newfile.txt</code>。</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> hello &gt; newfile.txt</span></code></pre></div><p>shell实现的方法是: 在子进程创建后，调用 <code>exec</code>之前，shell关闭标准输出，并且打开文件<code>newfile.txt</code>, 这样结果就不会被输出到屏幕上，而是被输出到<code>newfile.txt</code>。</p><p>当然这个效果也依赖于操作系统对文件描述符的管理方式。文件描述符由kernel管理的对象，用一个比较小的整数来表示，把文件描述符指向的对象称为file，通过文件描述符可以对文件进行读写操作。通常，0为standard input, 1为standard output, 2为standard error。在分配文件描述符时，UNIX系统会从0开始寻找第一个可以使用的文件描述符。shell关闭了标准输出后，<code>STDOUT_FILENO</code>就是第一个可以使用的文件描述符。调用<code>open</code>函数打开文件后，这个文件就会被分配到这个文件描述符。</p><p>考虑，如果将<code>fork</code>, <code>exec</code>合并为一个系统调用<code>forkexec</code>，那怎么才能实现重定向呢？有几下几种思考</p><ul><li>shell在调用<code>forkexec</code>之前修改他的I/O</li><li><code>forkexec</code>接受I/O重定向的参数</li><li>每个程序自己处理I/O重定向问题</li></ul><p>显然，这些都比较复杂。还是将<code>fork</code>和<code>exec</code>作为两个函数比较方便。但是，这也有一个问题，fork需要拷贝内存，而exec需要替换内存，这样是比较浪费时间的，所以后面会采用copy-on-write的方式进行优化。</p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Miss Status Holding Registers (MSHR)</title>
    <link href="/2020/10/29/MSHR/"/>
    <url>/2020/10/29/MSHR/</url>
    
    <content type="html"><![CDATA[<blockquote><p> miss status holding register (MSHR) 主要用来处理non-blocing cache中cache miss的情况</p></blockquote><a id="more"></a><h1 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h1><p>miss status holding register (MSHR) 主要用来处理non-blocing cache中cache miss的情况，因此也被称为miss buffer</p><p>这里你可能就会对non-blocking cache感到疑惑了。什么是non-blocking cache呢? (不疑惑的话当我没说, 啊这…)</p><p>当我们发出一个memory request, 然后就会在cache中寻找这个地址。如果这个地址不在cache中，那么就是一个cache miss。所谓的blocking cache, 当出现cache miss后, 后续对cache的请求将被阻塞，直到处理完了cache miss的情况。很显然，这样很影响效率。</p><p>因此，non-blocking cache出来制止这种 “stop the world”的行为。他允许processer继续处理指令，即使存在cache miss。他很像是pipelining the memory system, 可以达到hiding memory latency的效果。下图就是这两者的对比</p><p><img src="image-20201029190843232.png" srcset="/img/loading.gif" alt="image-20201029190843232" style="zoom:80%;" /></p><p>是什么导致了blocking cache和non-blocking cache的这种差别呢？ 我认为，这是因为blocking cache只能存一个request的信息，而non-blocking cache可以存多个request的信息，关键是可以将miss信息都存储起来。将miss信息存在哪里了？—-&gt; MSHR</p><h1 id="MHA-and-MSHR-Entry"><a href="#MHA-and-MSHR-Entry" class="headerlink" title="MHA and MSHR Entry"></a>MHA and MSHR Entry</h1><p>MSHR track的information为</p><ul><li>outstanding cache misses</li><li>Pending load/store accesses that refer to the missing cache block</li></ul><p>下图左边展示了banked cache的Miss handling architecture, 每个cache bank都有他自己的MSHR</p><p>右边展示了MSHR的内部结构。这个MSHR file是一个比较小的全关联cache, 他可以处理n个miss。</p><p>每个MSHR entry包含的信息如下</p><ul><li>引发miss的cache block address</li><li>target information (存储了该block的pending load/store的信息)。</li><li>一个valid bit。这个valid bit标志该MSHR是否正在使用中。如果这个MSHR file所有的valid bit都置1了，那么再出现miss的话，MSHR就无法处理了，只能block。</li></ul><p><img src="image-20201029194813318.png" srcset="/img/loading.gif" alt="image-20201029194813318" style="zoom:80%;" /></p><p>下图是一个更加详细的MSHR Entry的结构, 后面更详细的展示了target information的内容</p><ul><li>是不是valid</li><li>请求的type是什么 (load or store)</li><li>如果requested data比一整个cache line要小的话，那么就需要存储requested data在该cache line的offset。</li><li>返回给哪个哪个CPU的哪个destination register或者是store buffer entry address</li></ul><p><img src="image-20201029201655094.png" srcset="/img/loading.gif" alt="image-20201029201655094" style="zoom:80%;" /></p><p><img src="MSHREntry.svg" srcset="/img/loading.gif" alt="image-20201029201655094" style="zoom:80%;" /></p><h1 id="MSHR-Operation"><a href="#MSHR-Operation" class="headerlink" title="MSHR Operation"></a>MSHR Operation</h1><p>下图展示了Non-blocking cache处理memory access的过程， 其中 [h1]-[h3]展示了cache hit的过程，[m1]-[m`6]展示了cache miss的过程</p><h3 id="cache-hit的情况"><a href="#cache-hit的情况" class="headerlink" title="cache hit的情况"></a>cache hit的情况</h3><p>process发送request给cache, cache hit, 然后将data返回</p><h3 id="cache-miss的情况"><a href="#cache-miss的情况" class="headerlink" title="cache miss的情况"></a>cache miss的情况</h3><ul><li><p>process发送request给cache, cache中找不到对应地址，cache miss</p></li><li><p>cache miss时, 查找MSHR看request block在不在里面。</p><ul><li>如果不在，则需要分配一个新的MSHR Entry， 还会给memory 发送request, 请求数据。</li><li>如果在，就在对应的MSHR Entry里面写入该load或者store的信息，他不需要给memory发送request了，因为已经有人去request了，他只要安静地等着就行了。</li><li>如果没有多余的Entry了，就会引发stall。</li></ul></li><li><p>数据从memory返回后</p><ul><li>他会查看哪些load/store指令正在等待他，然后把数据forward给这些load/store unit，并将这些load/store unit从MSHR中deallocate</li><li>然后将数据写入cache或者MSHR</li><li>写完了最后一个cache subblock后，就deallocate MSHR</li></ul></li></ul><p><img src="image-20201029192203454.png" srcset="/img/loading.gif" alt="image-20201029192203454" style="zoom:80%;" /></p><p><br></p><p>references</p><p>[1] <a href="https://safari.ethz.ch/architecture/fall2017/lib/exe/fetch.php?media=onur-comparch-fall2017-lecture3-afterlecture.pdf" target="_blank" rel="noopener">https://safari.ethz.ch/architecture/fall2017/lib/exe/fetch.php?media=onur-comparch-fall2017-lecture3-afterlecture.pdf</a></p><p>[2] <a href="https://www.researchgate.net/publication/237283841_Performance_Effects_of_a_Cache_Miss_Handling_Architecture_in_a_Multi-core_Processor" target="_blank" rel="noopener">https://www.researchgate.net/publication/237283841_Performance_Effects_of_a_Cache_Miss_Handling_Architecture_in_a_Multi-core_Processor</a></p><p>[3] <a href="https://link.springer.com/article/10.1007/s11241-017-9280-9#:~:text=A%20non%2Dblocking%20cache%20is,requests%20at%20the%20same%20time.&amp;text=Because%20a%20non%2Dblocking%20cache,penalties%20and%20therefore%20improves%20performance" target="_blank" rel="noopener">https://link.springer.com/article/10.1007/s11241-017-9280-9#:~:text=A%20non%2Dblocking%20cache%20is,requests%20at%20the%20same%20time.&amp;text=Because%20a%20non%2Dblocking%20cache,penalties%20and%20therefore%20improves%20performance</a>.</p><p>[4] <a href="https://www.epfl.ch/labs/lap/wp-content/uploads/2019/06/AsiaticiFeb19_StopCryingOverYourCacheMissRateHandlingEfficientlyThousandsOfOutstandingMissesInFpgas_FPGA19.pdf" target="_blank" rel="noopener">https://www.epfl.ch/labs/lap/wp-content/uploads/2019/06/AsiaticiFeb19_StopCryingOverYourCacheMissRateHandlingEfficientlyThousandsOfOutstandingMissesInFpgas_FPGA19.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>Computer Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性规划松弛算法</title>
    <link href="/2020/10/06/OperationResearch/lpslack/"/>
    <url>/2020/10/06/OperationResearch/lpslack/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><div class="row">    <embed src="./lpslack.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Applied Operation Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Applied Operation Research</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TSP问题</title>
    <link href="/2020/10/06/OperationResearch/tsp/"/>
    <url>/2020/10/06/OperationResearch/tsp/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><div class="row">    <embed src="./TSP.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Applied Operation Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Applied Operation Research</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法</title>
    <link href="/2020/10/06/OperationResearch/greedy/"/>
    <url>/2020/10/06/OperationResearch/greedy/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><div class="row">    <embed src="./greedy.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    
    <tags>
      
      <tag>Applied Operation Research</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bin Packing的近似算法</title>
    <link href="/2020/10/06/OperationResearch/binpacking/"/>
    <url>/2020/10/06/OperationResearch/binpacking/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><div class="row">    <embed src="./Binpacking.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Applied Operation Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Applied Operation Research</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原始对偶算法</title>
    <link href="/2020/10/06/OperationResearch/primedual/"/>
    <url>/2020/10/06/OperationResearch/primedual/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><div class="row">    <embed src="./primedual.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Applied Operation Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Applied Operation Research</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对偶单纯形法</title>
    <link href="/2020/10/06/OperationResearch/dualsimplex/"/>
    <url>/2020/10/06/OperationResearch/dualsimplex/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><div class="row">    <embed src="./dualsimplex.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Applied Operation Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Applied Operation Research</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性规划的对偶</title>
    <link href="/2020/10/06/OperationResearch/LPdual/"/>
    <url>/2020/10/06/OperationResearch/LPdual/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><div class="row">    <embed src="./lpdual.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Applied Operation Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Applied Operation Research</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单纯形法</title>
    <link href="/2020/10/06/OperationResearch/simplex/"/>
    <url>/2020/10/06/OperationResearch/simplex/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><div class="row">    <embed src="./simplex.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Applied Operation Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Applied Operation Research</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>isms</title>
    <link href="/2020/09/15/isms/"/>
    <url>/2020/09/15/isms/</url>
    
    <content type="html"><![CDATA[<h2 id="机会主义"><a href="#机会主义" class="headerlink" title="机会主义"></a>机会主义</h2><p>wiki: 是一种有意识的策略或是行为，通过利用形势来自利肥己——常常不关心规则，不关心他人的处境。投机主义者的行为是以自利为主要驱动力的。该词可以描述人类个体或生物、群体、组织、风格、行为或倾向</p><h2 id="投降主义"><a href="#投降主义" class="headerlink" title="投降主义"></a>投降主义</h2><p>wiki: 冲突和纠纷中，无原则地放弃己方集团的利益，向敌对集团没有底线地迁就与妥协，放弃与敌对集团进行斗争的主张和思想。投降主义和一般寻求接触和谈判解决纠纷的妥协主义的区别在于，妥协政策设置了妥协的底线，即核心利益，而投降主义可以无条件的承诺敌对集团的要求，以避免对敌对集团发生激烈斗争。</p><blockquote><p>知乎问题: 机会主义和投降主义有什么区别?</p><p>一个是懒，一个是怂。</p><p>懒的那个总想抄近路，抄着抄着看不见最初的的目标了，然后就走歪了。</p><p>怂的那个没什么目标，是条好走的路就走，自然也走歪了。</p></blockquote><h2 id="考茨基主义"><a href="#考茨基主义" class="headerlink" title="考茨基主义"></a>考茨基主义</h2><p>他被列宁作为教条主义及对修正主义采取调和折中的中间派的代表加以抨</p><p>列宁认为考茨基是教条主义，把历史唯物主义理解为经济决定论，理解为一种“经验科学”；用理论排斥实践，无视实践的发展。</p><p>列宁在分析考茨基主义产生的社会根源时指出:考茨基主义不是偶然现象,而是第二国际各种矛盾的社会产物,是既要在口头上忠于马克思主义又要在实际上屈服于机会主义的社会产物。“中派”是一些被腐朽的合法性侵蚀了的,被议会制度的环境等等败坏了的守旧派,是习惯于待遇优厚的职位和“安稳”的工作的官吏。</p><h2 id="无政府主义"><a href="#无政府主义" class="headerlink" title="无政府主义"></a>无政府主义</h2><p>其目的在于提升个人自由及废除政府当局与所有的政府管理机构。无政府主义包含了众多哲学体系和社会运动实践。它的基本立场是反对包括政府在内的一切统治和权威，提倡个体之间的自助关系，关注个体的自由和平等；其政治诉求是消除政府以及社会上或经济上的任何独裁统治关系。对大多数无政府主义者而言，“无政府”一词并不代表混乱、虚无、或道德沦丧的状态，而是一种由自由的个体自愿结合，以建立互助、自治、反独裁主义的和谐社会。</p><p>马克思在驳斥无政府主义者时，反对的是他们废除国家的方式。马克思完全不是反对国家将随阶级的消失而消失，或国家将随阶级的废除而废除，而是反对要工人拒绝使用武器，拒绝使用有组织的暴力，即拒绝使用应为“粉碎资产阶级的反抗”这一目的服务的国家。</p><p>为什么反权威主义者不只限于高喊反对政治权威，反对国家呢？所有的社会主义者都认为, 国家及政治权威将由于未来的社会革命而消失，这就是说，社会职能将失去其政治性质，而变为维护真正社会利益的简单的管理职能。但是，反权威主义者却要求在产生政治国家的各种社会条件消除以前，一举把政治国家废除。他们要求把废除权威作为社会革命的第一个行动。</p><h2 id="沙文主义"><a href="#沙文主义" class="headerlink" title="沙文主义"></a>沙文主义</h2><p>原指极端的、不合理的、过分的爱国主义或民族主义。现在沙文主义定义为“认为自己的群体或人民优越于其他群体或人民的非理性信念”。也因此，沙文主义者会将自己的群体或人民视为独特的，而将其他的群体或人民视为平庸的。</p><p>词源是拿破仑手下的一名（有可能是位文艺上杜撰的）士兵尼古拉·沙文，他由于获得军功章对拿破仑感恩戴德，对拿破仑以军事力量征服其他民族的政策狂热崇拜。而“沙文主义”这个名词则首先出现在法国的一部戏剧“三色帽徽”中，以讽刺的口吻描写沙文的这种情绪。后来这个词被广泛应用，如大国沙文主义、民族沙文主义等，还曾被女权运动的领袖用于“男性沙文主义”（相当于“大男人主义”）</p><p>今日的沙文主义已经扩展到了对任何群体的不当偏爱和过度奉献，并尤其多的用于因该群体看不起局外人或者敌对势力时。</p><p>沙文主义者一般都是对自己所在的国家、民族和团体感到骄傲，因此看不起其他的国家、民族和团体。</p><h2 id="加速主义"><a href="#加速主义" class="headerlink" title="加速主义"></a>加速主义</h2><p>是一种政治与社会理论，认为资本主义制度或历史上某种技术相关的社会进程应该被加速以产生巨大社会变革。当代的加速主义哲学以德勒兹和伽塔利的理论为起点，旨在强化加速去领域化的力量，以克服阻碍深远社会变革可能性的对抗趋势。加速主义也可能指更广泛的支持资本主义的深化的观点，这些论点认为这将加速资本主义自我毁灭的倾向，并最终导致其崩溃。</p><p>加速论者的理论分为相互矛盾的左右派系。“左翼加速主义”试图将“技术演进的过程”从“资本主义的限制”中剥离，将现代技术改造为服务社会有益和解放的目的；“右翼加速主义”支持资本主义本身的无限强化，带来一个技术奇异点。</p><h2 id="民族主义"><a href="#民族主义" class="headerlink" title="民族主义"></a>民族主义</h2><p>通常是指认同本民族文化、传统、利益的一种意识形态，其旨在追求民族的生存、发展、兴盛。民族主义者往往认为民族拥有自我治理的主权，而不应受他人干涉，即民族拥有所谓“<a href="https://zh.wikipedia.org/wiki/民族自决权" target="_blank" rel="noopener">民族自决权</a>”，而这一观念则起源于<a href="https://zh.wikipedia.org/wiki/人民主权论" target="_blank" rel="noopener">人民主权论</a>。民族主义中的“民族”既可能是基于<a href="https://zh.wikipedia.org/wiki/語言" target="_blank" rel="noopener">语言</a>、<a href="https://zh.wikipedia.org/wiki/族群" target="_blank" rel="noopener">族裔</a>、<a href="https://zh.wikipedia.org/wiki/部落" target="_blank" rel="noopener">部落</a>或<a href="https://zh.wikipedia.org/wiki/人種" target="_blank" rel="noopener">种族</a>的团体，也可能是一国、一地之<a href="https://zh.wikipedia.org/wiki/公民" target="_blank" rel="noopener">公民</a>集体，还可能是某一宗教的信徒。</p><p>就民族主义的起源而言，早期学者多认为民族主义是自古已有的原生概念，有时会主张民族间存在着基因差异。而现代研究多认为民族是社会<a href="https://zh.wikipedia.org/wiki/现代化" target="_blank" rel="noopener">现代化</a>的产物，将18世纪<a href="https://zh.wikipedia.org/wiki/法国大革命" target="_blank" rel="noopener">法国大革命</a>和<a href="https://zh.wikipedia.org/wiki/民族國家" target="_blank" rel="noopener">民族国家</a>的形成视为民族主义的起源，而欧洲以外的民族主义都是扩散自欧洲，例如<a href="https://zh.wikipedia.org/wiki/本尼迪克特·安德森" target="_blank" rel="noopener">本尼迪克特·安德森</a>在《<a href="https://zh.wikipedia.org/wiki/想像的共同體_(書" target="_blank" rel="noopener">想象的共同体</a>)》中描述了民族作为“<a href="https://zh.wikipedia.org/wiki/想像的共同體" target="_blank" rel="noopener">想象的共同体</a>”的产生及其随着殖民扩张在世界范围扩散的轨迹。近年来，也有部分学者挑战民族主义的<a href="https://zh.wikipedia.org/wiki/歐洲中心主義" target="_blank" rel="noopener">欧洲中心论</a>，提出了与欧洲的民族国家相对的亚洲<a href="https://zh.wikipedia.org/wiki/文明国家" target="_blank" rel="noopener">文明国家</a>概念，其中代表即<a href="https://zh.wikipedia.org/wiki/中华文明" target="_blank" rel="noopener">中华文明</a>。</p><p>学界一般认为民族主义和政治上的<a href="https://zh.wikipedia.org/wiki/國族" target="_blank" rel="noopener">民族</a>、<a href="https://zh.wikipedia.org/wiki/主权" target="_blank" rel="noopener">主权</a>概念密不可分，但对于到底“什么是民族主义”乃至“什么是民族”仍莫衷一是，历史上民族（nation）一词要到<a href="https://zh.wikipedia.org/wiki/法国大革命" target="_blank" rel="noopener">法国大革命</a>时期才和<a href="https://zh.wikipedia.org/wiki/民族國家" target="_blank" rel="noopener">民族国家</a>等政治概念联系到一起，很多情况下不同地区、不同族群间的民族主义内容相差迥异，难以给出一个笼统的概括。而民族主义和不同的社会领域、意识形态的结合也使得其内容纷繁复杂，枝叶众多，既有<a href="https://zh.wikipedia.org/wiki/經濟民族主義" target="_blank" rel="noopener">经济民族主义</a>，也有<a href="https://zh.wikipedia.org/w/index.php?title=宗教民族主義&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">宗教民族主义</a>，既存在<a href="https://zh.wikipedia.org/wiki/極右派" target="_blank" rel="noopener">极右翼</a>的<a href="https://zh.wikipedia.org/wiki/法西斯主义" target="_blank" rel="noopener">法西斯主义</a>，也相应存在着<a href="https://zh.wikipedia.org/wiki/左翼民族主義" target="_blank" rel="noopener">左翼民族主义</a>；而最为常见的划分是将民族主义分为<a href="https://zh.wikipedia.org/wiki/公民民族主義" target="_blank" rel="noopener">公民民族主义</a>和<a href="https://zh.wikipedia.org/wiki/族群民族主义" target="_blank" rel="noopener">族裔民族主义</a>，反映了民族主义者“以国建族”和“以族建国”的两种政治倾向。</p><p><a href="https://zh.wikipedia.org/wiki/爱国主义" target="_blank" rel="noopener">爱国主义</a>及对统治者、土地、文化、宗教、血族的忠诚相伴人类文明始终，在<a href="https://zh.wikipedia.org/wiki/原生主义" target="_blank" rel="noopener">原生主义</a>者看来这就是民族主义的最初体现，而<a href="https://zh.wikipedia.org/wiki/建構主義" target="_blank" rel="noopener">建构主义</a>者则认为作为一种政治行动信条的民族主义直到18世纪才登上历史舞台——在此后民族主义既是<a href="https://zh.wikipedia.org/wiki/民族独立运动" target="_blank" rel="noopener">民族独立</a>和民族解放的重要动力，促成了<a href="https://zh.wikipedia.org/wiki/法国大革命" target="_blank" rel="noopener">法国大革命</a>、<a href="https://zh.wikipedia.org/wiki/德意志统一" target="_blank" rel="noopener">德意志统一</a>、<a href="https://zh.wikipedia.org/wiki/非洲的非殖民化" target="_blank" rel="noopener">非洲的去殖民化</a>、<a href="https://zh.wikipedia.org/wiki/苏联解体" target="_blank" rel="noopener">苏联解体</a>等一系列重大历史事件，也有着罄竹难书的阴暗之处，导致了<a href="https://zh.wikipedia.org/wiki/世界大戰" target="_blank" rel="noopener">两次世界大战</a>、<a href="https://zh.wikipedia.org/wiki/亚美尼亚种族大屠杀" target="_blank" rel="noopener">亚美尼亚大屠杀</a>、<a href="https://zh.wikipedia.org/wiki/猶太人大屠殺" target="_blank" rel="noopener">纳粹大屠杀</a>等惨绝人寰的悲剧发生。民族主义者在推动政治进程的同时，也创造出<a href="https://zh.wikipedia.org/wiki/国旗" target="_blank" rel="noopener">国旗</a>、<a href="https://zh.wikipedia.org/wiki/国歌" target="_blank" rel="noopener">国歌</a>、<a href="https://zh.wikipedia.org/wiki/民族語言" target="_blank" rel="noopener">国语</a>、<a href="https://zh.wikipedia.org/w/index.php?title=民族史诗&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">民族史诗</a>等一系列代表<a href="https://zh.wikipedia.org/wiki/國族認同" target="_blank" rel="noopener">民族认同</a>的民族象征物。时至今日，民族主义仍是社会的一大重要思潮，<a href="https://zh.wikipedia.org/wiki/极端民族主义" target="_blank" rel="noopener">极端民族主义</a>及其所引发的一系列纠纷仍威胁着世界的和平与稳定。</p><p>世界上绝大多数人口都生活在——至少是名义上的——民族国家之中<a href="https://zh.wikipedia.org/wiki/民族主義#cite_note-4" target="_blank" rel="noopener">[3]</a>，但大多数国家都存在着多民族、多族群的社会结构，只有日本、韩国在内10%左右的国家可以算是<a href="https://zh.wikipedia.org/wiki/單一民族國家" target="_blank" rel="noopener">纯粹的民族国家</a>，在这些国家民族主义和<a href="https://zh.wikipedia.org/wiki/爱国主义" target="_blank" rel="noopener">爱国主义</a>内涵比较一致；而此外的大多数国家都奉行着融合、平权、乃至压迫的政策来解决其国内的<a href="https://zh.wikipedia.org/wiki/民族問題" target="_blank" rel="noopener">民族问题</a>。<a href="https://zh.wikipedia.org/wiki/民族主義#cite_note-:6-5" target="_blank" rel="noopener">[4]</a></p><p>逆向民族主义</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Builder</title>
    <link href="/2020/08/27/DesignPatterns/Builder/"/>
    <url>/2020/08/27/DesignPatterns/Builder/</url>
    
    <content type="html"><![CDATA[<h2 id="Builder属于对象创建模式"><a href="#Builder属于对象创建模式" class="headerlink" title="Builder属于对象创建模式"></a>Builder属于对象创建模式</h2><p>通过对象创建模式绕开<code>new</code>, 来避免对象创建 (<code>new</code>) 过程中所导致的紧耦合(依赖具体类 )，从而支持对象创建的稳定。他是接口抽象之后的第一步工作。</p><p>典型模式有</p><ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>BuilderPrototype属于对象创建模式</li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li><p>在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这 个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在 一起的算法却相对稳定。</p></li><li><p>如何应对这种变化？如何提供一种”封装机制”来隔离出”复杂对象的各个部分”的变化，从而保持系统中的”稳定构建算法”不 随着需求改变而改变？</p></li></ul><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过 程(稳定)可以创建不同的表示(变化)</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">House</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>-&gt;BuildPart1();                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            <span class="hljs-keyword">this</span>-&gt;BuildPart2();        &#125;                <span class="hljs-keyword">bool</span> flag = <span class="hljs-keyword">this</span>-&gt;BuildPart3();                <span class="hljs-keyword">if</span>(flag) &#123;            <span class="hljs-keyword">this</span>-&gt;BuildPart4();        &#125;                <span class="hljs-keyword">this</span>-&gt;BuildPart5();    &#125;    <span class="hljs-keyword">virtual</span> ~House() &#123;&#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart3</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart4</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart5</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoneHouse</span>:</span> <span class="hljs-keyword">public</span> House &#123;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart1</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart2</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart3</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart4</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart5</span><span class="hljs-params">()</span> </span>&#123;&#125;&#125;</code></pre></div><p>我们会发现这份代码非常像template method</p><div class="note note-warning">            <p>有个疑问就是，既然是创建对象， 能不能把Init()函数改成构造函数</p>          </div><div class="note note-success">            <p>答案是不行，构造函数中调用虚函数用的是静态绑定</p>          </div><ul><li>重构</li></ul><p>拆分House类, HouseBuilder专管构建</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">House</span> &#123;</span>    <span class="hljs-comment">//...</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseBulder</span> &#123;</span>    House* pHouse;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>-&gt;BuildPart1();                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            <span class="hljs-keyword">this</span>-&gt;BuildPart2();        &#125;                <span class="hljs-keyword">bool</span> flag = <span class="hljs-keyword">this</span>-&gt;BuildPart3();                <span class="hljs-keyword">if</span>(flag) &#123;            <span class="hljs-keyword">this</span>-&gt;BuildPart4();        &#125;                <span class="hljs-keyword">this</span>-&gt;BuildPart5();    &#125;        <span class="hljs-function">House* <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> pHouse;    &#125;        <span class="hljs-keyword">virtual</span> ~HouseBuilder() &#123;&#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart3</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart4</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart5</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;&#125;</code></pre></div><ul><li>再重构 </li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">House</span> &#123;</span>    <span class="hljs-comment">//...</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseBulder</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">House* <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> pHouse;    &#125;        <span class="hljs-keyword">virtual</span> ~HouseBuilder() &#123;&#125;<span class="hljs-keyword">protected</span>:    House* pHouse;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart3</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart4</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildPart5</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseDirector</span> &#123;</span><span class="hljs-keyword">public</span>:    HouseBuilder* pHouseBuilder;<span class="hljs-function">House* <span class="hljs-title">Construct</span><span class="hljs-params">()</span> </span>&#123;        pHouseBuilder-&gt;BuildPart1();                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            pHouseBuilder-&gt;BuildPart2();        &#125;                <span class="hljs-keyword">bool</span> flag = pHouseBuilder-&gt;BuildPart3();                <span class="hljs-keyword">if</span>(flag) &#123;            pHouseBuilder-&gt;BuildPart4();        &#125;                pHouseBuilder-&gt;BuildPart5();        <span class="hljs-keyword">return</span> pHouseBuilder-&gt;getResult();    &#125;&#125;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200827143019216.png" srcset="/img/loading.gif" alt="image-20200827143019216" style="zoom:67%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中 “分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。</p></li><li><p>变化点在哪里，封装哪里—— Builder模式主要在于应对”复杂对 象各个部分”的频繁需求变动。其缺点在于难以应对”分步骤构建 算法”的需求变动。</p></li><li><p>在Builder模式中，要注意不同语言中构造器内调用虚函数的差别 （C++ vs. C#) 。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Prototype 原型模式</title>
    <link href="/2020/08/26/DesignPatterns/Prototype/"/>
    <url>/2020/08/26/DesignPatterns/Prototype/</url>
    
    <content type="html"><![CDATA[<h2 id="Prototype属于对象创建模式"><a href="#Prototype属于对象创建模式" class="headerlink" title="Prototype属于对象创建模式"></a>Prototype属于对象创建模式</h2><p>通过对象创建模式绕开<code>new</code>, 来避免对象创建 (<code>new</code>) 过程中所导致的紧耦合(依赖具体类 )，从而支持对象创建的稳定。他是接口抽象之后的第一步工作。</p><p>典型模式有</p><ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>这是factory method的动机</li></ul><blockquote><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化， 需要创建的对象的具体类型经常变化。</p><p>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种”封装机制”来避免客户程序和这种”具体对象创建工作”的紧耦合？</p></blockquote><ul><li>这是prototype的动机</li></ul><blockquote><p>在软件系统中，经常面临着”<u>某些结构复杂的对象</u>“的创建工作；由于需求的变化， 这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。</p><p>如何应对这种变化？如何向”客户程序(使用这些对象的程序)”隔离出这些”易变对象”，从而使得”依赖这些易变对象的客户程序”不随着需求改变而改变?</p><p>（maybe类似游戏读档</p></blockquote><p>非常相似是不是，知识prototype中面对的是结构复杂的对象</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>使用原型实例指定创建对象的种类，然后通过<u>拷贝</u>这些原型来创建新的对象。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h4 id="这是Factory-method中使用的代码"><a href="#这是Factory-method中使用的代码" class="headerlink" title="这是Factory method中使用的代码"></a>这是Factory method中使用的代码</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//抽象类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~ISplitter() &#123;&#125;&#125;;<span class="hljs-comment">//工厂基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~SplitterFactory()&#123;&#125;    &#125;&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//具体类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySpliter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;  &#125;;<span class="hljs-comment">//具体工厂</span>BinarySplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BinarySplitter();    &#125;&#125;;TxtSplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TxtSplitter();    &#125;&#125;;PictureSplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PictureSplitter();    &#125;&#125;;VideoSplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VideoSplitter();    &#125;&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    SplitterFactory* factory;<span class="hljs-keyword">public</span>:    MainForm(SplitterFactory* factory) &#123;        <span class="hljs-keyword">this</span>-&gt;factory = factory;    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//多态new</span>ISplitter* splitter = factory-&gt;CreateSplitter();        splitter-&gt;split;    &#125;&#125;</code></pre></div><h4 id="在prototype中-合并ISplitter-SplitterFactory"><a href="#在prototype中-合并ISplitter-SplitterFactory" class="headerlink" title="在prototype中, 合并ISplitter, SplitterFactory"></a>在prototype中, 合并ISplitter, SplitterFactory</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span> &#123;</span><span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//通过clone自己来创建对象</span>        <span class="hljs-keyword">virtual</span> ~ISplitter() &#123;&#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//具体类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySpliter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BinarySplitter(*<span class="hljs-keyword">this</span>);    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TxtSplitter(*<span class="hljs-keyword">this</span>);    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PictureSplitter(*<span class="hljs-keyword">this</span>);    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;  <span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VideoSplitter(*<span class="hljs-keyword">this</span>);    &#125;&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    ISplitter* prototype;<span class="hljs-keyword">public</span>:    MainForm(SplitterFactory* prototype) &#123;        <span class="hljs-keyword">this</span>-&gt;prototype = prototype;<span class="hljs-comment">//原型对象是供clone的</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;ISplitter* splitter = prototype-&gt;clone();        splitter-&gt;split;    &#125;&#125;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200826132954596.png" srcset="/img/loading.gif" alt="image-20200826132954596" style="zoom:67%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Prototype模式同样用于隔离类独享的使用者和具体类型(易变类)之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口</li><li>Prototype模式对于”如何创建易变类的尸体对象”采用”原型克隆”的方法来做，它使得我们可以非常灵活的动态创建”拥有某些稳定接口”的新对象—所需工作仅仅是注册一个新类的对象(即原型)，然后在任何需要的地方Clone</li><li>Prototype模式中的clone方法可以利用某些框架中的序列化来实现深拷贝。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Terminal AddOns</title>
    <link href="/2020/08/23/AddOns/"/>
    <url>/2020/08/23/AddOns/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/romkatv/powerlevel10k" target="_blank" rel="noopener">powerlevel10k</a>: a theme for Zsh. It emphasizes <a href="https://github.com/romkatv/powerlevel10k#uncompromising-performance" target="_blank" rel="noopener">speed</a>, <a href="https://github.com/romkatv/powerlevel10k#extremely-customizable" target="_blank" rel="noopener">flexibility</a> and <a href="https://github.com/romkatv/powerlevel10k#configuration-wizard" target="_blank" rel="noopener">out-of-the-box experience</a>.</li></ul><ul><li><a href="https://github.com/SpaceVim/SpaceVim" target="_blank" rel="noopener">SpaceVim</a>: SpaceVim is a community-driven modular Vim distribution. It manages collections of plugins in layers, which help to collect related packages together to provide IDE-like features. SpaceVim is not just a vimrc but an ultimate Vim configuration, It contains many built-in features.</li></ul><p><img src="image-20200823172304012.png" srcset="/img/loading.gif" alt="image-20200823172304012" style="zoom:50%;" /></p><p><img src="image-20200823174451884.png" srcset="/img/loading.gif" alt="image-20200823174451884" style="zoom:50%;" /></p><ul><li><a href="https://github.com/Mayccoll/Gogh" target="_blank" rel="noopener">Gogh</a> : color theme</li></ul><p><img src="image-20200823172029258.png" srcset="/img/loading.gif" alt="image-20200823172029258" style="zoom:50%;" /></p><p><br></p><p>Vim clipboard无法使用的问题:</p><ul><li>linux</li></ul><div class="hljs"><pre><code class="hljs shell">sudo apt-get install vim-gnome</code></pre></div><p>安装后执行</p><div class="hljs"><pre><code class="hljs shell">vim --version | grep "clipboard"</code></pre></div><p>可以发现clipboard前面有一个加号</p><ul><li>MacOS</li></ul><p>弄了半天还是不行，不搞了，可恶</p><p>那就这样吧</p><p>To copy the current line, in command mode type:</p><div class="hljs"><pre><code class="hljs 1c"><span class="hljs-string">"*yy</span></code></pre></div><p>To copy the whole file/buffer, in command mode, first go to the beginning via <code>gg</code>, then type</p><div class="hljs"><pre><code class="hljs 1c"><span class="hljs-string">"*yG</span></code></pre></div><p><code>&quot;*5yy</code> says <code>5 lines yanked</code> </p>]]></content>
    
    
    
    <tags>
      
      <tag>Terminal</tag>
      
      <tag>Theme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMware虚拟机共享本机vpn</title>
    <link href="/2020/08/21/UbuntuNet/"/>
    <url>/2020/08/21/UbuntuNet/</url>
    
    <content type="html"><![CDATA[<ul><li>设置windows上的vpn为允许其他设备接入</li></ul><p><img src="image-20200821203437531.png" srcset="/img/loading.gif" alt="image-20200821203437531" style="zoom: 80%;" /></p><ul><li>找到windows的IPv4地址。打开cmd, 敲下命令</li></ul><div class="hljs"><pre><code class="hljs shell">ipconfig</code></pre></div><p><img src="image-20200821203549431.png" srcset="/img/loading.gif" alt="image-20200821203549431" style="zoom:80%;" /></p><ul><li>将虚拟机的网络更改到桥接NAT模式</li></ul><p><img src="826F8F12DC215AB8D882501214537913.png" srcset="/img/loading.gif" alt="826F8F12DC215AB8D882501214537913" style="zoom:80%;" /></p><ul><li>打开ubuntu的网络设置</li></ul><p><img src="image-20200821203806669.png" srcset="/img/loading.gif" alt="image-20200821203806669" style="zoom:67%;" /></p><ul><li>设置代理服务器</li></ul><p><img src="image-20200821203833106.png" srcset="/img/loading.gif" alt="image-20200821203833106" style="zoom:80%;" /></p><p>这时浏览器已经可以上网，但是命令行还不行，还需要另外设置。</p><ul><li>open ubuntu terminal，输入如下内容</li></ul><div class="hljs"><pre><code class="hljs shell">export http_proxy=...export https_proxy=......</code></pre></div><p><img src="image-20200821203938024.png" srcset="/img/loading.gif" alt="image-20200821203938024" style="zoom:80%;" /></p><ul><li>最后，可以使用vpn🌶️</li></ul><p><img src="image-20200821204028331.png" srcset="/img/loading.gif" alt="image-20200821204028331"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Ubuntu VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Abstract Factory</title>
    <link href="/2020/08/21/DesignPatterns/AbstractFactory/"/>
    <url>/2020/08/21/DesignPatterns/AbstractFactory/</url>
    
    <content type="html"><![CDATA[<h2 id="Abstract-Factory属于对象创建模式"><a href="#Abstract-Factory属于对象创建模式" class="headerlink" title="Abstract Factory属于对象创建模式"></a>Abstract Factory属于对象创建模式</h2><p>通过对象创建模式绕开<code>new</code>, 来避免对象创建 (<code>new</code>) 过程中所导致的紧耦合(依赖具体类 )，从而支持对象创建的稳定。他是接口抽象之后的第一步工作。</p><p>典型模式有</p><ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li><p>在软件系统中，经常面临着”<u>一系列相互依赖的对象</u>“的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。</p></li><li><p>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种”封装机制”来避免客户程序和这种”多系列具体对象创建工作” 的紧耦合？</p></li></ul><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>提供一个接口，让该接口负责创建一系列”相关或者相互依赖的对象”，无需指定它们具体的类。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>任务是写一个数据访问层。数据库可能会有各种各样的变化。可能是sqlserver, oracel, mysql, 因此对应的类型就需要变化。但是下面的代码的new并不是多态new</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span>    <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;        SqlConnection* connection =            <span class="hljs-keyword">new</span> SqlConnection();        connection-&gt;ConnectionString = <span class="hljs-string">"..."</span>;        SqlCommand* command =            <span class="hljs-keyword">new</span> SqlCommand();        command-&gt;CommandText=<span class="hljs-string">"..."</span>;        command-&gt;SetConnection(connection);        SqlDataReader* reader = command-&gt;ExecuteReader();        <span class="hljs-keyword">while</span> (reader-&gt;Read())&#123;        &#125;    &#125;&#125;;</code></pre></div><ul><li>重构</li></ul><p>要支持多态new, 马上就想到了factory method.</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//数据库访问有关的基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnection</span>&#123;</span>    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnectionFactory</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommand</span>&#123;</span>    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommandFactory</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReader</span>&#123;</span>    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReaderFactory</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;&#125;;<span class="hljs-comment">//支持SQL Server</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnectionFactory</span>:</span><span class="hljs-keyword">public</span> IDBConnectionFactory&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommandFactory</span>:</span><span class="hljs-keyword">public</span> IDBCommandFactory&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReaderFactory</span>:</span><span class="hljs-keyword">public</span> IDataReaderFactory&#123;&#125;;<span class="hljs-comment">//支持Oracle</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span>    IDBConnectionFactory* dbConnectionFactory;    IDBCommandFactory* dbCommandFactory;    IDataReaderFactory* dataReaderFactory;    <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;        IDBConnection* connection =            dbConnectionFactory-&gt;CreateDBConnection();        connection-&gt;ConnectionString(<span class="hljs-string">"..."</span>);        IDBCommand* command =            dbCommandFactory-&gt;CreateDBCommand();        command-&gt;CommandText(<span class="hljs-string">"..."</span>);        command-&gt;SetConnection(connection); <span class="hljs-comment">//关联性</span>        IDBDataReader* reader = command-&gt;ExecuteReader(); <span class="hljs-comment">//关联性</span>        <span class="hljs-keyword">while</span> (reader-&gt;Read())&#123;        &#125;    &#125;&#125;;</code></pre></div><p>但是，这样的问题是IDBConnection, IDBCommand, IDBDataReader可能并不对应，比如一个是oracel的connection, 一个是mysql的command。因此产生关联性问题。</p><ul><li>继续重构</li></ul><p>把connection, command, datareader凝聚到一个类中, 这样就能得到关联性的保证。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//数据库访问有关的基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBConnection</span>&#123;</span>    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBCommand</span>&#123;</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDataReader</span>&#123;</span>    &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDBFactory</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;    &#125;;<span class="hljs-comment">//支持SQL Server</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlDBFactory</span>:</span><span class="hljs-keyword">public</span> IDBFactory&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span> </span>&#123;&#125; &#125;;<span class="hljs-comment">//支持Oracle</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleConnection</span>:</span> <span class="hljs-keyword">public</span> IDBConnection&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleCommand</span>:</span> <span class="hljs-keyword">public</span> IDBCommand&#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleDataReader</span>:</span> <span class="hljs-keyword">public</span> IDataReader&#123;  &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OracleDBFactory</span>:</span><span class="hljs-keyword">public</span> IDBFactory&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBConnection* <span class="hljs-title">CreateDBConnection</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDBCommand* <span class="hljs-title">CreateDBCommand</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> IDataReader* <span class="hljs-title">CreateDataReader</span><span class="hljs-params">()</span> </span>&#123;&#125; &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDAO</span>&#123;</span>    IDBFactory* dbFactory;    <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;EmployeeDO&gt; <span class="hljs-title">GetEmployees</span><span class="hljs-params">()</span></span>&#123;        IDBConnection* connection =            dbFactory-&gt;CreateDBConnection();        connection-&gt;ConnectionString(<span class="hljs-string">"..."</span>);        IDBCommand* command =            dbFactory-&gt;CreateDBCommand();        command-&gt;CommandText(<span class="hljs-string">"..."</span>);        command-&gt;SetConnection(connection); <span class="hljs-comment">//关联性</span>        IDBDataReader* reader = command-&gt;ExecuteReader(); <span class="hljs-comment">//关联性</span>        <span class="hljs-keyword">while</span> (reader-&gt;Read())&#123;        &#125;    &#125;&#125;;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200821143526358.png" srcset="/img/loading.gif" alt="image-20200821143526358" style="zoom:50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>如果没有应对”多系列对象构建”的需求变化，则没有必要使用 Abstract Factory模式，这时候使用简单的工厂完全可以。</p></li><li><p>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、 或作用的关系。不同系列的对象之间不能相互依赖。</p></li><li><p>Abstract Factory模式主要在于应对”新系列”的需求变动。其缺 点在于难以应对”新对象”的需求变动。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Factory Method 工厂模式</title>
    <link href="/2020/08/14/DesignPatterns/FactoryMethod/"/>
    <url>/2020/08/14/DesignPatterns/FactoryMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="Factory-Method属于对象创建模式"><a href="#Factory-Method属于对象创建模式" class="headerlink" title="Factory Method属于对象创建模式"></a>Factory Method属于对象创建模式</h2><p>通过对象创建模式绕开<code>new</code>, 来避免对象创建 (<code>new</code>) 过程中所导致的紧耦合(依赖具体类 )，从而支持对象创建的稳定。他是接口抽象之后的第一步工作。</p><p>典型模式有</p><ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化， 需要创建的对象的具体类型经常变化。</p><p>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种”封装机制”来避免客户程序和这种”具体对象创建工作”的紧耦合？</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使得一个类的实例化延迟（目的：解耦， 手段：虚函数）到子类。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>初始代码，一个文件分割器。</p><p>这个代码会有什么问题呢？要从变化的场景去看。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;FileSplitter* splitter = <span class="hljs-keyword">new</span> FileSplitter();        splitter-&gt;split;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSpitter</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>最开始我们讲过一个原则：面向接口的编程。一个对象的类型应该声明成抽象类或者接口，而不应该声明成具体的类。如果声明成具体的类，就把他定死了，无法应对未来的变化。</p><p>假设我们产生了新的需求：</p><p>需要支持二进制文件，txt文件，图片文件，视频文件的分割</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span> &#123;</span> <span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~ISplitter() &#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySpliter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;  &#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">/*******************问题产生了******************/</span>ISplitter* splitter = <span class="hljs-keyword">new</span> BinarySplitter(); <span class="hljs-comment">//??????怎么又依赖细节了？？？</span>        splitter-&gt;split;    &#125;&#125;</code></pre></div><div class="note note-warning">            <p><code>new</code>不能new抽象类，<code>new</code>只能new具体类。但是我们需要的是多态<code>new</code>。怎么解决呢？</p>          </div><ul><li>开始重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//return new ISplitter(...);//这样也是不对的，因为不能new抽象类</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BinarySplitter();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span> &#123;</span> <span class="hljs-comment">//接口</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~ISplitter() &#123;&#125;&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;SplitterFactory factory;ISplitter* splitter = factory.CreateSplitter();        splitter-&gt;split;    &#125;&#125;</code></pre></div><p>但是这种实现根本没有解决问题，<code>ISplitter* splitter = factory.CreateSplitter();</code>依然依赖于具体的类BinarySplitter</p><ul><li>继续重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//抽象类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISplitter</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~ISplitter() &#123;&#125;&#125;;<span class="hljs-comment">//工厂基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplitterFactory</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~SplitterFactory()&#123;&#125;    &#125;&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;SplitterFactory* factory;<span class="hljs-comment">//多态了</span>ISplitter* splitter = factory-&gt;CreateSplitter();        splitter-&gt;split;    &#125;&#125;</code></pre></div><ul><li>继续完善</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//具体类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySpliter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxtSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PictureSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VideoSplitter</span>:</span> <span class="hljs-keyword">public</span> ISplitter &#123;  &#125;;<span class="hljs-comment">//具体工厂</span>BinarySplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BinarySplitter();    &#125;&#125;;TxtSplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TxtSplitter();    &#125;&#125;;PictureSplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PictureSplitter();    &#125;&#125;;VideoSplitterFactory: <span class="hljs-keyword">public</span> SplitterFactory &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">virutal ISplitter* <span class="hljs-title">CreateSplitter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VideoSplitter();    &#125;&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    SplitterFactory* factory;<span class="hljs-keyword">public</span>:    MainForm(SplitterFactory* factory) &#123;        <span class="hljs-keyword">this</span>-&gt;factory = factory;    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//多态new</span>ISplitter* splitter = factory-&gt;CreateSplitter();        splitter-&gt;split;    &#125;&#125;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200814150354579.png" srcset="/img/loading.gif" alt="image-20200814150354579" style="zoom:50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导 致软件的脆弱。</p></li><li><p>Factory Method模式通过面向对象的手法，将所要创建的具体对 象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。</p></li><li><p>Factory Method模式解决”单个对象”的需求变化。缺点在于要求创建方法/参数相同。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bridge 桥模式</title>
    <link href="/2020/08/11/DesignPatterns/Bridge/"/>
    <url>/2020/08/11/DesignPatterns/Bridge/</url>
    
    <content type="html"><![CDATA[<h2 id="Bridge属于”单一职责”模式"><a href="#Bridge属于”单一职责”模式" class="headerlink" title="Bridge属于”单一职责”模式"></a>Bridge属于”单一职责”模式</h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码， 这时候的关键是划清责任。</p><ul><li><p>典型模式</p><p>• Decorator</p><p>• Bridge</p></li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>由于某些类型的固有的实现逻辑，使得它们具有<u>两个变化的维度， 乃至多个纬度</u>的变化。</p><p>如何应对这种”多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>将抽象部分(业务功能)与实现部分(平台实现)分离，使他们都可以独立地变化</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>一个通信模块Messager。根据平台分为PC, Mobile，派生出两个子类PCMessagerBase, MobileMessagerBase。根据业务分成perfect和lite, 前面的两个子类又派生出PCMessagerLite, PCMessagerPerfect, MobileMessagerLite, MobileMessagerPerfect.</p><p>如果设平台有n中选择，业务有m中，那么类的数目为$1 + n + m * n$</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Message() &#123;&#125;&#125;<span class="hljs-comment">//平台实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;; <span class="hljs-comment">//业务抽象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerLite</span>:</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        PCMessagerBase::Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        PCMessagerBase::WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        PCMessagerBase::DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerPerfect</span>:</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;PCMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        PCMessagerBase::Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;PCMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        PCMessagerBase::WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        PCMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        PCMessagerBase::DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerLite</span>:</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        MobileMessagerBase::Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        MobileMessagerBase::WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        MobileMessagerBase::DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerPerfect</span>:</span> <span class="hljs-keyword">public</span> PCMessagerBase &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;MobileMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        MobileMessagerBase::Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;MobileMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        MobileMessagerBase::WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        MobileMessagerBase::PlaySound();        <span class="hljs-comment">//******</span>        MobileMessagerBase::DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;</code></pre></div><p>但是这样设置的类有很多的结构性重复。比如PCMessagerPerfect, MobileMessagerPerfect。</p><ul><li>重构</li></ul><p>将PCMessagerLite, PCMessagerPerfect, MobileMessagerLite, MobileMessagerPerfect的继承改为组合。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Message() &#123;&#125;&#125;<span class="hljs-comment">//平台实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;; <span class="hljs-comment">//业务抽象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerLite</span> &#123;</span>    Messager* messager;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        messager-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        messager-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        messager-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerPerfect</span> &#123;</span>    Messager* messager;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;messager-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messager-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;messager-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messager-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;       messager-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messager-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;</code></pre></div><p>注意，这样修改之后并不是完整的，因为MessagerLite和MessagerPerfect没有了PlaySound, Connect…这些函数</p><ul><li>继续重构</li></ul><p>可以看到平台类在重载PlaySound, PlaySound, WriteText, Connect这几个函数。而业务类在重载Login, SendMessage, SendPicture这几个函数。因此把这两块函数放在一个类里面是不合适的，我们把他们拆分成两个类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Message() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerImp</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~MessageImp() &#123;&#125;&#125;<span class="hljs-comment">//平台实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span>:</span> <span class="hljs-keyword">public</span> MessagerImp &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span>:</span> <span class="hljs-keyword">public</span> MessagerImp &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;; <span class="hljs-comment">//业务抽象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerLite</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;    MessagerImp* messagerImp;<span class="hljs-comment">//...</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        messagerImp-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        messagerImp-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        messagerImp-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerPerfect</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;    MessagerImp* messagerImp;<span class="hljs-comment">//...</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;       messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;</code></pre></div><ul><li>再重构</li></ul><p>可以看到MessageLite和MessagerPerfect这两个类里面都有MessagerImp字段。根据重构的原则，应该将他往上提到Messager类中。</p><p>最终类的数目编程$1+n+m$</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Messager</span> &#123;</span><span class="hljs-keyword">protected</span>:    MessagerImp* messagerImp;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Message() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerImp</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~MessageImp() &#123;&#125;&#125;<span class="hljs-comment">//平台实现</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCMessagerBase</span>:</span> <span class="hljs-keyword">public</span> MessagerImp &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobileMessagerBase</span>:</span> <span class="hljs-keyword">public</span> MessagerImp &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlaySound</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawShape</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//******</span>    &#125;&#125;; <span class="hljs-comment">//业务抽象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerLite</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;        messagerImp-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;        messagerImp-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;        messagerImp-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessagerPerfect</span>:</span> <span class="hljs-keyword">public</span> Messager &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> password)</span> </span>&#123;messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;Connect();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(<span class="hljs-built_in">string</span> message)</span> </span>&#123;messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;WriteText();        <span class="hljs-comment">//......</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendPicture</span><span class="hljs-params">(Image image)</span> </span>&#123;       messagerImp-&gt;PlaySound();        <span class="hljs-comment">//******</span>        messagerImp-&gt;DrawShape();        <span class="hljs-comment">//......</span>    &#125;&#125;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200811150059187.png" srcset="/img/loading.gif" alt="image-20200811150059187" style="zoom:50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Bridge模式使用”对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓 抽象和实现沿着各自纬度的变化，即”子类化”它们。</p></li><li><p>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。 Bridge模式是比多继承方案更好的解决方法。</p></li><li><p>Bridge模式的应用一般在”两个非常强的变化维度”，有时一个 类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Decorator</title>
    <link href="/2020/08/07/DesignPatterns/Decorator/"/>
    <url>/2020/08/07/DesignPatterns/Decorator/</url>
    
    <content type="html"><![CDATA[<h2 id="Decorator属于”单一职责”模式"><a href="#Decorator属于”单一职责”模式" class="headerlink" title="Decorator属于”单一职责”模式"></a>Decorator属于”单一职责”模式</h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码， 这时候的关键是划清责任。</p><ul><li><p>典型模式</p><p>• Decorator</p><p>• Bridge</p></li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在某些情况下我们可能会”过度地使用继承来扩展对象的功能”， 由于继承为类型引入的<strong>静态特质</strong>，使得这种扩展方式缺乏灵活性； 并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</p><p>如何使”对象功能的扩展”能够根据需要来动态地实现？同时避免”扩展功能的增多”带来的子类膨胀问题？从而使得任何”功能扩展变化”所导致的影响将为最低？</p><p>所谓静态特质, 比如在CryptoNetworkStream的Read函数中定死了调用NetworkStream::Read(), 而我们重构后的CryptoStream中的Read函数调用stream-&gt;Read(), 支持多态，可以产生变化。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面给出一个Stream代码示例，其继承关系如下所示</p><p><img src="image-20200807143722316.png" srcset="/img/loading.gif" alt="image-20200807143722316" style="zoom:30%;" /></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//业务操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stream</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>= <span class="hljs-number">0</span>;        <span class="hljs-keyword">virtual</span> ~Stream() &#123;&#125;&#125;;<span class="hljs-comment">//主体类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读文件流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位文件流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写文件流</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读网络流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位网络流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写网络流</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//读内存流</span>&#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//定位内存流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;        <span class="hljs-comment">//写内存流</span>    &#125;&#125;;<span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        FileStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoNetworkStream</span>:</span> <span class="hljs-keyword">public</span> NetworkStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        NetworkStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoMemoryStream</span>:</span> <span class="hljs-keyword">public</span> MemoryStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        MemoryStream::Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedNetworkStream</span>:</span> <span class="hljs-keyword">public</span> NetworkStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedMemoryStream</span>:</span> <span class="hljs-keyword">public</span> MemoryStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoBufferedFileStream</span>:</span> <span class="hljs-keyword">public</span> FileStream &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Read(number);<span class="hljs-comment">//读文件流</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Seek(position);<span class="hljs-comment">//定位文件流</span>        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>        FileStream::Write(position);<span class="hljs-comment">//写文件流</span>        <span class="hljs-comment">//额外的加密操作...</span>        <span class="hljs-comment">//额外的缓冲操作...</span>    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//编译时装配</span>    CryptoFileStream* fs1 = <span class="hljs-keyword">new</span> CryptoFileStream();        BufferedFileStream* fs2 = <span class="hljs-keyword">new</span> BufferedFileStream();        CryptoBufferedFileStream* fs3 = <span class="hljs-keyword">new</span> CryptoBufferedFileStream();&#125;</code></pre></div><p>这样设计的代码存在大量的冗余，比如对于不同的stream, 无论是FileStream还是NetworkStream还是MemoryStream, 他们的加密操作都是一样的。</p><ul><li>重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoFileStream</span> &#123;</span>    FileStream* stream;<span class="hljs-comment">//=new FileStream()</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoNetworkStream</span> &#123;</span>    NetworkStream* stream;<span class="hljs-comment">//=new NetworkStream();</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoMemoryStream</span> &#123;</span>    MemoryStream* stream;<span class="hljs-comment">//=new MemoryStream();</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;</code></pre></div><ul><li>继续重构</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;    Stream* stream;<span class="hljs-comment">//...</span><span class="hljs-keyword">public</span>:    CryptoStream(Stream* stm): stream(stm) &#123;            &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;    Stream* stream; <span class="hljs-comment">//...</span>    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//运行时装配</span>    FileStream* s1 = <span class="hljs-keyword">new</span> FileStream();    CryptoStream* s2 = <span class="hljs-keyword">new</span> CryptoStream(s1);    BufferedStream* s3 = <span class="hljs-keyword">new</span> BufferedStream(s1);    BufferedStream* s4 = <span class="hljs-keyword">new</span> BufferedStream(s2);&#125;</code></pre></div><p>很神奇，CryptoStream既有Stream基类，也有Stream字段。这里还需要继承Stream是因为他定义了基类的接口规范</p><ul><li>继续重构</li></ul><p>CryptoStream, BufferedStream都有Stream这个字段，把他们提到一个中间类中，</p><p>设置一个DecoratorStream中间类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//扩展操作</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoratorStream</span>:</span> <span class="hljs-keyword">public</span> Stream &#123;<span class="hljs-keyword">protected</span>:    Stream* stream; <span class="hljs-comment">//...</span>    DecoratorStream(Stream* stm): DecoratorStream(stm) &#123;            &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoStream</span>:</span> <span class="hljs-keyword">public</span> DecoratorStream &#123;<span class="hljs-keyword">public</span>:    CryptoStream(Stream* stm): DecoratorStream(stm) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Read(number);    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Seek(position);        <span class="hljs-comment">//额外的加密操作</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span> </span>&#123;        <span class="hljs-comment">//额外的加密操作...</span>        stream-&gt;Write(data);        <span class="hljs-comment">//额外的加密操作...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedStream</span>:</span> <span class="hljs-keyword">public</span> DecoratorStream &#123;    <span class="hljs-comment">//...</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//运行时装配</span>    FileStream* s1 = <span class="hljs-keyword">new</span> FileStream();    CryptoStream* s2 = <span class="hljs-keyword">new</span> CryptoStream(s1);    BufferedStream* s3 = <span class="hljs-keyword">new</span> BufferedStream(s1);    BufferedStream* s4 = <span class="hljs-keyword">new</span> BufferedStream(s2);&#125;</code></pre></div><p>新的类关系</p><p><img src="image-20200807143823919.png" srcset="/img/loading.gif" alt="image-20200807143823919" style="zoom:30%;" /></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200807160507597.png" srcset="/img/loading.gif" alt="image-20200807160507597" style="zoom:50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免 了使用继承带来的”灵活性差”和”多子类衍生问题”。</p></li><li><p>Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又 表现为has-a Component的组合关系，即Decorator类又使用了 另外一个Component类。</p></li><li><p>Decorator模式的目的并非解决”多子类衍生的多继承”问题，Decorator模式应用的要点在于解决”主体类在多个方向上的扩展 功能”——是为”装饰”的含义。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="/2020/08/06/DesignPatterns/Principle/"/>
    <url>/2020/08/06/DesignPatterns/Principle/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>变化是复用的天敌！ 面向对象设计最大的优势在于：<u><strong><em>抵御变化</em></strong></u></p>          </div><h4 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 (DIP)"></a>依赖倒置原则 (DIP)</h4><ul><li><p>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。</p></li><li><p>抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。</p></li></ul><p><br></p><h4 id="开放封闭原则-OCP"><a href="#开放封闭原则-OCP" class="headerlink" title="开放封闭原则 (OCP)"></a>开放封闭原则 (OCP)</h4><ul><li><p>对扩展开放，对更改封闭。</p></li><li><p>类模块应该是可扩展的，但是不可修改。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Observer 观察者模式</title>
    <link href="/2020/08/06/DesignPatterns/Observer/"/>
    <url>/2020/08/06/DesignPatterns/Observer/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，我们需要为某些对象建立一种”通知依赖关系” </p><p><u>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密， 将使软件不能很好地抵御变化</u>。</p><p>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>定义对象间的一种<u><strong><em>一对多</em></strong></u>（变化）的依赖关系，以便当一个 对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并<u><strong><em>自动更新</em></strong></u>。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>考虑一个文件分割器程序，将一个大文件分割成几个小文件。</p><p>我们有一个主界面MainForm (在这里是一个观察者), 里面有两个对象，一个是文件路径，一个是分割成的文件都个数。当button click时就会调用filesplitter将文件分割</p><p>代码如下</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;<span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber):    m_filePath(filePath),    m_fileNumber(fileNumber) &#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>        &#125;    &#125;&#125;</code></pre></div><h4 id="需求1：文件分割进度条"><a href="#需求1：文件分割进度条" class="headerlink" title="需求1：文件分割进度条"></a>需求1：文件分割进度条</h4><ul><li>第一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form &#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;<span class="hljs-comment">/***增加progress bar***/</span>    ProgressBar* progressBar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;<span class="hljs-comment">/***增加progres bar***/</span>    ProgressBar* m_progressBar;<span class="hljs-keyword">public</span>:<span class="hljs-comment">/***增加初始化参数***/</span>    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, ProgressBar* progressBar):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_progressBar(progressBar)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span><span class="hljs-comment">/***更新progress bar***/</span>            <span class="hljs-keyword">if</span>(m_progressBar != <span class="hljs-literal">NULL</span>) &#123;                m_progressBar-&gt;setValue((i + <span class="hljs-number">1</span>) / m_fileNumber);            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="note note-warning">            <p>但是这种实现方式违反了<u>依赖倒置原则</u>。FileSplitter依赖ProgressBar 这样一种具体的实现细节，但是进度条的种类和展现形式是变化的，如果我们想将进度条换一种展现形式，比如不断打点，那么就会面临需求变更的困扰。</p>          </div><ul><li>第二种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    <span class="hljs-comment">//ProgressBar* m_progressBar; 这是一个通知控件</span>    IProgress* m_iprogress; <span class="hljs-comment">//抽象通知机制</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, IProgress* iprogress):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_iprogress(iprogress)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">if</span>(m_iprogress != <span class="hljs-literal">NULL</span>) &#123;                <span class="hljs-keyword">float</span> progressValue = m_fileNumber;                progressValue = (i + <span class="hljs-number">1</span>) / progressValue;                m_iprogress-&gt;DoProgress(progressValue); <span class="hljs-comment">//更新进度条</span>            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress&#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressbar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;        splitter.split();    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        progressBar-&gt;setValue(value);    &#125;&#125;</code></pre></div><p>C++支持多继承，但是不推荐使用多继承，因为会带来很多耦合的问题。但是有一种情况是推荐使用多继承的，一个主的继承类，其他都是接口  (单继承多实现), 这里就属于这种情况</p><ul><li>再修改一下</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    <span class="hljs-comment">//ProgressBar* m_progressBar; 这是一个通知控件</span>    IProgress* m_iprogress; <span class="hljs-comment">//抽象通知机制</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber, IProgress* iprogress):    m_filePath(filePath),    m_fileNumber(fileNumber)         m_iprogress(iprogress)&#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">float</span> progressValue = m_fileNumber;            progressValue = (i + <span class="hljs-number">1</span>) / progressValue;            onProgress(progressValue);        &#125;    &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span>(m_iprogress != <span class="hljs-literal">NULL</span>) &#123;        m_iprogress-&gt;DoProgress(value);<span class="hljs-comment">//更新进度条</span>        &#125;    &#125;&#125;</code></pre></div><h4 id="需求2-多观察者"><a href="#需求2-多观察者" class="headerlink" title="需求2: 多观察者"></a>需求2: 多观察者</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IProgress</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgresss</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~IProgress() &#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSplitter</span> &#123;</span>    <span class="hljs-built_in">string</span> m_filePath;    <span class="hljs-keyword">int</span> m_fileNumber;    List&lt;IProgress*&gt; m_iprogressList; <span class="hljs-comment">//抽象通知机制, 支持多个观察者</span><span class="hljs-keyword">public</span>:    FileSplitter(<span class="hljs-keyword">const</span> strign&amp; filePath, <span class="hljs-keyword">int</span> fileNumber):    m_filePath(filePath),    m_fileNumber(fileNumber) &#123;                &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIProgress</span><span class="hljs-params">(IProgress* iprogress)</span> </span>&#123;        m_iprogressList.add(iprogress);    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeIProgress</span><span class="hljs-params">(IProgress* iprogress)</span> </span>&#123;        m_iprogressList.remove(iprogress);    &#125;            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1. 读取大文件</span>                <span class="hljs-comment">//2. 分批次向小文件中写入</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++) &#123;            <span class="hljs-comment">//...</span>            <span class="hljs-keyword">float</span> progressValue = m_fileNumber;            progressValue = (i + <span class="hljs-number">1</span>) / progressValue;            onProgress(progressValue);        &#125;    &#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        List&lt;IProgress*&gt;::iterator it = m_iprogressList.begin();        <span class="hljs-keyword">while</span>(it != m_iprogressList.end()) &#123;            (*it)-&gt;DoProgress(value);            it++;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span>:</span> <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress&#123;    TextBox* txtFilePath;    TextBox* txtFileNumber;    ProgressBar* progressbar;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">string</span> filePath = txtFilePath-&gt;getText();        <span class="hljs-keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());                ConsoleNotifier cn;        <span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;                splitter.addIprogress(<span class="hljs-keyword">this</span>);        splitter.addIprogress(&amp;cn);                splitter.split();    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        progressBar-&gt;setValue(value);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleNotifier</span>:</span> <span class="hljs-keyword">public</span> IProgress &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value)</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"."</span>;    &#125;&#125;</code></pre></div><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200806160700160.png" srcset="/img/loading.gif" alt="image-20200806160700160" style="zoom: 50%;" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。 </p></li><li><p>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。</p></li><li><p>观察者自己决定是否需要订阅通知，目标对象对此一无所知。 </p></li><li>Observer模式是基于事件的UI框架中非常常用的设计模式，也是 MVC模式的一个重要组成部分。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Template Method</title>
    <link href="/2020/08/05/DesignPatterns/TemplateMethod/"/>
    <url>/2020/08/05/DesignPatterns/TemplateMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因 （比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p><p>核心在于在稳定与变化之间求得一个平衡，如果全部稳定或者全部变化都是不需要设计模式的。</p><p>如何在确定<strong>稳定操作结构</strong>的前提下，来灵活应对<strong>各个子步骤的变化</strong>或者<strong>晚期实现需求</strong>？</p><p>假设整个代码的操作结构如下图所示，其中红色是Library开发人员完成的，蓝色部分是Application开发人员完成的</p><p><img src="image-20200710191024075.png" srcset="/img/loading.gif" alt="image-20200710191024075" style="zoom:33%;" /></p><h2 id="结构化软件流程设计"><a href="#结构化软件流程设计" class="headerlink" title="结构化软件流程设计"></a>结构化软件流程设计</h2><p><img src="image-20200710191212499.png" srcset="/img/loading.gif" alt="image-20200710191212499" style="zoom:50%;" /></p><p>lib.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>app.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//应用程序开发人员</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>主程序</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Library <span class="hljs-title">lib</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Application <span class="hljs-title">app</span><span class="hljs-params">()</span></span>;        lib.Step1();        <span class="hljs-keyword">if</span>(app.Step2()) &#123;        lib.Step3();    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;        app.Step4();    &#125;    lib.Step5();&#125;</code></pre></div><h2 id="用模板方法的代码重构为"><a href="#用模板方法的代码重构为" class="headerlink" title="用模板方法的代码重构为"></a>用模板方法的代码重构为</h2><p><img src="image-20200710191917988.png" srcset="/img/loading.gif" alt="image-20200710191917988" style="zoom:50%;" /></p><p>lib.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span> </span>&#123;        Step1();        <span class="hljs-keyword">if</span>(Step2()) &#123;            Step3();        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            Step4();        &#125;        Step5();    &#125;        <span class="hljs-keyword">virtual</span> ~Library() &#123;&#125;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Step5</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//稳定</span>        <span class="hljs-comment">//...</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//变化</span>&#125;</code></pre></div><p>app.cpp</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//应用程序开发人员</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span>:</span> <span class="hljs-keyword">public</span> Library &#123;<span class="hljs-keyword">protected</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step4</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;;</code></pre></div><p>主程序</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Library* pLib = <span class="hljs-keyword">new</span> Application();    lib.Run();    <span class="hljs-keyword">delete</span> pLib;&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两者的区别在于早绑定和晚绑定。前者属于早绑定，而template method属于晚绑定</p><p><img src="image-20200710192039991.png" srcset="/img/loading.gif" alt="image-20200710192039991" style="zoom:50%;" /></p><p>定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟 (变化)到子类中。Template Method使得子类可以不改变 (复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。</p>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Strategy Method</title>
    <link href="/2020/08/05/DesignPatterns/StrategyMethod/"/>
    <url>/2020/08/05/DesignPatterns/StrategyMethod/</url>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂； 而且有时候支持不使用的算法也是一个性能负担</p><p>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</p><h2 id="Strategy-Method定义"><a href="#Strategy-Method定义" class="headerlink" title="Strategy Method定义"></a>Strategy Method定义</h2><p>定义一系列算法，把它们一个个封装起来，并且使它们可互 相替换（变化）。该模式使得算法可独立于使用它的客户程 序(稳定)而变化（扩展，子类化）。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>考虑一下计算税的例子</p><ul><li>第一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> TaxBase &#123;    CN_Tax,    US_Tax,    DE_Tax&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span>    TaxBase tax;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>                <span class="hljs-keyword">if</span>(tax == CN_Tax) &#123;            <span class="hljs-comment">//CN*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == US_Tax) &#123;            <span class="hljs-comment">//US*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == DE_Tax) &#123;            <span class="hljs-comment">//DE*****</span>        &#125;        <span class="hljs-comment">//***</span>    &#125;&#125;</code></pre></div><p>有些时候，静态地去观察是看不出来的，加入时间轴，考虑到未来的动态变化，问题就会暴露出来。考虑上述例子，如果要加入一个国家，比如法国，那么我们不仅要在<code>TaxBase</code>中中增加一个<code>FR_Tax</code>, 还需要在<code>SalesOrder</code>中增加判断语句。这样的更改违背了开闭原则： 对扩展开放，对修改封闭 (避免去修改源代码</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> TaxBase &#123;    CN_Tax,    US_Tax,    DE_Tax,    <span class="hljs-comment">/***加入France***/</span>    FR_Tax,&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span>    TaxBase tax;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>                <span class="hljs-keyword">if</span>(tax == CN_Tax) &#123;            <span class="hljs-comment">//CN*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == US_Tax) &#123;            <span class="hljs-comment">//US*****</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == DE_Tax) &#123;            <span class="hljs-comment">//DE*****</span>        &#125;        <span class="hljs-comment">/***加入France***/</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tax == FR_Tax) &#123;                  &#125;        <span class="hljs-comment">//***</span>    &#125;&#125;</code></pre></div><ul><li>考虑另一种实现方式</li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxStrategy</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~TaxStrategy() &#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DETax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesOrder</span> &#123;</span><span class="hljs-keyword">private</span>:    TaxStrategy* strategy;<span class="hljs-keyword">public</span>:    SalesOrder(StrategyFactory* strategyFactory) &#123;        <span class="hljs-keyword">this</span>-&gt;strategy = strategyFactory-&gt;NewStrategy();    &#125;        ~SalesOrder() &#123;        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;strategy;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>        <span class="hljs-function">Context <span class="hljs-title">context</span><span class="hljs-params">()</span></span>;                <span class="hljs-keyword">double</span> val =             srtategy-&gt;Calculate(context);<span class="hljs-comment">//多态调用</span>    &#125;&#125;</code></pre></div><p>如果要增加法国，只需增加一个<code>FRTax</code>类</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FRTax</span>:</span> <span class="hljs-keyword">public</span> TaxStrategy &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> doubel <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Context&amp; context)</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>这是一种扩展的做法，在这里只需要增加一个FRTax类，不需要更改SalesOrder。</p><p>复用性一般是指二进制层面下的复用性，如果使用第一种方法，那么整个系统需要重新编译，重新测试。虽然修改后保留了一部分原来的代码，但是这个并不是复用。而策略方法不需要重新编译之前编译好的文件，只需要重新编译FRTax这个文件</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="image-20200805135526277.png" srcset="/img/loading.gif" alt="image-20200805135526277"> </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使 得类型在运行时方便地根据需要在各个算法之间进行切换。</p></li><li><p>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件 判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需 要Strategy模式。</p></li><li><p>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design Patterns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer network--传输层</title>
    <link href="/2019/12/09/ComputerNetwork/TransportLayer/"/>
    <url>/2019/12/09/ComputerNetwork/TransportLayer/</url>
    
    <content type="html"><![CDATA[<h1 id="1-The-Transport-Service"><a href="#1-The-Transport-Service" class="headerlink" title="1. The Transport Service"></a>1. The Transport Service</h1><ul><li><p>transport layer services</p><ul><li>To provide efficient, <strong><em>reliable,</em></strong> and cost effective service to its users, normally processes in the application layer.</li><li>To make use of the services provided by the network layer.</li></ul></li><li><p>the transport entity</p><ul><li>the hardware and/or software within the transport layer that does the work.</li></ul></li></ul><center><img src="image-20191126095920516.png" srcset="/img/loading.gif" alt="image-20191126095920516" style="zoom:35%;" /></center><h2 id="1-1-网络层和传输层的区别与联系"><a href="#1-1-网络层和传输层的区别与联系" class="headerlink" title="1.1 网络层和传输层的区别与联系"></a>1.1 网络层和传输层的区别与联系</h2><blockquote><p>考虑有两个家庭，一家位于美国东海岸，一家位于美国西海岸，每家有12个孩子。东海岸的孩子们是西海岸家庭孩子们的堂兄弟姐妹。这两个家庭的孩子们喜欢彼此通信，每个人每周要给每个堂兄弟姐妹写一封信，每封信都用单独的信封通过传统的邮政服务发送。因此，每个家庭每周向另一家庭发送144封信。（如果他们有电子邮件的话，这些孩子可以省不少钱！）每个家庭有一个孩子负责收发邮件，西海岸家庭是Ann而东海岸家庭是Bill。每周Ann去她所有的兄弟姐妹那里收集邮件，并将这些邮件交到每天到家门口的邮政运输车上。当信件到达西海岸家庭时，Ann也负责将信件发到她的兄弟姐妹手上，东海岸家庭中Bill也负责类似工作。</p></blockquote><p>我们可以做下面这样的类比:</p><div class="hljs"><pre><code class="hljs armasm">应用层报文　　＝　信封上的字符进程　　　　　＝　堂兄弟姐妹主机(端系统)　＝　家庭运输层协议　　＝　Ann和<span class="hljs-keyword">Bill</span><span class="hljs-keyword">网络层协议　</span>　＝　邮政服务</code></pre></div><blockquote><p>在这个例子中，网络层就像邮递员，而运输层就像Ann和Bill。现在我们再来理解上面的这句话:<strong>网络层提供了主机之间的逻辑通信，而传输层为不同主机上的进程之间提供了逻辑通信。</strong>邮政服务知识将信件送到指定的家庭，它不会将信件分发到家庭的具体成员手中。这个分发的工作则是由Ann和Bill提供的。值得注意的是Ann和Bill都是在各自的家里进行工作的，他们没有参与任何中间邮件中心对邮件进行分拣的工作，也没有将邮件从一个邮件中心送到另一个邮件中心。相应的，<strong>运输层协议只工作在端系统中</strong>。在端系统中，运输层协议将来自应用进程的的报文移动到网络边缘(即网络层)，但对有关这些报文在网络层中如何移动却不做任何规定。<br>由这个例子，我们可以做出如下概括:<strong>网络层提供了不同端系统的数据交付服务，而传输层则将这种不同主机间的交付拓展为了运行在不同端系统上的两个进程之间的交付。</strong>进程到进程之间的数据交付是传输层提供的最基本的服务之一。</p></blockquote><p>{:.success}</p><p>传输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信。传输层还要对收到的报文进行差错检测。</p><center><img src="image-20191212232948465.png" srcset="/img/loading.gif" alt="image-20191212232948465" style="zoom:40%;" /></center><center><img src="image-20191212233116016.png" srcset="/img/loading.gif" alt="image-20191212233116016" style="zoom:50%;" /></center><p><br/></p><h2 id="1-2-Hypothetical-primitives"><a href="#1-2-Hypothetical-primitives" class="headerlink" title="1.2 Hypothetical primitives"></a>1.2 Hypothetical primitives</h2><center><img src="image-20191126100224177.png" srcset="/img/loading.gif" alt="image-20191126100224177" style="zoom:30%;" /></center><p><br/></p><p>用segment表示传输实体间发送的消息[一些老协议使用了更加笨拙的名称一一传输协议数据单元。TPDU, Transport Protocol Data Unit]</p><center><img src="image-20191209001317925.png" srcset="/img/loading.gif" alt="image-20191209001317925" style="zoom: 30%;" /></center><p><strong><em>How to use these primitives for an application?</em></strong></p><center><img src="image-20191209000910981.png" srcset="/img/loading.gif" alt="image-20191209000910981" style="zoom:35%;" /></center><p><strong><em>Connection establishment and connection release</em></strong></p><center><img src="image-20191209002015904.png" srcset="/img/loading.gif" alt="image-20191209002015904" style="zoom:35%;" /></center><p><br/></p><h1 id="2-Elements-of-Transport-Protocols"><a href="#2-Elements-of-Transport-Protocols" class="headerlink" title="2. Elements of Transport Protocols"></a>2. Elements of Transport Protocols</h1><h2 id="2-1-传输层协议与数据链路层协议"><a href="#2-1-传输层协议与数据链路层协议" class="headerlink" title="2.1 传输层协议与数据链路层协议"></a>2.1 传输层协议与数据链路层协议</h2><p>传输协议在有些方面类似数据链路协议。这两种协议都要处理<u>错误控制、 顺序性和流量控制以及其他一些问题。</u></p><p>然而，两者之间也存在着重大的差别。这些差别是因为这两种协议的运行环境不同而造成的。</p><center><table>  <tr>    <td><div class="card">     <div class="card__image">       <img class="image" src="image-20191209134511204.png" srcset="/img/loading.gif" alt="image-20191209134511204" style="zoom:50%;" />  </div>     <div class="card__content">         <div class="card__header">             <h4>数据链路层环境</h4>         </div>         <p>两台路由器通过一条有线或者无线物理信道直接进行通信</p>    </div></div></td>  <td><div class="card">     <div class="card__image">       <img class="image" src="image-20191209134550181.png" srcset="/img/loading.gif" alt="image-20191209134550181" style="zoom:50%;" />  </div>     <div class="card__content">         <div class="card__header">             <h4>传输层</h4>         </div>         <p>该物理信道被整个网络所替代                             </p>    </div> </div></td>  </tr></table></center><ul><li>Addressing: <ul><li>在点到点链路上，路由器不必指定它要与哪一台路由器进行通话，因为每条出境线路直接通向一台特定的路由器。</li><li>而在传输层，必须显式地指定接收方的地址。</li></ul></li><li>Connection establishment:<ul><li>在一条线路上建立一个连接的过程非常简单，另一端总是在那里（除非它崩溃了才不在那里）。两边都不需要做很多事情。如果因发生错误而消息没有被确认，可以再次重发。</li><li>而在传输层中，初始的连接建立过程非常复杂。</li></ul></li><li>Storage capacity:<ul><li>数据链路层和传输层之间的另一个（非常恼人的）差别是，网络存在着潜在的存储容量。当路由器发送一帧到一条链路上后，该帧可能到达对方也可能丢失，但是它不可能先蹦跄一会儿，再躲到远处一个角落中，然后在其他数据包发送出去很久后突然又冒了出来。</li><li>如果网络使用数据报技术，即网络内部的路由是独立进行的，那么就存在一个不可忽略的概率：一个包可能选取了风景优美的路线，一路观光姗姗来迟到达目的地，这将扰乱预期的接收顺序，甚至它的重复数据包都已经到达目的地它还没到呢。网络具有的这种延迟和重复数据包的特性所产生的后果有时是灾难性的，因此要求使用特殊的协议，以便正确地传输信息。 </li></ul></li><li>Buffering:<ul><li>这两层都需要缓冲和流量控制，但是，由于传输层上存在着大量并且数量可变的连接，而且由于连接之间的相互竞争造成连接的可用带宽上下波动，因此需要一种不同于数据链路层使用的方法。</li></ul></li></ul><h2 id="2-2-寻址"><a href="#2-2-寻址" class="headerlink" title="2.2 寻址"></a>2.2 寻址</h2><p>端口</p><div class="note note-success">            <p>当一个应用进程希望与另一个远程应用进程建立连接时，它必须制定要连接到哪个应用进程上。通常使用的方法是为那些能够监听连接请求的进程定义相应的传输地址。将这些端点称为<strong><em><u>端口</u></em></strong>[port]</p>          </div><p>传输服务访问点[transport service access point]</p><div class="note note-success">            <p>传输层的一个特殊端点</p>          </div><p>网络访问服务点[network service access point]</p><div class="note note-success">            <p>网络层上的端点[即网络层地址]</p>          </div><p>接下来来看一下过程</p><p>应用进程（包括客户和服务器） 可以将自己关联到）1个本地 TSAP 上，以便与一个远程 TSAP 建立连接。这些连接运行在 每台主机的 NSAP 之上，如图所示。在有些网络中，每台计算机只有一个 NSAP ，但是可能有多个传输端点共享此 NSAP</p><div class="item">     <div class="item__image">     <img  src="image-20191209134703993.png" srcset="/img/loading.gif" alt="image-20191209134703993" style="zoom:40%;" />   </div>     <div class="item__content">       <div class="item__header">           <h4>Addressing过程</h4>       </div>       <div class="item__description">         <p>1. Host 2 上的邮件服务器进程将自己关联到 TSAP 1522 上[例如调用listen]，等待入境连接请求的到 来。</p>    <p>2. Host 1 上的应用进程希望发送一个邮件消息，所以它把自己关联到 TSAP1208 上，并且发出一个 CONNECT 请求。该请求消息指定主机 1 上的 TSAP 1208 作为源，主机 2 上 的 TSAP 1522 作为目标。这个动作最终导致在应用进程和服务器之间建立了一个连接。</p>    <p>3. 应用进程发送邮件消息。 </p>    <p>4. 作为响应，Host 2上的邮件服务器表示它将传递该消息。</p>    <p>5. 传输连接被释放。 请注意，在主机 2 上很可能还有其他的服务器被关联到其他的 TSAP 上，它们也在等 待经过同一个 NSAP 到达的入境连接请求。</p>  </div>     </div> </div><p><br/></p><h3 id="A-host-1上的用户进程如何知道邮件服务器被关联到了TSAP-1522-上"><a href="#A-host-1上的用户进程如何知道邮件服务器被关联到了TSAP-1522-上" class="headerlink" title="A. host 1上的用户进程如何知道邮件服务器被关联到了TSAP 1522 上"></a>A. host 1上的用户进程如何知道邮件服务器被关联到了TSAP 1522 上</h3><ol><li><p>固定TSAP[将某些服务器永久关联到一些端口上]</p><p>http=TCP:80</p><p>https=TCP:443</p><p>RDP=TCP:3389</p><p>ftp=TCP:21</p><p>SMTP=TCP:25</p><p>DNS=UDP:53</p><p><img src="image-20200105235129774.png" srcset="/img/loading.gif" alt="image-20200105235129774" style="zoom:50%;" /></p></li><li><p>端口映射。存在－个称为端口映射器（ portmapper）的特殊进程。</p><ul><li>为了找到一个给定服务名字相对应的 TSAP 地址，用户需要<strong><em><u>与端口映射器[server上？]建立一个连接</u></em></strong></li><li>然后，用户通过该连接发送一条消息指定它想要的服务名字[如”BitTorrent”]，端口映射器返回相应的 TSAP 地址。</li><li>之后，用户释放它与端口映射器之间的连接， 再与所需的服务建立一个新的连接。</li></ul></li></ol><div class="note note-info">            <p>当一个新的服务被创建时，它必须向端口映射器注册，把它的服务名字（通常是一个 ASCII 字符串〉和 TSAP 告诉端口映射器。端口映射器将该信息记录到它 的内部数据库中，所以，以后当用户查询时，它就知道答案了。端口映射器的功能类似于电话系统中的查号操作员, 提供的是从名字到电话号码之间的映射关系。</p>          </div><div class="note note-success">            <p>用<code>netstat -an</code>命令查看应用监听的端口</p><p><code>netstat -n</code>查看建立的会话</p>          </div><center><img src="image-20191213095702465.png" srcset="/img/loading.gif" alt="image-20191213095702465" style="zoom:50%;" /></center><div class="note note-success">            <p><code>netstat -nb</code>查看建立会话的进程</p>          </div><div class="note note-success">            <p><code>telnet 192.168.80.100 3389</code>测试远程计算机某个端口是否打开</p>          </div><h3 id="B-Many-server-processes-will-be-used-rarely-and-it-is-wasteful-to-have-them-active"><a href="#B-Many-server-processes-will-be-used-rarely-and-it-is-wasteful-to-have-them-active" class="headerlink" title="B. Many server processes will be used rarely and it is wasteful to have them active"></a>B. Many server processes will be used rarely and it is wasteful to have them active</h3><p><br/></p><div class="item">     <div class="item__image">     <img  src="image-20191209135340835.png" srcset="/img/loading.gif" alt="image-20191209135340835" style="zoom:40%;" />  </div>     <div class="item__content">     <div class = "item__header">      <h4>        initial connection protocol      </h4>    </div>  <div class="item__description">         <p>每台希望向远程用户提供服务的机器有一个特殊的进程服务器（ process server ）充当那些不那么频繁使用的服务器的代理。它在同一时间监听一组端口，等待连接请求的到来。一个服务的潜在用户发出一个连接请求，并指定他们所需服务的 TSAP 地址。如果该 TSAP 地址上没有服务器正等着，则他们得到一条与进程服务器的连接，如图a所示。</p>    <p>在获取入境请求后，进程服务器派生出被请求的服务器，允许该服务器继承与用户的现有连接。新服务器完成要求的工作，而进程服务器可回去继续监听新的连接要求，如图b所示。这种方法只适用于服务器可按需创建的场合。</p>  </div>     </div> </div><h2 id="2-3-连接建立"><a href="#2-3-连接建立" class="headerlink" title="2.3 连接建立"></a>2.3 连接建立</h2><p>一个巨大的问题</p><div class="note note-warning">            <p><strong><em>delayed duplicates problem</em></strong></p>          </div><blockquote><p>用户建立了一个与银行的连接，并且发送消息告诉银行把一大笔钱转移到一个并不是完全值得信赖的人的账户。不幸的是，数据包决定采取一条到目的地的风景路径，去探索网络的某个偏僻角落。然后，发送端超时，并且再次发送这些消息。这一次，数据包采取了一条最短路径，并且很快被交付给接收端，所以发送端释放连接。不幸的是，最终原先的那批数据包终于从某个隐藏处冒了出来，并到达目的地，要求银行建立一个新的连接和汇款（再次）。银行没有办法得知这些是重复请求。它必须假设 这是第二个并且独立的交易请求，因此再次转钱。</p></blockquote><div class="note note-success">            <p>Desired behavior</p>          </div><center><img src="image-20191210093758100.png" srcset="/img/loading.gif" alt="image-20191210093758100" style="zoom:30%;" /></center><h3 id="A-Solution-1"><a href="#A-Solution-1" class="headerlink" title="A. Solution 1"></a>A. Solution 1</h3><div class="note note-info">            <p>use sequence numbers</p>          </div><div class="hljs"><pre><code class="hljs python">packet arrival:  <span class="hljs-keyword">if</span>(packet.seq see before)  discard packet</code></pre></div><p><code>problems</code></p><ul><li><p>Possible wrap around of seqno</p></li><li><p>Client/Host or Server may crash</p></li></ul><center><img src="image-20191210094719473.png" srcset="/img/loading.gif" alt="image-20191210094719473" style="zoom:30%;" /></center><p>Problem : How to differentiate <strong><em><u>delay duplicate</u></em></strong> and <strong><em><u>new pkt with wrapped around seqno</u></em></strong>?</p><p>Idea: <strong><em><u>use time</u></em></strong></p><p>Two assumptionsthat simplifies the problem</p><ol><li><p>Time for seqno wrap around (T1) is typically large if, e.g., seqno is 32 bits long.</p></li><li><p>If pkt delays a relatively short time (T2&lt;T1), we can use time to differentiate</p><p>the two.</p></li></ol><h3 id="B-Solution-2"><a href="#B-Solution-2" class="headerlink" title="B. Solution 2"></a>B. Solution 2</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">if</span> (packet.seq see before <span class="hljs-keyword">and</span> time <span class="hljs-keyword">is</span> short (&lt;T))discard packet<span class="hljs-keyword">if</span> (packet.seq see before <span class="hljs-keyword">and</span> time <span class="hljs-keyword">is</span> large (&gt;T))accept packet</code></pre></div><center><img src="image-20191126102346530.png" srcset="/img/loading.gif" alt="image-20191126102346530" style="zoom: 33%;" /></center><h4 id="How-to-realize"><a href="#How-to-realize" class="headerlink" title="How to realize"></a>How to realize</h4><ol><li><p>Restrict packet lifetime</p><p>Packet lifetime can be restricted to a known maximum using one of the following techniques</p><ul><li><p>Restricted subnet design.</p></li><li><p>Putting a hop counter in each packet. 将跳计数器 初始化为某个适当的值，然后每次数据包被转发的时候该跳计数器减一。网络协议简单丢弃掉那些跳计数器变成零的数据包</p></li><li><p>Timestamping each packet (router synchronization required) 每个数据包携带它的创建时间，路由 器负责丢弃那些年限超过某个预设值的数据包。后一种方法要求同步所有路由器的时钟.</p></li></ul><p>引入周期T, 他是数据报实际最大生存期的某个不太大的倍数：<script type="math/tex">T=n\times (pkt\;lifetime)</script></p><p>It is impossible to receive a delay duplicate after T</p></li><li><p>use time-of-day clock[日时钟] to limit sending rate</p><p>核心是源端用序号作为段的标签，使得该段在 T 秒内不被重用。 T 的大小以及数据包速率（数据包／秒）确定了序号的大小。这样，在任何给定的时间内只能出现一个给定序号的数据包。</p><p>为了解决一台机器崩溃之后丢失所有内存的问题，一种可能的解决方法是要求传输实体在机器崩溃之后空闲 T 秒。这段空闲期将确保所有老的段全部死掉，因而发送端可以启用任何一个序号值。然而，在复杂的互联网络中， T 可能会很大，因此这种策略不具吸引力。</p><p>相反， Tomlinson 建议每台主机都配备一个日时钟（time-of-day clock ）。不同主机上的</p><ul><li>时钟不需要同步。假定每个时钟均采用了<strong><em><u>二进制计数器</u></em></strong>的形式。该计数器以统一的时间间隔递增自己，</li><li>计数器的位数必须等于或者超过序号的位数。</li><li>即使<strong><em><u>主机停机时钟也不停下</u></em></strong>，它将持续不停地运行。</li></ul><p>当建立一个连接时，时钟的低 k 位被用于同样是 k位的初始序号。每个连接都从一个完全不同的初始序号开始对它的段进行编号。序号空间应该足够大，以便当序号回绕时，原来那些具有老序号的段都己经消失。</p></li></ol><p><strong><em>forbidden region</em></strong></p><div class="item">     <div class="item__image">    <img src="image-20191211220455615.png" srcset="/img/loading.gif" alt="image-20191211220455615" style="zoom:50%;" />  </div>     <div class="item__content">     <div class = "item__header">      <h4>        Forbidden region      </h4>    </div>  <div class="item__description">         <p>Assume the same bits of seqno and time-of-day clock</p>    <p>      Two time instants, t and t', t << t'    </p>    <p>      If we allow legitimate reuse of the same seqno at t and t', we should ensure that t'-t >T </p>  </div>     </div> </div><div class="note note-warning">            <p>为了防止序号进入forbidden region，我们必须兼顾两个方面。</p>          </div><center><img src="image-20191211222453374.png" srcset="/img/loading.gif" alt="image-20191211222453374" style="zoom:40%;" /></center><blockquote><ul><li>如果一台主机在一个新打开的连接上发送得太快，则实际序号与时间的曲线可能比初始序号与时间的曲线还要陡，导致序号进入forbidden region。<ul><li>为了防止这种情况出现，每个连接上的最大数据速率是每个时钟滴答一次发送一段。这同时也意味着在机器崩溃并重启动之后， 传输实体必须等待时钟滴答，才能打开一个新的连接，以免同样的序号被使用两次。这两 点都倾向于使用短的时钟滴答 (1 微秒甚至更短）。但是相对序号来说时钟不能滴答得太快。 假设时钟速率为 C，序号空间大小为 S，则有 S/C&gt;T，才能使得序号不至于回绕得太快。</li></ul></li><li>如果以任何低于时钟速率的数据率发送，实际使用的序号与时间之间的曲线最终会从左边进入到禁止区域中。实际序号曲线的斜度越大，则这种事件发生得越晚。<ul><li>为了避免这种情况发生，应该限制连接序号递增的速度不能太慢（或连接可能会持续多久）。</li></ul></li></ul></blockquote><center><img src="image-20191126102810011.png" srcset="/img/loading.gif" alt="image-20191126102810011" style="zoom: 33%;" /></center><blockquote><p>看一道例题</p><p>In a network whose max segment is 128 bytes, max segment lifetime is 30 sec, and has 8 bit sequence numbers, what is the maximum data rate per connection?</p><p><strong>Answer</strong></p><p>这个包是0号，则在30sec里面可以从0号发到255号，一共256个包</p><p>number of bits=256 × 128 × 8 = 262,144 bits<br>The data rate =262,144 bits /30 sec=8738 bps. </p></blockquote><p>以上内容解决了delay duplicate packets的问题。接下来将其投入应用</p><h3 id="Three-way-handshake"><a href="#Three-way-handshake" class="headerlink" title="Three-way handshake"></a>Three-way handshake</h3><div class="item">     <div class="item__image">   <img src="image-20191211230251099.png" srcset="/img/loading.gif" alt="image-20191211230251099" style="zoom:45%;" />  </div>     <div class="item__content">     <div class = "item__header">      <h4>       Connection Establishment(1)      </h4>    </div>  <div class="item__description">      <p> a. 主机1选择一个序号x，并且发送一个包含x的CONNECTION REQUEST段给主机2。</p>    <p>      b. 主机2回应一个ACK段作为对x的确认，并且宣告它自己的初始序号y。    </p>    <p>      c. 最后，主机1在它发送的第一个数据段中，对主机 2 选择的初始序号进行确认。</p>  </div>     </div> </div><div class="item">     <div class="item__image">   <img src="image-20191211230545824.png" srcset="/img/loading.gif" alt="image-20191211230545824" style="zoom:35%;" />  </div>     <div class="item__content">     <div class = "item__header">      <h4>        Connection Establishment(2)      </h4>    </div>  <div class="item__description">      <p> a. 第一个段是一个旧连接上被延迟了的重复 CONNECTION REQUEST。该段到达主机 2, 而主机 1 对此并不知情。</p>    <p>      b. 主机 2 对这个段的回应是给主机 1 发送一个 ACK 段，其效果相 当于验证主机 1 是否真的请求建立一个新的连接。    </p>    <p>      c. 当主机 1 拒绝了主机 2 的连接建立请求后，主机 2 就意识到被一个延迟的重复段所欺骗了，于是放弃连接。这样 p 一个延迟的重 复段没有造成任何伤害。</p>  </div>     </div> </div><div class="item">     <div class="item__image">   <img src="image-20191211230935460.png" srcset="/img/loading.gif" alt="image-20191211230935460" style="zoom:35%;" />  </div>     <div class="item__content">     <div class = "item__header">      <h4>        Connection Establishment(3)      </h4>    </div>  <div class="item__description">      <p> a. 第一个段是一个旧连接上被延迟了的重复 CONNECTION REQUEST。该段到达主机 2, 而主机 1 对此并不知情。</p>    <p>      b. 主机 2 对这个段的回应是给主机 1 发送一个 ACK 段，其效果相当于验证主机 1 是否真的请求建立一个新的连接。    </p>    <p>      c. 当第二个延迟的段到达主机 2 时，主机 2 注意到确认的是 z 而不是 y，这个事实告诉主机 2 这也是一个老的重复数据包。</p>  </div>     </div> </div><h2 id="2-4-连接释放"><a href="#2-4-连接释放" class="headerlink" title="2.4 连接释放"></a>2.4 连接释放</h2><center><table>  <tr>    <td><div class="card">      <div class="card__content">         <div class="card__header">             <h4>Asymmetric release</h4>         </div>         <p>当一方挂机后，连接就被中断了</p>     <p>      很冒失，可能导致数据丢失    </p>  </div></div></td>  <td><div class="card">     <div class="card__content">         <div class="card__header">             <h4>Symmetric release</h4>         </div>         <p>把连接看成两个独立的单向连接，要求单独释放每一个单向连接．                           </p>    </div> </div></td>  </tr></table></center><p>Two army problem, 完美的释放是不可能的</p><p>也采用三次握手协议</p><div class="item">     <div class="item__image">   <img src="image-20191211234832859.png" srcset="/img/loading.gif" alt="image-20191211234832859" style="zoom:50%;" />  </div>     <div class="item__content">     <div class = "item__header">      <h4>        Normal case of three-way handshake      </h4>    </div>  <div class="item__description">      <p> a. 一个用户发送一个 DR (DISCONNECTION REQUEST ）段来启动释放连接过程</p>    <p>      b. 当该段到达对方，接收端也发回一个DR段，并启动一个计时器，设置计时器的目的是为了防止它的DR丢失。    </p>    <p>      c. 当这个 DR 到达时，最初的发 送端发回一个 ACK 段，并且释放连接</p>    <p>      d. 当 ACK 返回后，接收端也释放连接。释放 一个连接意味着传输实体将有关该连接的信息从它的内部表（记录了所有当前己打开的连 接）中删除，并且通知该连接的所有者（传输用户）    </p>  </div>     </div> </div><div class="item">     <div class="item__image">   <img src="image-20191211235148092.png" srcset="/img/loading.gif" alt="image-20191211235148092" style="zoom:50%;" />  </div>     <div class="item__content">     <div class = "item__header">      <h4>        Final ACK lost      </h4>    </div>  <div class="item__description">      <p> 如果最后的 ACK 段被丢失, 可以通过一个计时器来补救。当计时器超时，无论如何连接都要被释放。</p>  </div>     </div> </div><div class="item">     <div class="item__image">   <img src="image-20191211235320953.png" srcset="/img/loading.gif" alt="image-20191211235320953" style="zoom:50%;" />  </div>     <div class="item__content">     <div class = "item__header">      <h4>        Response lost      </h4>    </div>  <div class="item__description">      <p> 现在考虑第二个 DR 被丢失的情形。发起释放连接的用户接收不到期望的响应，所以 它将超时，于是再次尝试释放连接。</p>  </div>     </div> </div><div class="item">     <div class="item__image">   <img src="image-20191211235440547.png" srcset="/img/loading.gif" alt="image-20191211235440547" style="zoom:50%;" />  </div>     <div class="item__content">     <div class = "item__header">      <h4>        Response lost and subsequent DRs Lost      </h4>    </div>  <div class="item__description">      <p> 但由于丢失段的原因，所有重传 DR 的尝试都失败。经过 N 次重试之后，发送端放弃了，并且释放连接。同时，接收端超时，于是退出连接。</p>  </div>     </div> </div><div class="note note-success">            <p>Automatic disconnect rule</p>          </div><ul><li><p>If no segments have arrived for a certain number of seconds, the connection is then automatically disconnect.</p></li><li><p>Thus, if one side ever disconnects, the other side will detect the lack of activity and also disconnect.</p></li></ul><p><br/></p><h2 id="2-5-error-control-and-flow-control"><a href="#2-5-error-control-and-flow-control" class="headerlink" title="2.5 error control and flow control"></a>2.5 error control and flow control</h2><ul><li><p>Error detection:</p><ul><li><p>The link layer checksum protects a frame while it crosses a single link.</p></li><li><p>The transport layer checksum protects a segment while it crosses an entire network path. It is an end-to-end check, which is not the same as having a check on every link.</p></li></ul></li></ul><p>End-to-end argument: transport check is essential for correctness while link layer check is valuable for performance.</p><p><br/></p><h2 id="2-6-多路复用"><a href="#2-6-多路复用" class="headerlink" title="2.6 多路复用"></a>2.6 多路复用</h2><ul><li><p><strong><em>多路复用</em></strong>（或多个会话共享连接、虚电路和物理链路）在网络体系结构的不同层次发挥着作用。在传输层，有几种方式需要多路复用。</p><ul><li>如果主机只有一个网络地址可用， 则该机器上的所有传输连接都必须使用这个地址。当到达了一个段，必须有某种方式告知 把它交给哪个进程处理。图中， 4 个独立的传输连接都使用了相同的网络连接（即 IP 地址）到达远程主机。</li></ul></li><li><p><strong><em>逆向多路复用</em></strong>，假设一台主机有多条网络路径可用。如果用户需要的带宽和可靠性比其中任何一条路径所能提供的还要多，那么一种解决办法是以轮询的方式把一个连接上的流量分摊到多条网络路径。</p></li></ul><center><img src="image-20191212000741805.png" srcset="/img/loading.gif" alt="image-20191212000741805" style="zoom:50%;" /></center><p><br/></p><h1 id="3-Congestion-Control"><a href="#3-Congestion-Control" class="headerlink" title="3. Congestion Control"></a>3. Congestion Control</h1><h1 id="4-The-Internet-Transport-Protocols：UDP"><a href="#4-The-Internet-Transport-Protocols：UDP" class="headerlink" title="4. The Internet Transport Protocols：UDP"></a>4. The Internet Transport Protocols：UDP</h1><p>TCP 与 UCP的应用场景</p><ul><li>TCP: 需要将传输的文件分段 建立会话，可靠传输，流量控制  QQ传文件</li><li>UDP： 一个数据包就能完成数据通信 不分段 不需要建立会话 不需要流量控制 不可靠传输 QQ聊天</li></ul><p><br/></p><h2 id="4-1-UDP-overview"><a href="#4-1-UDP-overview" class="headerlink" title="4.1 UDP overview"></a>4.1 UDP overview</h2><center><img src="image-20191213103709184.png" srcset="/img/loading.gif" alt="image-20191213103709184" style="zoom:50%;" /></center><p>UDP length是header和payload两部分的总长度，以byte为单位</p><center><img src="image-20191213103006241.png" srcset="/img/loading.gif" alt="image-20191213103006241" style="zoom:50%;" /></center><p>在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。</p><h4>UDP checksum计算过程</h4>    <p><img src="image-20191213103042682.png" srcset="/img/loading.gif" alt="image-20191213103042682" style="zoom:40%;" /><img src="image-20191213110622335.png" srcset="/img/loading.gif" alt="image-20191213110622335" style="zoom:40%;" /></p><h2 id="4-2-RPC-Remote-Procedure-Call"><a href="#4-2-RPC-Remote-Procedure-Call" class="headerlink" title="4.2 RPC[Remote Procedure Call]"></a>4.2 RPC[Remote Procedure Call]</h2><p>客户-服务器 RPC 是 UDP 被广泛应用的一个领域，</p><div class="note note-success">            <p>RPC (Remote Procedure Call) allows programs to call procedures located on remote hosts.</p>          </div><blockquote><p>RPC 背后的思想是尽可能地使一个远程过程调用看起来像本地过程调用一样。</p><p>在最简单的形式中，为了调用一个远程过程，客户程序必须绑定（链接）到一个小的库过程，这 个库过程称为客户存根[client stub]，它代表了客户地址空间中的服务器过程。类似地，服务器需要绑定到一个称为服务器存根[server stub]的过程。正是这些过程，隐藏了客户机不在本地调用服务器的事实。</p></blockquote><center><img src="image-20191213122858021.png" srcset="/img/loading.gif" alt="image-20191213122858021" style="zoom:50%;" /></center><h3 id="A-执行RPC的实际步骤"><a href="#A-执行RPC的实际步骤" class="headerlink" title="A. 执行RPC的实际步骤"></a>A. 执行RPC的实际步骤</h3><ol><li>client调用client stub，参数入栈</li><li>client stub将参数封装到一个消息中，然后通过系统调用发送消息。参数封装的过程称为列集[marshalling]</li><li>kernel将消息从client machine发到server machine</li><li>kernel将入境数据包传递给server stub</li><li>server stub利用散集[unmarshaled]调用的参数调用服务器过程</li><li>调用的结果沿着相反的方向按照同样的路径传递。</li></ol><h3 id="B-RPC陷阱"><a href="#B-RPC陷阱" class="headerlink" title="B. RPC陷阱"></a>B. RPC陷阱</h3><ul><li><p>The use of pointer parameters. </p></li><li><p>Some problems for weakly typed languages (The length of an array).</p></li><li><p>It is not always possible to deduce the types of the parameters, not even from a formal specification or the code itself. [printf]</p></li><li><p>The use of global variables.</p></li></ul><h2 id="4-3-RTP-Real-time-transport-protocol"><a href="#4-3-RTP-Real-time-transport-protocol" class="headerlink" title="4.3 RTP[Real-time transport protocol]"></a>4.3 RTP[Real-time transport protocol]</h2><p>UDP 的另一个应用领域是实时多媒体应用</p><div class="note note-success">            <p>RTP is a transport protocol realized in the application layer.</p>          </div><h3 id="RTP的基本功能："><a href="#RTP的基本功能：" class="headerlink" title="RTP的基本功能："></a>RTP的基本功能：</h3><div class="note note-info">            <p>RTP is to multiplex several real-time data streams onto a single stream of UDP packets and unicast or multicast the UDP packets.</p>          </div><h3 id="RTP格式包含了几种有助于接收端处于流媒体信息的特性"><a href="#RTP格式包含了几种有助于接收端处于流媒体信息的特性" class="headerlink" title="RTP格式包含了几种有助于接收端处于流媒体信息的特性"></a>RTP格式包含了几种有助于接收端处于流媒体信息的特性</h3><ul><li>Each RTP packet is given a <u>number</u> one higher than its predecessor. RTP has no flow control, no error control, no acknowledgements, and no retransmission support.</li><li>Each RTP payload may contain multiple samples and they can <u>be coded any way that the application wants</u>. For example a single audio stream may be encoded as 8-bit PCM samples at 8kHz, delta encoding, predictive encoding  GSM encoding, MP3, and so on.</li><li>RTP allows timestamping.</li></ul><center><img src="image-20191213124846490.png" srcset="/img/loading.gif" alt="image-20191213124846490" style="zoom:50%;" /></center><h3 id="RTCP-Realtime-Transport-Control-Protocol"><a href="#RTCP-Realtime-Transport-Control-Protocol" class="headerlink" title="RTCP[Realtime Transport Control Protocol]"></a>RTCP[Realtime Transport Control Protocol]</h3><h4 id="A-RTCP一些特性"><a href="#A-RTCP一些特性" class="headerlink" title="A. RTCP一些特性"></a>A. RTCP一些特性</h4><ul><li><p>Does not transport any data</p></li><li><p>To handle feedback, synchronization, and the user interface</p></li><li><p>To handle interstream synchronization.</p></li><li><p>To name the various sources.</p></li></ul><h4 id="B-带有缓冲和抖动控制的播放"><a href="#B-带有缓冲和抖动控制的播放" class="headerlink" title="B. 带有缓冲和抖动控制的播放"></a>B. 带有缓冲和抖动控制的播放</h4><p><strong>Smoothing the output stream by buffering packets</strong></p><p>一旦媒体信息到达接收端，它必须在合适的时间播放出来。 一般情况下，这个时间不是 RTP 包到达接收端的时间，因为数据包通过网络传输所需要的时间略有不同。即使在发送端，数据包以正确的时间间隔被依次注入网络，它们到达接收端的相对时间也不同。这种延迟的变化称为<strong><em><u>抖动[jitter</u>]</em></strong>。即使是少量的数据包抖动，如果简单地按它到达的时间播放出来，也可能导致媒体成品发散，如抖动的画面帧和难以辨认的音频。</p><p>这个问题的解决办法是在接收端播放媒体之前对其进行缓冲，以此来减少抖动。</p><center><img src="image-20191213130200893.png" srcset="/img/loading.gif" alt="image-20191213130200893" style="zoom:50%;" /></center><p>数据包 8 被延迟得太多，当播放到它时还不可用。这种情况下可以有两种选择。</p><ul><li>第一种是跳过数据包 8 继续播放后续的数据包。</li><li>另一种方法是停止播放，直到数据包 8 到达，此时在播放的音乐或电影中就会出现一个恼人的间隙。</li></ul><center><img src="image-20191213130334229.png" srcset="/img/loading.gif" alt="image-20191213130334229" style="zoom:50%;" /></center><h1 id="5-TCP"><a href="#5-TCP" class="headerlink" title="5. TCP"></a>5. TCP</h1><h2 id="5-1-Overview"><a href="#5-1-Overview" class="headerlink" title="5.1 Overview"></a>5.1 Overview</h2><p>TCP[Transmission Control Protocol] provides a <strong><em><u>reliable end-to-end byte stream</u></em></strong> over an unreliable internetwork.</p><p>TCP must furnish (提供) the reliability that most users want and that IP does not provide.</p><ul><li><p>TCP 是面向连接的传输层协议。[三次握手]</p></li><li><p>每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的[一对一]。 </p></li><li><p>提供可靠交付的服务。</p></li><li><p>TCP 提供全双工通信。[同时收发]</p></li><li>面向字节流。 </li></ul><h2 id="5-2-TCP-The-Service-Model"><a href="#5-2-TCP-The-Service-Model" class="headerlink" title="5.2 TCP: The Service Model"></a>5.2 TCP: The Service Model</h2><ul><li>TCP 服务由发送端和接收端创建一种称为套接字（ socket ）的端点来获得</li></ul><div class="note note-error">            <p>Socket = IP地址 + port</p>          </div><ul><li>TCP连接是<strong><em><u>全双工</u></em></strong>的[必须全双工，一方给另一方发送消息，另一方应该回复“嗯嗯嗯，我在听”]</li><li>TCP连接是一个字节流，而不是消息流</li></ul><blockquote><p>如果发送进程将 4 个 512 字节的数据块写到一个 TCP 流中，那么这些数据有可能按 4 个 512 字节块、2 个 1024 字节块、 1 个 2048 字节块或者其他的方式被递交给接收进程。 接收端不管多么努力尝试，都无法获知这些数据被写入字节流时的单元大小。</p></blockquote><div class="card">     <div class="card__image">       <img class="image__lg" src="image-20191212233707007.png" srcset="/img/loading.gif" alt="image-20191212233707007" style="zoom:67%;" />  </div>     <div class="card__content">         <div class="card__header">             <h4>TCP面向byte stream的概念</h4>         </div>       </div></div><h2 id="5-3-TCP-header"><a href="#5-3-TCP-header" class="headerlink" title="5.3 TCP header"></a>5.3 TCP header</h2><p>每个TCP segment的起始部分是一个固定格式的 <strong><em><u>20 字节</u></em></strong>头。固定的头部之后可能有头的选项。如果该数据段有数据部分的话，那么在选项之后是最多可达 65535-20-20=65495 个字节的数据，这里的第一个 20 是指 IP 头，第二个 20 指 TCP 头。 没有任何数据的 TCP 段也是合法的，通常被用作确认和控制消息。</p><center><img src="image-20191215161710416.png" srcset="/img/loading.gif" alt="image-20191215161710416" style="zoom:50%;" /></center><ul><li>sequence number</li></ul><blockquote><p>是TCP数据部分的第一个字节在整个文件中所处第几个字节</p></blockquote><center><img src="image-20191215161855868.png" srcset="/img/loading.gif" alt="image-20191215161855868" style="zoom:50%;" /></center><ul><li>acknowledge number</li></ul><blockquote><p>期待发送者下一次发送的数据</p></blockquote><center><img src="image-20191213151314239.png" srcset="/img/loading.gif" alt="image-20191213151314239" style="zoom:50%;" /></center><ul><li>TCP header length</li></ul><blockquote><p>TCP header的长度，以word[4个bytes]为单位</p></blockquote><div class="card">     <div class="card__image">       <img class="image" src="image-20191215163422275.png" srcset="/img/loading.gif" alt="image-20191215163422275" style="zoom:50%;" />  </div>     <div class="card__content">         <div class="card__header">             <h4>CWE&ECE</h4>         </div>         <p>CWR和ECE用作拥塞控制的信号。</p>    <p>当receiver收到了来自网络的拥塞指示后，就设置ECE以便给sender发ECN-Echo[Explicit Congestion Notification-Echo]信号，告诉发送端放慢发送速率。</p>    <p>TCP sender设置CWR，给 TCP 接收端发 CWR 信号</p>    <p>receiver知道sender己经放慢速率，不必再给sender发 ECN-Echo 信号</p>   </div> </div><center><table>  <tr>    <td><div class="card">     <div class="card__image">       <img class="image" src="image-20191215162158221.png" srcset="/img/loading.gif" alt="image-20191215162158221" style="zoom:50%;" />  </div>     <div class="card__content">         <div class="card__header">             <h4>ACK</h4>         </div>         <p>对上一次发过来的数据进行确认, 如果设置为1表示acknowledge number字段有效。如果为0，说明acknowledge number字段无效，没有确认信息</p>        <p>因此发送建立会话请求时,ACK=0, 因为之前没有要确认的数据</p>    </div></div></td>  <td><div class="card">     <div class="card__image">       <img class="image" src="image-20191215162258403.png" srcset="/img/loading.gif" alt="image-20191215162258403" style="zoom:50%;" />  </div>     <div class="card__content">         <div class="card__header">             <h4>SYN</h4>         </div>         <p>表示要建立会话[to used to establish connections].比如我的电脑想要和某个网站建立连接 </p>        <p><u>SYN for CONNECTION REQUEST, SYN+ACK for CONNECTION ACCEPTED.</u></p>    </div> </div></td>  <td><div class="card">     <div class="card__image">       <img class="image"  src="image-20191215162320667.png" srcset="/img/loading.gif" alt="image-20191215162320667" style="zoom:50%;" />  </div>     <div class="card__content">         <div class="card__header">             <h4>FIN</h4>         </div>         <p>释放连接</p>  </div>    </div></td>  </tr></table></center><table>  <tr>    <td><div class="card">     <div class="card__image">       <img class="image" src="image-20191215162053100.png" srcset="/img/loading.gif" alt="image-20191215162053100" style="zoom:50%;" />  </div>     <div class="card__content">         <div class="card__header">             <h4>URG</h4>         </div>         <p>在sender,紧急，这个数据包不要等待前面缓存发送了，插到第一个，马上给我发 bjl</p>   </div> </div></td>    <td><div class="card">     <div class="card__image">       <img class="image" src="image-20191215162216454.png" srcset="/img/loading.gif" alt="image-20191215162216454" style="zoom:50%;" />  </div>     <div class="card__content">         <div class="card__header">             <h4>PSH</h4>         </div>         <p>在receiver,紧急，别处理缓存里的其他数据了，先处理这个包，bjl</p>   </div> </div></td>  </tr></table><div class="card">     <div class="card__image">       <img class="image" src="image-20191215162237847.png" srcset="/img/loading.gif" alt="image-20191215162237847" style="zoom:50%;" />  </div>     <div class="card__content">         <div class="card__header">             <h4>RST</h4>         </div>         <p></p>   </div> </div><ul><li>Window size</li></ul><blockquote><p>TCP发送和接收都存在一个缓存区域。TCP 中的流量控制是通过一个在缓存中的可变大小的滑动窗口来处理的。窗口大小（ Window size) 字段指定了从被确认的字节算起可以发送多少个字节。</p></blockquote><center><img src="image-20191215163057718.png" srcset="/img/loading.gif" alt="image-20191215163057718" style="zoom:50%;" /></center><p><img src="image-20191215165833678.png" srcset="/img/loading.gif" alt="image-20191215165833678" style="zoom:50%;" /></p><blockquote><p>首先计算机B要跟A说明自己的接受缓存是多少，然后A就会设置自己的发送缓存，不能超过B接收缓存的大小</p><p>然后A跟B说明自己接收缓存的大小，B设置其发送缓存</p></blockquote><ul><li><p>urgent</p><p>配合URG位使用，指明TCP数据中哪些是紧急的。比如urgent pointer设置为50，说明TCP数据中1-50是紧急的。</p></li></ul><center><img src="image-20191215164702576.png" srcset="/img/loading.gif" alt="image-20191215164702576" style="zoom:50%;" /></center><h2 id="5-4-TCP连接建立"><a href="#5-4-TCP连接建立" class="headerlink" title="5.4 TCP连接建立"></a>5.4 TCP连接建立</h2><p>通过三次握手来建立连接</p><p>Host 1执行CONNECT, 与Host 2建立连接</p><p>Host 1发送连接请求</p><blockquote><p><code>SYN</code>表示要建立connection, <code>SEQ=x</code>说明host 1发送的TCP数据的起始段是x</p></blockquote><p>Host 2接收连接请求，回复一个确认[如果拒绝请求的话，发送一个设置了 RST 的应答报文]</p><blockquote><p><code>SYN</code>表示建立connection, <code>SEQ=y</code>说明host 2发送的TCP数据的起始段是y, <code>ACK=x+1</code>说明确认了host 1发送过来的数据并且期待host1发送的下一个数据的起始段为x+1</p></blockquote><p>host 1再进行确认</p><blockquote><p>host 1已经开始发送数据x+1，用piggybacking的方式对host 2对起始段y进行确认</p></blockquote><center><img src="image-20191212111637936.png" srcset="/img/loading.gif" alt="image-20191212111637936" style="zoom:50%;" /></center><h2 id="5-5-TCP连接释放"><a href="#5-5-TCP连接释放" class="headerlink" title="5.5 TCP连接释放"></a>5.5 TCP连接释放</h2><ul><li>为了释放一个连接，任何一方都可以发送一个设置了 FIN 标志位的 TCP 段，这表示它己经没有数据要发送了。</li><li>当 FIN 段被另 一方确认后，这个方向上的连接就被关闭，不再发送任何数据。然而，另一个方向上或许还在继续着无限的数据流。</li><li>当两个方向都关闭后，连接才算被彻底释放。</li></ul><p>通常情况下，释 放一个连接需要 4 个 TCP 段：每个方向上一个 FIN 和一个 ACK。然而，第一个 ACK 和第二个 FIN 有可能被组合在同一个段中，从而将所需段总数降低到 3 个。</p><center><img src="image-20191215173851930.png" srcset="/img/loading.gif" alt="image-20191215173851930" style="zoom:50%;" /></center><h2 id="5-6-TCP连接管理模型"><a href="#5-6-TCP连接管理模型" class="headerlink" title="5.6 TCP连接管理模型"></a>5.6 TCP连接管理模型</h2><p>每条线都标记成一对“事件／动作“ [event / action]</p><center><img src="image-20191215173944466.png" srcset="/img/loading.gif" alt="image-20191215173944466" style="zoom:50%;" /></center><p>沿着client的路径[粗实线]</p><blockquote><p>当client上的一个应用程序发出<code>CONNECT</code>请求，本地的 TCP 实体创建一条连接记录，并将它标记为<code>SYN SENT</code>状态，然后发送一个<code>SYN</code>段。当 <code>SYN+ACK</code>到达的时候， TCP 发出三次握手过程的最后一个 <code>ACK</code> 段，然后切 换到 <code>ESTABLISHED</code> 状态。现在可以发送和接收数据了。</p><p>当一个应用结束时，它执行 <code>CLOSE</code> 原语，从而使本地的 TCP 实体发送一个 <code>FIN</code> 段， 并等待对应的 <code>ACK</code> 。当 <code>ACK</code> 到达时，状态迁移到 <code>FIN WAIT 2</code>，而且连接的一个方向被关闭。当另一方也关闭时，会到达一个 <code>FIN</code> 段，然后它被<code>ACK</code>。 现在，双方都已经关闭了连接，但是， TCP 要等待一段长度为最大数据包生存期两倍的时间，才能确保该连接上的所有数据包都己寿终正寝，以防万一发生确认被丢失的情形。当 计时器超时后， TCP 删除该连接记录。</p></blockquote><p>注意这里的close是fin, ack, fin, ack总共四次</p><p>沿着server的路径[虚线]</p><blockquote><p>服务器执行 LISTEN，并等待入境连接请求。当收到一个 <code>SYN</code> 时，服务器就确认该段并且进入到 <code>SYN RCVD</code> 状态。当服务器本身的 <code>SYN</code> 被确认后，就标志着三次握手过程的结束，服务器进入到 <code>ESTABLISHED</code> 状态。从现在开始双方可以传输数据了。</p><p>当客户完成了自己的数据传输，它就执行 <code>CLOSE</code>，从而导致 TCP 实体发送一个 <code>FIN 到服务器</code>。然后，服务器接到信号：当它也执行了<code>CLOSE</code>时， TCP 实体给客户发送一个 <code>FIN</code> 段。当该段的来自客户的确认返回后，服务器释放该连接，并且删除相应的连接记录。</p></blockquote><h2 id="5-7-TCP滑动窗口"><a href="#5-7-TCP滑动窗口" class="headerlink" title="5.7 TCP滑动窗口"></a>5.7 TCP滑动窗口</h2><center><img src="image-20191215185528057.png" srcset="/img/loading.gif" alt="image-20191215185528057" style="zoom:50%;" /></center><center><img src="image-20191215183419888.png" srcset="/img/loading.gif" alt="image-20191215183419888" style="zoom:50%;" /></center><h4>sender buffer</h4><img class="image" src="image-20191215184124008.png" srcset="/img/loading.gif" alt="image-20191215184124008" style="zoom:50%;" /><h4>receiver buffer</h4>  <p><img class="image" src="image-20191215184312475.png" srcset="/img/loading.gif" alt="image-20191215184312475" style="zoom:50%;" /></p><p>delayed acknowledgement</p><p><strong>nagle’s algorithm</strong>—-解决发送端应用每次向 TCP 传递一个字节而引起的问题</p><p>因为发送端发送多个小数据包的工作方式效率很低[比如41字节的数据包只包含1个字节的数据]</p><blockquote><p>当数据每次以很少量方式进入到发送端时，发送端只是发送第一次到达的数据字节，然后将其余后面到达的字节缓冲起来，直到发送出去的那个数据包被确认</p><p>然后将所有缓冲的字节放在一个 TCP 段 中发送出去，并且继续开始缓冲字节，直到下一个段被确认。</p><p>这就是说，任何时候只有第 一个发送的数据包是小数据包。如果在一个来回时间内应用程序发送了许多数据，那么 Nagle 算法可以将这些数据放置在一个段中发送，由此大大地减少所需的带宽。另外，如 果应用传递来的数据足够多，多到可以填满一个最大数据段，则该算法也允许发送一个新的段。</p></blockquote><p><strong><em>Clark’s algorithm</em></strong>—-解决由于接收端应用每次从 TCP 流中读取一个字节而引起的问题</p><p>降低TCP性能的另一个问题是<strong><em>silly window syndrome</em></strong>。</p><blockquote><p>当数据以大块形式传递,但是接收端的交互式应用每次只读取一个字节数据</p><p>初始时，接收端的 TCP 缓冲区为满，发送端知道这一点[即它有一个大小为 0 的窗口]。然后，交互式应用从TCP 流中读取一个字符，这个动作使得接收端的 TCP 欣喜若狂，它立刻发送一个窗口更新段给发送端，告诉它现在可以发送 1 个字节过来。发送端很感激，立即发送 1 个字节。现 在缓冲区又满了，所以，接收端对这 1 字节的数据段进行确认，同时设置窗口大小为 0。</p></blockquote><p>Clark 的解决方案是禁止接收端发送只有 1 个字节的窗口更新段。相反，它强制接收端必须等待一段时间，直到有了一定数量的可用空间之后再通告给对方。特别是，只有当接收端能够处理它在建立连接时宣告的最大数据段，或者它的缓冲区一半为空时（相当于两者之中取较小的值〉，它才发送窗口更新段。而且，发送端不发送太小的段也会有所帮助。 相反，它应该等待一段时间，直到可以发送一个满的段，或者至少包含接收端缓冲区一半大小的段。</p><center><img src="image-20191215192956539.png" srcset="/img/loading.gif" alt="image-20191215192956539" style="zoom:50%;" /></center><h2 id="5-8-TCP-timer-management"><a href="#5-8-TCP-timer-management" class="headerlink" title="5.8 TCP timer management"></a>5.8 TCP timer management</h2><h3 id="A-重传计时器-RTO-Retransmission-Timeout"><a href="#A-重传计时器-RTO-Retransmission-Timeout" class="headerlink" title="A. 重传计时器(RTO, Retransmission Timeout)"></a>A. 重传计时器(RTO, Retransmission Timeout)</h3><p>当 TCP 实体发出一个段时，它同时启动一个重传计时器。</p><ul><li>如果在该计时器超时前该段被确认，则计时器被停止。</li><li>如果在确认到来之前计时器超时，则段被重传（并且该计时器被重新启动）</li></ul><p><br/></p><h4 id="如何设置超时间隔"><a href="#如何设置超时间隔" class="headerlink" title="如何设置超时间隔"></a>如何设置超时间隔</h4><p>动态算法，根据网络性能的连续测量’情况，不断地调整超时间隔</p><p><strong><em>Jacobson算法</em></strong></p><p>对于每一个连接，TCP 维护一个变量SRTT[Smoothed Round-Trip Time，平滑的往返时间]，它代表到达接收方往返时间的当前最佳估计值。</p><p>当一个段被发送出去时， TCP 启动一个计时器，该计时器有两个作用:</p><ul><li>一是看该段被确认需要多长时间</li><li>二是若确认时间太长，则触发重传动作。</li></ul><p><strong><em>A. SRTT</em></strong></p><p>如果在计时器超时前确认返回，则 TCP 测量这次确认所花的时间RTT。然后 它根据下面的公式更新 SRTT: </p><script type="math/tex; mode=display">SRTT ＝\alpha SRTT + (1-\alpha） RTT</script><p>这里 $\alpha$ 是一个平滑因子，它决定了老的 RTT 值所占的权重。典型情况下 $\alpha＝\frac{7}{8}$ 。</p><p><br/></p><p><strong><em>B. RTTVAR</em></strong></p><p>即使有了一个好的 SRTT 值，要选择一个合适的重传超时间隔仍然不是一件容易的事情。Jacobson 提议让超时值对往返时间的变化以及平滑的往返时间要变得敏感。这种改变要求跟踪另一个平滑变量RTTVAR[ Round-Trip Time VARiation]</p><script type="math/tex; mode=display">RTTVAR=\beta RTTVAR+(1-\beta)\vert SRTT-R\vert</script><p>通常<script type="math/tex">\beta=\frac{3}{4}</script></p><p><strong><em>C. RTO</em></strong></p><p>重传超时值RTO</p><script type="math/tex; mode=display">RTO=SRTT+4\times RTTVAR</script><p>但是采集往返时间样值R过程中还有一个问题是</p><blockquote><p>当一个段超时并重新发送以后该怎么办？确认到达时，无法判断该确认是针对第一次传输，还是针对后来的重传。</p><p>若猜测错误，则会严重影响重传超时值RTT</p></blockquote><p><strong><em>Karn算法</em></strong></p><blockquote><p>不更新任何重传段的估算值。</p><p>此外，每次连续重传的超时间隔值加倍，直到段能一次通过为止。</p></blockquote><h3 id="B-持续计时器-persistence-timer"><a href="#B-持续计时器-persistence-timer" class="headerlink" title="B. 持续计时器 persistence timer"></a>B. 持续计时器 persistence timer</h3><p>重传计时器并不是 TCP 使用的唯一计时器。第二个计时器是持续计时器。它的设计意图是为了避免出现以下所述的死锁情况:</p><blockquote><p>接收端发送一个窗口大小为 0 的确认，让发送端等一等。稍后，接收端更新了窗口，但是，携带更新消息的数据包丢失了。</p><p>现在，发送端和接收端都在等待对方的进一步动作。</p><p>当持续计时器超时后，发送端给接收端发送一个探询消息。接收端对探询消息的响应是将窗口大小告诉发送端。如果它仍 然为 0，则重置持续计时器，并开始下一轮循环。如果它非 0，则现在可以发送数据了。</p></blockquote><h3 id="C-保活计时器-keepalive-timer"><a href="#C-保活计时器-keepalive-timer" class="headerlink" title="C. 保活计时器[keepalive timer]"></a>C. 保活计时器[keepalive timer]</h3><p>to check whether the other side is still there</p><p>当一个连接空闲了较长一段时间以后，保活计时器可能超时，从而促使某一端查看另一端是否仍然还在。 如果另一端没有响应，则终止连接。</p><h2 id="5-9-TCP-congestion-control"><a href="#5-9-TCP-congestion-control" class="headerlink" title="5.9 TCP congestion control"></a>5.9 TCP congestion control</h2><center><img src="image-20191203131449883.png" srcset="/img/loading.gif" alt="image-20191203131449883" style="zoom:40%;" /></center><p>当提供给任何网络的负载超过它的处理能力时，拥塞便会产生。当路由器上的队列增长到很大时，网络层检测到拥塞，并试图通过丢弃数据包来管理拥塞。传输层接收到从网络层反馈来的拥塞信息，并减慢它发送到网络的流量速率。</p><ul><li><p>TCP维持一个<strong><em><u>拥塞窗口</u></em></strong> (congestion window ），<strong><em>窗口大小是任何时候发送端可以往网络发送的<u>字节数</u></em></strong>。相应的速率则是窗口大小除以连接的<strong><em>往返时间</em></strong>。 TCP 根据 AIMD 规则来调整该窗口的大小。</p></li><li><p>一个流量控制窗口，该窗口指出了<strong><em>接收端可以缓冲的字节数</em></strong>。</p></li></ul><p>要并发跟踪这两个窗口，可能发送的字节数是两个窗口中较小的那个。 因此，有效窗口是发送端认为的应该大小和接收端认为的应该大小两者中的<strong><em>较小者</em></strong>。</p><blockquote><p>如果拥塞窗口或流量控制窗口暂时己满，则 TCP 将停止发送数据。</p><p>如果接收端说“发送 64 KB数据”，但发送端知道超过 32KB 的突发将阻塞网络，它就只发送32KB</p><p>如果接收端说“发送 64 KB数据”，发送端知道高达 128 KB的突发通过网络都毫不费力，它会发送要求的全部 64 KB。</p></blockquote><p><br/></p><p>Congestion Control Algorithm by Van Jacobson (1988) </p><ul><li><p>To approximate an <strong>AIMD</strong> congestion window</p></li><li><p>To represent congestion signal by packet loss</p></li><li>To measure packet loss by a retransmission timer </li><li>To split data into segments (Ack Clock) </li><li>To use the optimal congestion window </li></ul><center><img src="image-20191203140815575.png" srcset="/img/loading.gif" alt="image-20191203140815575" style="zoom:50%;" /></center><p><br/></p><h3 id="i-slow-start"><a href="#i-slow-start" class="headerlink" title="i. slow start"></a>i. slow start</h3><p>从初始值1启动，呈指数增长</p><center><img src="image-20191212234251930.png" srcset="/img/loading.gif" alt="image-20191212234251930" style="zoom:40%;" /></center><blockquote><p>在第一次往返时间，发送端把一个数据包注入网络（并且接收端接收到一个数据包）。在接下来的一个往返时间，发送端发出两个数据包，然后在第三个往返时间发送四个。</p><p>当发送端得到一个确认，他就把拥塞窗口的大小+1，并立即将两个数据包发送到网络中</p></blockquote><p>由于慢速启动导致拥塞窗口按指数增长，网络很快拥塞。为了保持对慢速启动的控制，发送端为每个连接维持一个<strong><em><u>slow start threshold</u></em></strong>。</p><blockquote><p>最初，这个值被设置得任意高。 TCP 以慢速启动方式不断增加拥塞窗口，直到发生超时，或者拥塞窗口超过该阔值。</p><p>每当检测到丢包，比如超时了，slow start threshold就被设置为当前拥塞窗口的一半，整个过程再重新启动。</p></blockquote><h3 id="ii-Congestion-Control"><a href="#ii-Congestion-Control" class="headerlink" title="ii. Congestion Control"></a>ii. Congestion Control</h3><p>一旦slow start超过了threshold, TCP就切换到线性增加，每个往返时间，拥塞窗口只增加一段</p><center><img src="image-20191203143540623.png" srcset="/img/loading.gif" alt="image-20191203143540623" style="zoom:40%;" /></center><p>拥塞窗口cwnd和最大段长MSS，一个常见的近似做法</p><p>针对cwnd/MSS中可能被确认的每个数据包，将cwnd增加$(MSS \times MSS)/cwnd$</p><h3 id="iii-TCP-Tahoe"><a href="#iii-TCP-Tahoe" class="headerlink" title="iii.  TCP Tahoe"></a>iii.  TCP Tahoe</h3><center><img src="image-20191203144306819.png" srcset="/img/loading.gif" alt="image-20191203144306819" style="zoom:50%;" /></center><center><img src="image-20191215202752438.png" srcset="/img/loading.gif" alt="image-20191215202752438" style="zoom:50%;" /></center><ul><li>When <strong>cwnd</strong> is below <strong>Threshold</strong>, sender in <u>slow-start</u> phase, window grows <u>exponentially</u>. </li></ul><center><img src="image-20191215205611729.png" srcset="/img/loading.gif" alt="image-20191215205611729" style="zoom: 33%;" /></center><center><img src="image-20191215205648912.png" srcset="/img/loading.gif" alt="image-20191215205648912" style="zoom:33%;" /></center><center><img src="image-20191215205720002.png" srcset="/img/loading.gif" alt="image-20191215205720002" style="zoom: 33%;" /></center><center><img src="image-20191215205754864.png" srcset="/img/loading.gif" alt="image-20191215205754864" style="zoom:33%;" /></center><ul><li>When <strong>cwnd</strong> is above <strong>Threshold</strong>, sender is in <u>congestion-avoidanc</u>e phase, window grows <u>linearly</u>. </li></ul><center><img src="image-20191215205825740.png" srcset="/img/loading.gif" alt="image-20191215205825740" style="zoom:33%;" /></center><ul><li><p>When packet loss occurs</p><center><img src=image-20191215205912344.png" alt="image-20191215205912344" style="zoom:33%;" /></center><ul><li><strong>cwnd</strong> instead set to 1 MSS; </li><li>window then grows exponentially to a <strong>threshold</strong>, then grows linearly</li><li>Threshold =1/2 of <strong>cwnd</strong> before loss event </li></ul></li></ul><center><img src="image-20191215205948869.png" srcset="/img/loading.gif" alt="image-20191215205948869" style="zoom:33%;" /></center><p><br/></p><h3 id="iv-TCP-Reno"><a href="#iv-TCP-Reno" class="headerlink" title="iv. TCP Reno"></a>iv. TCP Reno</h3><center><img src="image-20191203144359731.png" srcset="/img/loading.gif" alt="image-20191203144359731" style="zoom:40%;" /></center><div class="note note-info">            <p>发送端有一个快速方法来识别它的包己经被丢失。当丢失数据包的后续数据包到达接收端时，它们触发给发送端返回确认。这些确认段携带着相同的确认号，称为重复确认。发送端每次收到重复确认时，很可能另一个包己经到达接收端，而丢失的那个包仍然没有出现。TCP认为三个重复确认意味着这个数据包已经丢失</p>          </div><center><img src="image-20191203144834670.png" srcset="/img/loading.gif" alt="image-20191203144834670" style="zoom:35%;" /></center><ul><li>When <strong>cwnd</strong> is below <strong>Threshold</strong>, sender in <u>slow-start</u> phase, window grows <u>exponentially</u>. </li><li>When <strong>cwnd</strong> is above <strong>Threshold</strong>, sender is in <u>congestion-avoidanc</u>e phase, window grows <u>linearly</u>. </li><li>When a triple duplicate ACK occurs <ul><li><strong>cwnd</strong> is cut in half</li><li>window then grows linearly </li><li>Threshold =1/2 of <strong>cwnd</strong> before loss event </li></ul></li><li>When timeout occurs <ul><li><strong>cwnd</strong> instead set to 1 MSS; </li><li>window then grows exponentially to a <strong>threshold</strong>, then grows linearly </li><li>Threshold =1/2 of <strong>cwnd</strong> before loss event </li></ul></li></ul><p>总结如下：</p><center><img src="image-20191203150750984.png" srcset="/img/loading.gif" alt="image-20191203150750984" style="zoom:40%;" /></center><h3 id="v-TCP-throughput"><a href="#v-TCP-throughput" class="headerlink" title="v. TCP throughput"></a>v. TCP throughput</h3><p>What’s the average throughput of TCP as a function of window size and RTT?[Ignore slow start]</p><blockquote><p>Let W be the window size when loss occurs. </p><p>When window is W, throughput is $\frac{W}{RTT }$</p><p>Just after loss, window drops to $\frac{W}{2}$, throughput to $\frac{W}{2RTT}$. </p><p>Average throughout: $\frac{0.75 W}{RTT}$</p></blockquote><h3 id="vi-一道例题"><a href="#vi-一道例题" class="headerlink" title="vi. 一道例题"></a>vi. 一道例题</h3><center><img src="image-20191203151238340.png" srcset="/img/loading.gif" alt="image-20191203151238340" style="zoom:40%;" /></center><ul><li><p><strong>(1).</strong> Identify the intervals of time when TCP slow start is operating. </p><p>看各阶段持续的时间。slow start有两段。答案是9</p></li><li><p><strong>(2).</strong> Identify the intervals of time when TCP congestion avoidance is </p><p>operating. </p><p>15</p></li><li><p><strong>(3).</strong> After the 16th transmission round, is segment loss detected by a triple duplicate ACK or by a timeout? </p><p>triple duplicate ACK 因为cwnd只降了一半</p></li><li><p><strong>(4).</strong> After the 22nd transmission round, is segment loss detected by a triple duplicate ACK or by a timeout? </p><p>timeout, 因为 cwnd降为1</p></li><li><p><strong>(5).</strong> What is the initial value of <strong>Threshold</strong> at the first transmission round? </p><p>32 因为32的时候进入了congestion avoidance阶段</p></li><li><p><strong>(6).</strong> What is the value of <strong>Threshold</strong> at the 18th transmission round? </p><p>21 threshold变成16th cwnd的一半</p></li><li><p><strong>(7).</strong> What is the value of <strong>Threshold</strong> at the 24th transmission round? </p><p>13 threshold变成16th cwnd的一半</p></li><li><p><strong>(8).</strong> Assuming a packet loss is detected after the 26th round by the receipt of a triple duplicate ACK, what will be the values of the <strong>cwnd</strong> and <strong>Threshold</strong>? </p><p>cwnd:4     threshold:4</p></li><li><p><strong>(9).</strong> Suppose <strong>TCP Tahoe</strong> is used (instead of TCP Reno), and assume that triple duplicate ACKs are received at the 16th round. What are the <strong>Threshold</strong> and <strong>cwnd</strong> at the 19th round? </p><p>cwnd:4     threshold:21</p></li></ul><p><br/></p><p>reference:</p><p>[1] <a href="https://andrewpqc.github.io/2018/07/16/transport-layer-udp-and-tcp/" target="_blank" rel="noopener">https://andrewpqc.github.io/2018/07/16/transport-layer-udp-and-tcp/</a></p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CA - Storage</title>
    <link href="/2019/12/08/ComputerArchitecture/Storage/"/>
    <url>/2019/12/08/ComputerArchitecture/Storage/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><center><img src="image-20191208134608723.png" srcset="/img/loading.gif" alt="image-20191208134608723" style="zoom:50%;" /></center><h2 id="1-1-缓存性能"><a href="#1-1-缓存性能" class="headerlink" title="1.1 缓存性能"></a>1.1 缓存性能</h2><p>CPU execution time</p><script type="math/tex; mode=display">=(CPU\, clock\, cycles + Memory\, stall\, cycles)\times Clock\, cycle\, time</script><p>{:.warning}</p><p>这里CPU clock cicles包括handle cache hit/miss的时间</p><center><img src="image-20191208135106480.png" srcset="/img/loading.gif" alt="image-20191208135106480" style="zoom:60%;" /></center><center><img src="image-20191208135244903.png" srcset="/img/loading.gif" alt="image-20191208135244903" style="zoom:60%;" /></center><p>看一道例题</p><blockquote><p>a computer with CPI=1 when cache hit.  </p><p>50% instructions are loads and stores;</p><p>2% miss rate, 25 cc miss penalty;</p><p><strong>Q:</strong> how much faster would the computer be if all instructions were cache hits?</p></blockquote><p>Answer:</p><ol><li>always hit:</li></ol><p>CPU execution time = (CPU clocks cycles + Memory stall cycles) * clock cycle</p><p>=<script type="math/tex">(IC \times CPI + 0) \times clock\,cycle</script></p><p>=<script type="math/tex">IC \times clock\, cycle</script></p><p><br/></p><ol><li>with misses</li></ol><p>Memory stall cycles</p><p>= $IC \times \frac{Memory\, accesses}{Instruction}\times Miss\, rate\times Miss\, penalty$</p><p>=$IC\times(1+0.5)\times 0.02\times 25$</p><p>=$IC\times 0.75$</p><p>memory accesses=1.5是因为执行任何一条指令都要访问memory取指令，并且50%的指令是load, store 因此 1+0.5=1.5</p><p>CPU execution time = (CPU clocks cycles + Memory stall cycles) $\times$ clock cycle</p><p>=$(IC\times 1.0+IC\times 0.75)\times$clock cycle</p><p>=$1.75\times $clock cycle</p><p>所以比值是1.75</p><h2 id="1-2-4个存储器层次结构问题"><a href="#1-2-4个存储器层次结构问题" class="headerlink" title="1.2 4个存储器层次结构问题"></a>1.2 4个存储器层次结构问题</h2><p>Q1: Where can a block be placed in the upper level? (block placement)</p><p>Q2: How is a block found if it is in the upper level? (block identification)</p><p>Q3: Which block should be replaced on a miss? (block replacement)</p><p>Q4: What happens on a write? (write strategy)</p><center><img src="image-2019120874232.png" srcset="/img/loading.gif" alt="截屏2019-12-08下午7.42.32" style="zoom:67%;" /></center><center><img src="image-20191208194519623.png" srcset="/img/loading.gif" alt="image-20191208194519623" style="zoom: 67%;" /></center><h3 id="A-Write-Strategy"><a href="#A-Write-Strategy" class="headerlink" title="A. Write Strategy"></a>A. Write Strategy</h3><p><code>Write hit</code></p><ul><li>write-through: info is written to both the block in the cache and to the block in the lower-level memory</li><li>write-back: info is written only to the block in the cache;  to the main memory only when the modified cache block is replaced[dirty bit]</li></ul><p><code>Write miss</code></p><ul><li>Write allocate: data at the missed-<strong>write</strong> location is loaded to cache, followed by a <strong>write</strong>-hit operation  </li><li>No-write allocate[write around]: data at the missed-<strong>write</strong> location is not loaded to cache, and is written directly to the backing store.  ;  <em>until the program tries to read the block, the data is loaded to cache;</em></li></ul><center><img src="image-20191208201918610.png" srcset="/img/loading.gif" alt="image-20191208201918610" style="zoom:50%;" /></center><ol><li>No-Write allocate:  4 misses + 1 hit</li></ol><center><img src="image-20191208202025669.png" srcset="/img/loading.gif" alt="image-20191208202025669" style="zoom:50%;" /></center><ol><li>Write allocate:  2 misses + 3 hits</li></ol><center><img src="image-20191208202722945.png" srcset="/img/loading.gif" alt="image-20191208202722945" style="zoom:50%;" /></center><h1 id="2-缓存性能"><a href="#2-缓存性能" class="headerlink" title="2. 缓存性能"></a>2. 缓存性能</h1><h3 id="Hit-or-Miss-How-long-will-it-take"><a href="#Hit-or-Miss-How-long-will-it-take" class="headerlink" title="Hit or Miss: How long will it take?"></a>Hit or Miss: How long will it take?</h3><p>Average memory access time = Hit time + Miss rate x Miss penalty</p><ul><li><strong>Example</strong></li></ul><blockquote><p>16KB instr cache + 16KB data cache;</p><p>or, 32KB unified cache;</p><p>36% data transfer instructions;</p><p>(load/store takes 1 extra cc on unified cache)</p><p>1 CC hit; 200 CC miss penalty;</p></blockquote><center><img src="image-20191208204528711.png" srcset="/img/loading.gif" alt="image-20191208204528711" style="zoom:30%;" /></center><blockquote><p><strong>Q1:</strong> split cache or unified cache has lower miss rate? </p></blockquote><p>Answer:</p><center><img src="image-20191208204804983.png" srcset="/img/loading.gif" alt="image-20191208204804983" style="zoom:40%;" /></center><ol><li>split cache</li></ol><p>16KB instruction Miss rate</p><p>​        = <script type="math/tex">\frac{3.82}{1000}/1=0.004</script></p><p>16KB data miss rate</p><p>​        =<script type="math/tex">\frac{40.9}{1000}/0.36=0.114</script></p><p>assume 74% of memory accesses are instruction references</p><p>Overall miss rate</p><p>​        =<script type="math/tex">(74\%\times 0.004)+(26\%\times 0.114)=0.0326</script></p><ol><li>unified cache</li></ol><p>Miss rate</p><p>=<script type="math/tex">\frac{43.3}{1000}/(1.0+0.36)=0.0318</script></p><blockquote><p><strong>Q2:</strong> average memory access time?</p></blockquote><center><img src="image-20191208205644462.png" srcset="/img/loading.gif" alt="image-20191208205644462" style="zoom:40%;" /></center><center><img src="image-20191208205754992.png" srcset="/img/loading.gif" alt="image-20191208205754992" style="zoom:40%;" /></center><h2 id="2-1-存储器平均访问时间与处理器性能"><a href="#2-1-存储器平均访问时间与处理器性能" class="headerlink" title="2.1 存储器平均访问时间与处理器性能"></a>2.1 存储器平均访问时间与处理器性能</h2><h1 id="3-Six-Basic-Cache-Optimizations"><a href="#3-Six-Basic-Cache-Optimizations" class="headerlink" title="3. Six Basic Cache Optimizations"></a>3. Six Basic Cache Optimizations</h1><p>我们将所有缺失分成三类</p><ul><li><p>强制缺失[Compulsory]</p><p>cold-start/first-reference misses;</p></li><li><p>容量缺失[Capacity]</p><p>cache size limit;</p><p> blocks discarded and later retrieved;</p></li><li><p>冲突缺失</p><p>collision misses: associativity</p><p>a block discarded and later retrieved in a set;</p></li></ul><center><img src="image-20191208213224033.png" srcset="/img/loading.gif" alt="image-20191208213224033" style="zoom:30%;" /></center><center><img src="image-20191208213207928.png" srcset="/img/loading.gif" alt="image-20191208213207928" style="zoom:30%;" /></center><center><img src="image-20191208213148539.png" srcset="/img/loading.gif" alt="image-20191208213148539" style="zoom:30%;" /></center><h2 id="3-1-Larger-Block-size"><a href="#3-1-Larger-Block-size" class="headerlink" title="3.1 Larger Block size"></a>3.1 Larger Block size</h2><ul><li><p><strong>Reduce</strong> compulsory misses</p><p>​    Leverage spatial locality</p></li><li><p><strong>Reduce</strong> static power</p><p>​    block size增大，地址里面index位就变多，tag位数就变少，比较时需要的工作量就变少</p></li><li><p><strong>Increase</strong> conflict/capacity misses</p><p>​    Fewer block in the cache</p></li></ul><center><img src="image-20191208214954621.png" srcset="/img/loading.gif" alt="image-20191208214954621" style="zoom: 30%;" /></center><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><center><img src="image-20191208215035983.png" srcset="/img/loading.gif" alt="image-20191208215035983" style="zoom:40%;" /></center><p><strong>Answer</strong></p><p> avg mem access time</p><p>​        =hit time + miss rate x miss penalty</p><div class="note note-info">            <p> assume 1-CC hit time</p><p> for a 256-byte block in a 256 KB cache:</p><p> avg mem access time</p><p>​        = 1 + 0.49% x (80 + 2x256/16) = 1.5 cc</p>          </div><p> 2x256/16是因为存储器2cc能给cache传回16bytes</p><h2 id="3-2-Larger-cache"><a href="#3-2-Larger-cache" class="headerlink" title="3.2 Larger cache"></a>3.2 Larger cache</h2><ul><li><p><strong>Reduce</strong> capacity misses</p></li><li><p><strong>Increase</strong> hit time, cost, and power</p></li></ul><h2 id="3-3-Higher-Associativity"><a href="#3-3-Higher-Associativity" class="headerlink" title="3.3 Higher Associativity"></a>3.3 Higher Associativity</h2><ul><li><p><strong>Reduce</strong> conflict misses</p></li><li><p><strong>Increase</strong> hit time</p></li></ul><h2 id="3-4-Multilevel-cache"><a href="#3-4-Multilevel-cache" class="headerlink" title="3.4 Multilevel cache"></a>3.4 Multilevel cache</h2><ul><li><strong>Reduce</strong> miss penalty</li></ul><p><br/></p><h4 id="A-Two-level-cache"><a href="#A-Two-level-cache" class="headerlink" title="A. Two-level cache"></a>A. Two-level cache</h4><p> Add another level of cache between the original cache and memory</p><ul><li><p><strong>L1</strong>: small enough to match the clock cycle time of the fast processor;</p></li><li><p><strong>L2</strong>: large enough to capture many accesses that would go to main memory, lessening miss penalty</p></li></ul><center><img src="image-20191208220714030.png" srcset="/img/loading.gif" alt="image-20191208220714030" style="zoom:50%;" /></center><h4 id="B-Average-memory-access-time"><a href="#B-Average-memory-access-time" class="headerlink" title="B. Average memory access time"></a>B. Average memory access time</h4><p>=Hit timeL1 + Miss rateL1 x Miss penaltyL1</p><p>=Hit timeL1 + Miss rateL1</p><p> x(Hit timeL2+Miss rateL2xMiss penaltyL2)</p><h4 id="C-Average-mem-stalls-per-instruction"><a href="#C-Average-mem-stalls-per-instruction" class="headerlink" title="C. Average mem stalls per instruction"></a>C. Average mem stalls per instruction</h4><p>=Misses per instructionL1 x Hit timeL2</p><p> + Misses per instrL2 x Miss penaltyL2</p><h4 id="D-Local-miss-rate"><a href="#D-Local-miss-rate" class="headerlink" title="D. Local miss rate"></a>D. Local miss rate</h4><p> the number of misses in a cache</p><p> divided by the total number of mem accesses to <u>this cache</u>;</p><p> {:.info}</p><p>分成 Miss rateL1, Miss rateL2</p><h4 id="E-Global-miss-rate"><a href="#E-Global-miss-rate" class="headerlink" title="E. Global miss rate"></a>E. Global miss rate</h4><p> the number of misses in the cache </p><p> divided by the number of mem accesses generated by the processor;</p><p> {:.info}</p><p>L1的全局缺失率Miss rate<strong>L1</strong>,<u>L2的全局缺失率 Miss rateL1 x Miss rateL2</u></p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><blockquote><p>1000 mem references -&gt; 40 misses in L1 and 20 misses in L2;</p><p>miss penalty from L2 is 200 cc;</p><p>hit time of L2 is 10 cc;</p><p>hit time of L1 is 1 cc;</p><p>1.5 mem references per instruction;</p><p> <strong>Q: 1.</strong> various miss rates?</p></blockquote><p> <strong>L1:</strong> local = global</p><p> 40/1000 = 4%</p><p> <strong>L2:</strong></p><p> local: 20/40 = 50%</p><p> global: 20/1000 = 2%</p><blockquote><p><strong>Q: 2.</strong> avg mem access time?</p></blockquote><p>average memory access time</p><p>=Hit timeL1 + Miss rateL1</p><p> x(Hit timeL2+Miss rateL2xMiss penaltyL2)</p><p>=1 + 4% x (10 + 50% x 200)</p><p>=5.4</p><blockquote><p> <strong>Q: 3.</strong> avg stall cycles per instruction?</p></blockquote><p>average stall cycles per instruction</p><p>=Misses per instructionL1 x Hit timeL2</p><p> + Misses per instrL2 x Miss penaltyL2</p><p>=(1.5x40/1000)x10+(1.5x20/1000)x200</p><p>=6.6</p><h2 id="2-5-Prioritize-read-misses-over-writes"><a href="#2-5-Prioritize-read-misses-over-writes" class="headerlink" title="2.5  Prioritize read misses over writes"></a>2.5  Prioritize read misses over writes</h2><ul><li><strong>Reduce</strong> miss penalty</li></ul><div class="note note-info">            <p>这种方法使得在write buffer将数据写入memory之前，就可以为read操作提供服务</p>          </div><h2 id="2-6-Avoid-address-translation-during-indexing-cache"><a href="#2-6-Avoid-address-translation-during-indexing-cache" class="headerlink" title="2.6 Avoid address translation during indexing cache"></a>2.6 Avoid address translation during indexing cache</h2><p>虚拟缓存</p><h1 id="4-Ten-advanced-cache-optimizations"><a href="#4-Ten-advanced-cache-optimizations" class="headerlink" title="4. Ten advanced cache optimizations"></a>4. Ten advanced cache optimizations</h1><center><img src="image-20191209100308445.png" srcset="/img/loading.gif" alt="image-20191209100308445" style="zoom: 33%;" /></center><h2 id="4-1-Small-and-Simple-First-Level-Caches"><a href="#4-1-Small-and-Simple-First-Level-Caches" class="headerlink" title="4.1 Small and Simple First-Level Caches"></a>4.1 Small and Simple First-Level Caches</h2><ul><li>Small size</li></ul><blockquote><p>support a fast clock cycle</p><p>reduce power</p></blockquote><ul><li>Lower associativity</li></ul><blockquote><p>reduce both hit time and power</p><p>(direct-mapped caches can overlap the tag check with the transmission of the data)</p></blockquote><h2 id="4-2-Way-prediction"><a href="#4-2-Way-prediction" class="headerlink" title="4.2 Way prediction"></a>4.2 Way prediction</h2><p>•Reduce conflict misses and hit time</p><p>•<strong>Way prediction</strong></p><p> <em>block predictor bits</em> are added to each block to predict the way/block within the set of the <em>next</em> cache access</p><p> the multiplexor is set <strong>early to select the desired block</strong>;</p><p> only a single tag comparison is performed <strong>in parallel with cache reading</strong>;</p><p> a miss results in checking the other blocks for matches in the next clock cycle;</p><h2 id="4-3-Pipelined-Cache-Access"><a href="#4-3-Pipelined-Cache-Access" class="headerlink" title="4.3 Pipelined Cache Access"></a>4.3 Pipelined Cache Access</h2><ul><li><p>Increase cache bandwidth</p></li><li><p>Higher latency</p></li><li><p>Greater penalty on mispredicted branches and more clock cycles between issuing the load and using the data </p></li></ul><h2 id="4-4-Nonblocking-caches"><a href="#4-4-Nonblocking-caches" class="headerlink" title="4.4 Nonblocking caches"></a>4.4 Nonblocking caches</h2><blockquote><p>对于允许乱序执行的流水化计算机，他的处理器不必因为一次数据缓存缺失而停顿。在等待数据缓存返回缺失数据时，处理器可以继续从指令缓存中提取指令。nonblocking cache允许数据缓存在一次缺失期间继续提供缓存命令</p></blockquote><ul><li>Increase cache bandwidth</li></ul><h2 id="4-5-Multibanked-caches"><a href="#4-5-Multibanked-caches" class="headerlink" title="4.5 Multibanked caches"></a>4.5 Multibanked caches</h2><blockquote><p>Divide cache into independent banks that support simultaneous accesses</p><p>Sequential interleaving spread the addresses of blocks sequentially across the banks</p></blockquote><center><img src="image-20191217202233856.png" srcset="/img/loading.gif" alt="image-20191217202233856" style="zoom:50%;" /></center><ul><li>Increase cache bandwidth</li></ul><h2 id="4-6-Critical-Word-First-amp-Early-Restart"><a href="#4-6-Critical-Word-First-amp-Early-Restart" class="headerlink" title="4.6 Critical Word First &amp; Early Restart"></a>4.6 Critical Word First &amp; Early Restart</h2><p>通常CPU只会request一个word, 但是一个cache line对应了很多个word</p><ul><li>critical word first</li></ul><blockquote><p>首先请求critical word也就是CPU request的那个word, 然后发送给CPU, 然后再去请求一个cache line剩余的部分</p></blockquote><ul><li>early restart</li></ul><blockquote><p>按正常顺序获取word, 不需要等待一个cache line全部放入缓存再发送给处理器，而是critical word到了就直接发送给处理器，不需要等待还没有完成传输的word</p></blockquote><ul><li>Reduce miss penalty</li></ul><h2 id="4-7-Merging-Write-buffer"><a href="#4-7-Merging-Write-buffer" class="headerlink" title="4.7 Merging Write buffer"></a>4.7 Merging Write buffer</h2><p>Write merging merges four entries (with sequential addresses)  into a single buffer entry</p><center><img src="image-20191217203849064.png" srcset="/img/loading.gif" alt="image-20191217203849064" style="zoom:50%;" /></center><ul><li>Reduce miss penalty</li></ul><h2 id="4-8-Compiler-optimizations"><a href="#4-8-Compiler-optimizations" class="headerlink" title="4.8 Compiler optimizations"></a>4.8 Compiler optimizations</h2><h3 id="A-Loop-interchange"><a href="#A-Loop-interchange" class="headerlink" title="A. Loop interchange"></a>A. Loop interchange</h3><h4 id="before"><a href="#before" class="headerlink" title="before"></a>before</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;    x[i][j] = <span class="hljs-number">2</span> * x[i][j];  &#125;&#125;</code></pre></div><p>x[i][j]访问之后访问x[i+1][j],这中间差了100个数据</p><h4 id="after"><a href="#after" class="headerlink" title="after"></a>after</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;    x[i][j] = <span class="hljs-number">2</span> * x[i][j]  &#125;&#125;</code></pre></div><p>x[i][j]访问之后访问x[i][j+1], 这中间只差了一个数据，就可以按照数据存储的顺序来访问，增强了space locality。</p><p>这样一次miss之后，load多个word进cache的话，缺失就会变少</p><h3 id="B-Blocking-分块"><a href="#B-Blocking-分块" class="headerlink" title="B. Blocking[分块]"></a>B. Blocking[分块]</h3><h4 id="before-1"><a href="#before-1" class="headerlink" title="before"></a>before</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++) &#123;    &#123;      r = <span class="hljs-number">0</span>;      <span class="hljs-comment">//y的行 * z的列</span>      <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; N; k++) &#123;        r = r + y[i][k] * z[k][j]      &#125;    &#125;  &#125;&#125;</code></pre></div><p><img src="image-20191217210134473.png" srcset="/img/loading.gif" alt="image-20191217210134473" style="zoom:50%;" /></p><h4 id="after-1"><a href="#after-1" class="headerlink" title="after"></a>after</h4><p><em>maximize accesses to loaded data before they are replaced</em></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(jj = <span class="hljs-number">0</span>; jj &lt; N; jj = jj + B) &#123;  <span class="hljs-keyword">for</span>(kk = <span class="hljs-number">0</span>; kk &lt; N; kk = kk + B) &#123;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;      <span class="hljs-keyword">for</span>(j = jj; j &lt; min(jj+B, N); j++) &#123;        &#123;          r = <span class="hljs-number">0</span>;          <span class="hljs-keyword">for</span>(k = kk; k &lt; min(kk); k++) &#123;            r = r + y[i][k] * z[k][j];          &#125;          x[i][j] = x[i][j] + r;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre></div><p><img src="image-20191217210322625.png" srcset="/img/loading.gif" alt="image-20191217210322625" style="zoom:50%;" /></p><h2 id="4-9-Hardware-prefetching"><a href="#4-9-Hardware-prefetching" class="headerlink" title="4.9 Hardware prefetching"></a>4.9 Hardware prefetching</h2><p>指令和数据都可以预取，既可以直接放在cache中，也可以放在一个访问速度快于main memory的外部缓冲区中。</p><p>下面来看一下指令预取</p><p>通常，处理器在一次缺失时提取两个块。被请求块和下一个相邻块</p><ul><li>被请求块放在他返回时的指令缓存中</li><li>预取块放在指令流缓冲区中。</li></ul><p>请求时，如果发现被请求块位于指令流缓冲区，那么原缓存请求取消，从流缓冲区来读取这个块。并发出下一条预取请求</p><ul><li>Reduce miss penalty/rate</li></ul><h2 id="4-10-Compiler-Prefetching"><a href="#4-10-Compiler-Prefetching" class="headerlink" title="4.10 Compiler Prefetching"></a>4.10 Compiler Prefetching</h2><p>作为hardware prefetching的替代方法。可以在处理器需要某一数据之前，由编译器插入请求该数据的预取指令</p><p>有以下两种prefetch</p><ul><li><p><strong>Register</strong> <strong>prefetch</strong></p><p>load the value into a register</p></li><li><p><strong>Cache</strong> <strong>prefetch</strong></p><p>load data into the cache</p></li></ul><p><strong>Example</strong></p><p>16-byte blocks;</p><p>8-byte elements for a and b;</p><p>write-back strategy</p><p>a[0][0] miss, copy both a[0][0],a[0][1] as one block contains 16/8 = 2;</p><p><strong><em>before</em></strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i = i + <span class="hljs-number">1</span>)  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j = j + <span class="hljs-number">1</span>)    a[i][j] = b[j][<span class="hljs-number">0</span>] * b[j + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]</code></pre></div><p>缺失次数</p><p>对于a, $3\times(100/2)=150$次缺失</p><p>对于b, b不会从空间局部性受益，但是可以从时间局部性受益</p><p>b从b[0][0]访问到b[100][0]一共有101次缺失</p><p>总共251次缺失</p><p><strong><em>after prefetching</em></strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;  prefetch(b[j+<span class="hljs-number">7</span>][<span class="hljs-number">0</span>]);  prefetch(a[<span class="hljs-number">0</span>][j+<span class="hljs-number">7</span>]);  a[<span class="hljs-number">0</span>][j] = b[j][<span class="hljs-number">0</span>] * b[j+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];&#125;<span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;prefetch(a[i][j+<span class="hljs-number">7</span>]);    a[i][j] = b[j][<span class="hljs-number">0</span>] * b[j+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];  &#125;&#125;</code></pre></div><p>修改后，将会预取a[i][7]—-a[i][99]和b[7][0]—b[100][0]</p><p>所以非预取缺失只会出现在前几个循环</p><ul><li>第一个loop访问b[0][0]—-b[6][0]的7次缺失</li><li>第一个loop访问a[0][0]—a[0][7]的4次缺失</li><li>第二个loop访问a[1][0]—a[1][6]的4次缺失</li><li>第二个loop访问a[2][0]—a[2][6]的4次缺失</li></ul><p>总共有19次非预取缺失</p><p><strong>Reduce</strong> miss penalty/rate</p><h1 id="5-Memory"><a href="#5-Memory" class="headerlink" title="5. Memory"></a>5. Memory</h1><p>Performance Measures</p><ul><li><strong>Latency</strong></li></ul><div class="note note-warning">            <p>the time to retrieve the first word of the block</p>          </div><p> important for caches;</p><p> harder to reduce;</p><blockquote><p><strong>access time</strong>: the time between when a read is requested and when the desired word arrives;</p><p><strong>cycle time</strong>: the minimum time between unrelated requests to memory;</p><p><em>or</em> the minimum time between the start of an access and the start of the next access;</p></blockquote><ul><li><strong>Bandwidth</strong> </li></ul><p>the time to retrieve the rest of this block</p><h2 id="5-1-RAM"><a href="#5-1-RAM" class="headerlink" title="5.1 RAM"></a>5.1 RAM</h2><p><a href="https://www.zhihu.com/question/30492703" target="_blank" rel="noopener">Zhihu Birkee’s answer</a></p><p>RAM，Random-Access Memory，即随机存取存储器，其实就是内存，断电会丢失数据。<br>主要分为SRAM（static）和DRAM（dynamic)。主要的区别在于存储单元，DRAM使用电容电荷进行存储。需要一直刷新充电。SRAM是用锁存器锁住信息，不需要刷新。但也需要充电保持。</p><center><table>  <tr>    <td><div class="card">     <div class="card__image">       <img class="image" src="image-20191209104433202.png" srcset="/img/loading.gif" alt="image-20191209104433202" style="zoom:50%;" />   </div>     <div class="card__content">         <div class="card__header">             <h4>DRAM的基本存储单元</h4>         </div>         <p>利用一个晶体管进行控制电容的充放电</p>    </div></div></td>  <td><div class="card">     <div class="card__image">       <img class="image" src="image-20191209104458720.png" srcset="/img/loading.gif" alt="image-20191209104458720" style="zoom:50%;" />   </div>     <div class="card__content">         <div class="card__header">             <h4>DRAM一般的寻址模式</h4>         </div>         <p>控制的晶体管集成在单个存储单元中</p>    </div> </div></td>  </tr></table></center><h2 id="5-2-SRAM-for-cache-Static-Random-Access-Memory"><a href="#5-2-SRAM-for-cache-Static-Random-Access-Memory" class="headerlink" title="5.2 SRAM for cache[Static Random Access Memory]"></a>5.2 SRAM for cache[Static Random Access Memory]</h2><ul><li><p>Six transistors per bit to prevent the information from being disturbed when read</p></li><li><p>Don’t need to refresh, so access time is very close to cycle time</p></li></ul><h2 id="5-3-DRAM-for-main-memory-Dynamic-Random-Access-Memory"><a href="#5-3-DRAM-for-main-memory-Dynamic-Random-Access-Memory" class="headerlink" title="5.3 DRAM for main memory[Dynamic Random Access Memory]"></a>5.3 DRAM for main memory[Dynamic Random Access Memory]</h2><center><img src="image-20191209105411600.png" srcset="/img/loading.gif" alt="image-20191209105411600" style="zoom:30%;" /></center><center><img src="image-20191209105418930.png" srcset="/img/loading.gif" alt="image-20191209105418930" style="zoom:30%;" /></center><p>bing row into row buffer</p><center><img src="image-20191209105429474.png" srcset="/img/loading.gif" alt="image-20191209105429474" style="zoom:30%;"/></center><p>select Data via Multiplexor</p><center><img src="image-20191209105442259.png" srcset="/img/loading.gif" alt="image-20191209105442259" style="zoom:30%;"/></center><p>Data selected</p><center><img src="image-20191209105451917.png" srcset="/img/loading.gif" alt="image-20191209105451917" style="zoom:30%;"/></center><p>Row buffer hit</p><center><img src="image-20191209105459461.png" srcset="/img/loading.gif" alt="image-20191209105459461" style="zoom:30%;"/></center><p>Row buffer conflict</p><br>## 5.6 提高存储器的可靠性### Error type* **Soft errors**<div class="note note-info">            <p>changes to a cell’s contents, not a change in the circuitry</p>          </div>* **Hard errors**<div class="note note-info">            <p>permanent changes in the operation of one or more memory cells</p>          </div>### Error detection and fix<center><table>  <tr>    <td><div class="card">     <div class="card__content">         <div class="card__header">             <h4>Parity only</h4>         </div>         <p>only one bit of overhead to detect a single error in a sequence of bits;</p>    </div></div></td>  <td><div class="card">      <div class="card__content">         <div class="card__header">             <h4>ECC only</h4>         </div>         <p>detect two errors and correct a single error with 8-bit overhead per 64 data bits</p>    </div> </div></td>    <td><div class="card">      <div class="card__content">         <div class="card__header">             <h4>Chipkill</h4>         </div>         <p>类似于在磁盘中使用RAID方法，它分散数据和ECC信息，在单个存储器芯片完全失效时，可以从其余存储器芯片中重构丢失数据</p>    </div> </div></td>  </tr></table></center><h1 id="6-Disk"><a href="#6-Disk" class="headerlink" title="6. Disk"></a>6. Disk</h1><div class="item">     <div class="item__image">     <img class="image image--lg" src="image-20191209113803942.png" srcset="/img/loading.gif" alt="image-20191209113803942" style="zoom:50%;" />    <img class="image image--lg" src="image-20191209113823956.png" srcset="/img/loading.gif" alt="image-20191209113823956" style="zoom:50%;" />     </div>     <div class="item__content">       <div class="item__header">           <h4>Disk</h4>       </div>       <div class="item__description">         <p>Sector: minimum storage unit. A block may span multiple sectors</p>     <p>Cluster:(dis)contiguous groups of sectors to reduce the overhead of managing on-disk data structures; may span more than one track</p>      </div>     </div> </div><p>Areal density = $\frac{Tracks}{Inch}$ on a disk surface $\times$ $\frac{Bits}{Inch}$ on a track</p><h2 id="6-1-RAID-Redundant-Arrays-of-Inepensive-Disk"><a href="#6-1-RAID-Redundant-Arrays-of-Inepensive-Disk" class="headerlink" title="6.1 RAID[Redundant Arrays of Inepensive Disk]"></a>6.1 RAID[Redundant Arrays of Inepensive Disk]</h2><ul><li>RAID 0: No Redundancy</li><li>RAID 1: Mirroring / Shadowing</li></ul><blockquote><p>Two copies for every piece of data</p><p>one logical write = two physical writes</p><p>100% capacity/space  overhead</p></blockquote><center><img src="IMG_2C62CE9D9D16-1.jpeg" srcset="/img/loading.gif" alt="IMG_2C62CE9D9D16-1" style="zoom:50%;" /></center><ul><li>RAID 2:</li></ul><blockquote><p>Each bit of data word is written to a data disk drive</p><p>Each data word has its (Hamming Code) ECC word recorded on the ECC disks</p><p>On read, the ECC code verifies correct data or corrects single disks errors</p></blockquote><center><img src="image-20191216120558419.png" srcset="/img/loading.gif" alt="image-20191216120558419" style="zoom:50%;" /></center><ul><li>RAID 3:</li></ul><blockquote><p>RAID 3 P校验盘存的是前面所有盘数据的和。</p><p>他很慢，因为每读取一次磁盘数据，校验时要读取其他所有磁盘才能算校验和</p><p>磁盘坏了的话，也可以通过checksum恢复数据</p></blockquote><center><img src="IMG_E9E135911744-1.png" srcset="/img/loading.gif" alt="IMG_E9E135911744-1" style="zoom:50%;" /></center><center><img src="image-20191216121018499.png" srcset="/img/loading.gif" alt="image-20191216121018499" style="zoom:50%;" /></center><ul><li>RAID 4</li></ul><center><img src="IMG_17517EAA2585-1.png" srcset="/img/loading.gif" alt="IMG_17517EAA2585-1" style="zoom: 33%;" /></center><ul><li>RAID 5</li></ul><center><img src="IMG_8BFCBD97FD85-1.png" srcset="/img/loading.gif" alt="IMG_8BFCBD97FD85-1" style="zoom:30%;" /></center><ul><li>RAID 6</li></ul><blockquote><p>row parity</p></blockquote><center><img src="image-20191216130127847.png" srcset="/img/loading.gif" alt="image-20191216130127847" style="zoom:30%;" /></center><blockquote><p>Diagonal parity</p></blockquote><center><img src="image-20191216130657742.png" srcset="/img/loading.gif" alt="image-20191216130657742" style="zoom:30%;" /></center><p>看一个例子</p><p>disk 1和disk 3 double failure</p><center><img src="image-20191216130845614.png" srcset="/img/loading.gif" alt="image-20191216130845614" style="zoom:30%;" /></center><p>First recover Disk 3 stripe 0. Because its diagonal parity is independent from the other failed disk 1.</p><center><img src="image-20191216130921114.png" srcset="/img/loading.gif" alt="image-20191216130921114" style="zoom:30%;" /></center><p>When Disk 3 stripe 0 is recoverd, then we can recover Disk 1 stripe 3. Because on its row, only its stripe is failed. So we can use the row parity to recover the stripe.</p><center><img src="image-20191216130953500.png" srcset="/img/loading.gif" alt="image-20191216130953500" style="zoom:30%;" /></center><p>Now, we have recovered Disk 1 stripe 3 and Disk 3 stripe 0</p><center><img src="image-20191216131127165.png" srcset="/img/loading.gif" alt="image-20191216131127165" style="zoom:30%;" /></center><p>以下同理</p><center><img src="image-20191216131242663.png" srcset="/img/loading.gif" alt="image-20191216131242663" style="zoom:30%;" /></center><center><img src="image-20191216131302430.png" srcset="/img/loading.gif" alt="image-20191216131302430" style="zoom:30%;" /></center><center><img src="image-20191216131334869.png" srcset="/img/loading.gif" alt="image-20191216131334869" style="zoom:30%;" /></center><center><img src="image-20191216131357343.png" srcset="/img/loading.gif" alt="image-20191216131357343" style="zoom:30%;" /></center><center><img src="image-20191216131420435.png" srcset="/img/loading.gif" alt="image-20191216131420435" style="zoom:30%;" /></center><center><img src="image-20191216131449208.png" srcset="/img/loading.gif" alt="image-20191216131449208" style="zoom:30%;" /></center><center><img src="image-20191216131514362.png" srcset="/img/loading.gif" alt="image-20191216131514362" style="zoom:30%;" /></center><center><img src="image-20191216131536642.png" srcset="/img/loading.gif" alt="image-20191216131536642" style="zoom:30%;" /></center><center><img src="image-20191216131556362.png" srcset="/img/loading.gif" alt="image-20191216131556362" style="zoom:30%;" /></center><h1 id="7-I-O-performance"><a href="#7-I-O-performance" class="headerlink" title="7. I/O performance"></a>7. I/O performance</h1><h3 id="unique-measures"><a href="#unique-measures" class="headerlink" title="unique measures"></a>unique measures</h3><ul><li>Diversity</li></ul><blockquote><p>which I/O devices can connect to the computer system?</p></blockquote><ul><li>Capacity</li></ul><blockquote><p>how many I/O devices can connect to a computer system?</p></blockquote><h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><ul><li><p>response time[latency]</p></li><li><p>throughout[bandwidth]</p></li></ul><center><img src="image-20191216102829183.png" srcset="/img/loading.gif" alt="image-20191216102829183" style="zoom:50%;" /></center><h2 id="7-1-Throughout-VS-Response-Time"><a href="#7-1-Throughout-VS-Response-Time" class="headerlink" title="7.1 Throughout VS Response Time"></a>7.1 Throughout VS Response Time</h2><p><strong><em>Transaction</em></strong></p><blockquote><p>An interation between human and computer is called <strong><em><u>transaction</u></em></strong></p></blockquote><p>A <strong><em><u>transaction time</u></em></strong> is divided into three parts:</p><blockquote><ul><li><u>entry time</u></li></ul><blockquote><p>The time for user to enter the command</p></blockquote><ul><li><u>system response time</u></li></ul><blockquote><p>The time between when the user enters the command and the complete response is displayed</p></blockquote><ul><li><u>think time</u></li></ul><blockquote><p>The time from the reception of the response until the user begins to <strong><em><u>enter the next command</u></em></strong></p></blockquote></blockquote><center><img src="image-20191216210721189.png" srcset="/img/loading.gif" alt="image-20191216210721189" style="zoom:40%;" /></center><center><img src="image-20191216210659441.png" srcset="/img/loading.gif" alt="image-20191216210659441" style="zoom:50%;" /></center><p>More transaction time reduction than just the response time reduction. People need less time to think when given a faster response</p><h2 id="7-2-Transaction-Processing-Benchmarks"><a href="#7-2-Transaction-Processing-Benchmarks" class="headerlink" title="7.2 Transaction-Processing Benchmarks"></a>7.2 Transaction-Processing Benchmarks</h2><h3 id="A-SPEC"><a href="#A-SPEC" class="headerlink" title="A. SPEC"></a>A. SPEC</h3><h3 id="B-TPC-C"><a href="#B-TPC-C" class="headerlink" title="B. TPC_C"></a>B. TPC_C</h3><h2 id="7-3-A-little-Queuing-Theory-to-calculate-response-time-and-throughput"><a href="#7-3-A-little-Queuing-Theory-to-calculate-response-time-and-throughput" class="headerlink" title="7.3 A little Queuing Theory[to calculate response time and throughput]"></a>7.3 A little Queuing Theory[to calculate response time and throughput]</h2><center><img src="image-20191216104938324.png" srcset="/img/loading.gif" alt="image-20191216104938324" style="zoom:50%;" /></center><p><strong><em>Flow-balanced State</em></strong></p><ul><li><p>If the system is in <strong>steady state</strong>,  then the number of tasks entering the system must equal the number of tasks leaving the system</p></li><li><p>This <strong>flow-balanced state</strong> is necessary but not sufficient for steady state</p></li><li><p>The system has reached <strong>steady state</strong> if the system has been observed for a sufficiently long time and  mean waiting times stabilize</p></li></ul><h3 id="A-little’s-law-important"><a href="#A-little’s-law-important" class="headerlink" title="A. little’s law[important]"></a>A. little’s law[important]</h3><h4 id="i-Assumptions"><a href="#i-Assumptions" class="headerlink" title="i. Assumptions"></a>i. Assumptions</h4><div class="note note-info">            <p>input rate = output rate; </p><p>a steady supply of tasks independent for how long they wait for service;</p>          </div><h4 id="ii-little’s-law"><a href="#ii-little’s-law" class="headerlink" title="ii. little’s law"></a>ii. little’s law</h4><div class="note note-error">            <p>Mean number of tasks in system =  Arrival rate $\times$ Mean response time</p><p>注意arrival rate 表示单位时间到了几个task</p>          </div><h4 id="iii-single-server-model"><a href="#iii-single-server-model" class="headerlink" title="iii. single-server model"></a>iii. single-server model</h4><center><img src="image-20191216214128113.png" srcset="/img/loading.gif" alt="image-20191216214128113" style="zoom: 40%;" /></center><ul><li>$Time_{server}$  —Average time to service a task; average  $service_{rate}=1/Time_{server}$</li><li>$Time_{queue}$—Average time per task in the queue.</li><li>$Time_{system}$ —Average time per task in the system, or the response time, which is $Time_{queue}+Time_{server}$ .</li><li>Arrival rate—Average number of arriving tasks/second</li><li>$Length_{server}$—Average number of tasks in service.</li><li>$Length_{queue}$—Average length of queue.</li><li>$Length_{system}$—Average number of tasks in system, which is $Length_{server}+Length_{queue}$</li></ul><p><strong><em>Server Utilization</em></strong></p><div class="note note-info">            <p>Server utilization = Arrival rate$\times$ $Time_{server}$</p>          </div><center><img src="image-20191216110406290.png" srcset="/img/loading.gif" alt="image-20191216110406290" style="zoom:50%;" /></center><p><br/></p><p><strong><em>Time queue</em></strong></p><p>$Time_{queue}=Length_{queue}\times Time_{server}+$Mean time to complete the task being serviced when new task arrives if server is busy</p><p>$Time_{queue}=Time_{server}\times \frac{Server\;utilization}{1-Server\; utilization}$</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}Length_{queue}=&Arrival\; rate\times Time_{server}\times\frac{Server\;utilization}{1-Server\; utilization}\\ =&\frac{Server\; utilization^2}{1-Server\; utilization}\end{aligned}\end{equation}</script><h4 id="iv-M-M-1-queue"><a href="#iv-M-M-1-queue" class="headerlink" title="iv. M/M/1 queue"></a>iv. M/M/1 queue</h4><blockquote><p><strong>M</strong>: <em>Markov</em></p><p>exponentially random request arrival;</p><p><strong>M</strong>: <em>Markov</em></p><p>exponentially random service time</p><p><strong>1</strong></p><p>single server</p></blockquote><p><strong>assumptions</strong></p><blockquote><p>The system is in equilibrium</p><p><em>Interarrival</em> <em>times</em> [times between two successive requests arriving] are exponentionally distributed</p><p><em>Infinite population model</em>: unlimited number of sources of requests</p><p>Server starts on the next job immediately after finishing prior one</p><p>FIFO queue with unlimited length</p><p>One server only</p></blockquote><center><img src="image-20191216222544839.png" srcset="/img/loading.gif" alt="image-20191216222544839" style="zoom:50%;" /></center><center><img src="image-20191216222600418.png" srcset="/img/loading.gif" alt="image-20191216222600418" style="zoom:50%;" /></center><center><img src="image-20191216222618484.png" srcset="/img/loading.gif" alt="image-20191216222618484" style="zoom:50%;" /></center><h4 id="v-M-M-m-queue"><a href="#v-M-M-m-queue" class="headerlink" title="v. M/M/m queue"></a>v. M/M/m queue</h4><center><img src="image-20191216222740597.png" srcset="/img/loading.gif" alt="image-20191216222740597" style="zoom:50%;" /></center><center><img src="image-20191216222905001.png" srcset="/img/loading.gif" alt="image-20191216222905001" style="zoom:40%;" /></center>]]></content>
    
    
    <categories>
      
      <category>Computer Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer network--网络层part2</title>
    <link href="/2019/12/06/ComputerNetwork/NetworkLayer2/"/>
    <url>/2019/12/06/ComputerNetwork/NetworkLayer2/</url>
    
    <content type="html"><![CDATA[<h1 id="3-拥塞控制算法"><a href="#3-拥塞控制算法" class="headerlink" title="3. 拥塞控制算法"></a>3. 拥塞控制算法</h1><h3 id="i-什么是拥塞-congestion"><a href="#i-什么是拥塞-congestion" class="headerlink" title="i. 什么是拥塞[congestion]"></a>i. 什么是拥塞[congestion]</h3><div class="note note-warning">            <p>网络中存在太多的数据包导致数据包被延迟延迟和丢失，从而降低了传输性能，这种情况称为拥塞</p>          </div><p>网络层和传输层共同承担着处理拥塞的责任。</p><ul><li><p>由于拥塞发生在网络内，正是网络层直接经历着拥塞，而且必须由它最终确定如何处理过载的数据包。</p></li><li><p>然而，控制拥塞的最有效方法是减少传输层注入网络的负载。这就需要网络层和传输层共同努力协同工作。</p></li></ul><h3 id="ii-拥塞的影响"><a href="#ii-拥塞的影响" class="headerlink" title="ii. 拥塞的影响"></a>ii. 拥塞的影响</h3><center><img src="image-20191202212045404.png" srcset="/img/loading.gif" alt="image-20191202212045404" style="zoom:30%;" /></center><ul><li>当主机发送到网络的数据包数量在其承载能力范围之内时， 送达的数据包数与发送的数据包数成正比例增长</li><li>然而，随着负载接近承载能力，偶尔突发的流量填满了路由器内部的缓冲区，因而某些数据包会被丢失。这些丢失的数据包消耗了部分容量，因此，送达的数据包数量低于理想曲线。网络现在开始拥塞。</li></ul><ul><li>除非网络是精心设计的，否则它极有可能会遭遇拥塞崩溃 [Ccongestion collapse ]，表现为随着注入负载的增加到超出网络的容量，网络性能骤降。</li></ul><p><br/></p><p>拥塞控制和流量控制</p><blockquote><ul><li>拥塞控制的任务是确保网络能够承载所有到达的流量。这是一个全局性的问题，涉及各方面的行为，包括所有的主机和所有的路由器。</li><li>与此相反，流量控制只与特定的发送方和特定的接收方之间的点到点流量有关。它的任务是确保一个快速的发送方不会持续地以超过接收方接收能力的速率传输数据。</li></ul></blockquote><p><br/></p><h2 id="3-1-拥塞控制的途径"><a href="#3-1-拥塞控制的途径" class="headerlink" title="3.1 拥塞控制的途径"></a>3.1 拥塞控制的途径</h2><p>拥塞的出现意味着负载（暂时）大于资源（在网络的一部分〉可以处理的能力。</p><p>很自然能想到两个解决方案</p><ul><li>增加资源</li><li>减少负载。</li></ul><center><img src="image-20191202215504805.png" srcset="/img/loading.gif" alt="image-20191202215504805" style="zoom: 33%;" /></center><h2 id="3-2-流量感知路由-traffic-aware-routing"><a href="#3-2-流量感知路由-traffic-aware-routing" class="headerlink" title="3.2 流量感知路由[traffic-aware routing]"></a>3.2 流量感知路由[traffic-aware routing]</h2><p>把链路权重设置成一个（固定）链路带宽、传输延迟、（可变）测量负载或平均排队延迟的函数。在所有其他条件都相同的情况下，最小权重的路径更青睐那些<strong><em>轻负载</em></strong>的路径。</p><p><br/></p><h2 id="3-3-准入控制-admission-control"><a href="#3-3-准入控制-admission-control" class="headerlink" title="3.3 准入控制[admission control]"></a>3.3 准入控制[admission control]</h2><p>一种广泛应用于虚电路网络，防止出现拥塞的技术是准入控制（ admission control ）</p><p>思想：</p><div class="note note-warning">            <p>除非网络可以携带额外的流量而不会变得拥塞，否则不再建立新的虚电路。因此，任何建立新的虚电路的尝试或许会失败。</p>          </div><p>常用：<u>leaky bucket</u> or <u>token bucket</u></p><h2 id="3-4-流量调节-traffic-throttling"><a href="#3-4-流量调节-traffic-throttling" class="headerlink" title="3.4 流量调节[traffic throttling]"></a>3.4 流量调节[traffic throttling]</h2><p>在 Internet 和许多其他计算机网络中，发送方调整它们的传输速度以便发送网络能实际传送的流量。在这种设置下，网络的目标是在拥塞发生之前正常工作。</p><p>而当拥塞迫在眉睫，它必须告诉发送方紧急刹车放慢传输速度。这种反馈是一种常态而不是针对特殊情况的一种处理。</p><p><br/></p><h3 id="限制流量的方法"><a href="#限制流量的方法" class="headerlink" title="限制流量的方法"></a>限制流量的方法</h3><p>要解决两个问题：</p><h4 id="1-路由器必须确定何时快要接近拥塞，最好在拥塞发生之前能确定-排队时延"><a href="#1-路由器必须确定何时快要接近拥塞，最好在拥塞发生之前能确定-排队时延" class="headerlink" title="1. 路由器必须确定何时快要接近拥塞，最好在拥塞发生之前能确定[排队时延]"></a>1. 路由器必须确定何时快要接近拥塞，最好在拥塞发生之前能确定[排队时延]</h4><blockquote><p>解决方法：每个路由器连续监测它正在使用的资源。可以输出在路由器内缓冲的排队数据包。路由器内部的排队延迟直接捕获了数据包经历过的任何拥塞情况</p><p>为了维持良好的排队延迟估计d, 假设s表示瞬时队列长度的样值, d可以定期生成，按如下方式更新，其中$\alpha$是一个参数，加权移动平均</p><script type="math/tex; mode=display">d_{new}=\alpha d_{old}+(1-\alpha)s</script><p>如果d升高到某一个阈值之上，则路由器就要开始注意拥堵了</p></blockquote><h4 id="2-路由器必须及时把反馈消息传递给造成拥塞的发送方"><a href="#2-路由器必须及时把反馈消息传递给造成拥塞的发送方" class="headerlink" title="2. 路由器必须及时把反馈消息传递给造成拥塞的发送方"></a>2. 路由器必须及时把反馈消息传递给造成拥塞的发送方</h4><p><strong>2.A 抑制包</strong></p><blockquote><ul><li>路由器选择一个被拥塞的数据包，给该数据包的源主机返回一个抑制包（choke packet ）。</li></ul><p>抑制包中的<strong><em><u>目标地址</u></em></strong>取自该拥塞数据包。同时，在原来的拥塞数据包上添加一个<strong><em><u>标记</u></em></strong>（设置头部中的一位），因而它在前行的路径上不会产生更多的抑制包。</p><ul><li><p>数据包的转发过程如同平常 一样。 </p></li><li><p>当源主机收到了抑制包，按照要求它必须减少发送给指定目标的流量，比如说减少 50% 。</p></li></ul><p>在数据报网络中，发生拥塞时路由器简单地随机选择一个数据包，很有可能就把抑 制包发给了快速发送方，因为发送方的速度越快，它的数据包排队在路由器队列中的数目就越多。</p></blockquote><center><img src="image-20191205230214522.png" srcset="/img/loading.gif" alt="image-20191205230214522" style="zoom:50%;" /></center><p><strong>2.B 逐跳后压[hop-by-hop choke packets]</strong></p><p>因为传播延迟的影响，拥塞信号发出到起作用之间已经有很多新的数据包注入了网络。</p><p>因此，可以让抑制包在沿途的每一跳都发挥作用</p><center><img src="image-20191205232440838.png" srcset="/img/loading.gif" alt="image-20191205232440838" style="zoom:50%;" /></center><p><strong>2.C Explicit Congestion Notification [ECN]</strong></p><blockquote><ul><li><p>路由器可以在它转发的任何数据包上打上标记[设置数据包头的某一个标志位]发出信号，表明它正在经历着拥塞。</p></li><li><p>当网络传递数据包时， 接收方可以注意到有个拥塞己经发生，在它发送应答包时顺便告知发送方。</p></li><li><p>然后发送方可以像以前那样紧急刹车降低传输速率。</p></li></ul></blockquote><center><img src="image-20191205231809305.png" srcset="/img/loading.gif" alt="image-20191205231809305" style="zoom:50%;" /></center><p><br/></p><h2 id="3-5-负载脱落-load-shedding"><a href="#3-5-负载脱落-load-shedding" class="headerlink" title="3.5 负载脱落[load shedding]"></a>3.5 负载脱落[load shedding]</h2><p>当路由器因为来不及处理数据包而面临被这些数据包淹没的危险时，就将它们丢弃。</p><p>关键问题：选择丢弃哪个数据包</p><ul><li>旧的比新的好，丢新包[wine策略]</li><li>新的比旧的好[milk 策略]</li></ul><h3 id="随机早期检测-random-early-detection"><a href="#随机早期检测-random-early-detection" class="headerlink" title="随机早期检测[random early detection]"></a>随机早期检测[random early detection]</h3><p>为什么早期：</p><blockquote><p>在拥塞刚出现苗头时就处理它比等拥塞形成之后再设法解决它更加有效，即在所有的缓冲空间都精疲力竭之前丢弃数据包。</p></blockquote><p>为什么随机:</p><blockquote><p>随机选择丢弃的数据包使得快速发送方发现丢包的可能性更大。发送方没有收到期待的确认信息时，就会认为丢包了，然后传输协议将放慢速度。因此，丢失的数据包起到了传递抑制包的同样作用</p></blockquote><p><br/></p><h1 id="4-服务质量-QUALITY-OF-SERVICE"><a href="#4-服务质量-QUALITY-OF-SERVICE" class="headerlink" title="4. 服务质量[QUALITY OF SERVICE ]"></a>4. 服务质量[QUALITY OF SERVICE ]</h1><p>A flow is a stream of packets from a source to a destination.</p><p>The needs of each flow can be characterized by fourprimary parameters:</p><ul><li><p>Reliability(可靠性)</p></li><li><p>延迟(Delay)</p></li><li><p>抖动(Jitter)</p></li><li><p>带宽(Bandwidth)</p></li></ul><h2 id="4-1-应用需求"><a href="#4-1-应用需求" class="headerlink" title="4.1 应用需求"></a>4.1 应用需求</h2><center><img src="image-20191205233904014.png" srcset="/img/loading.gif" alt="image-20191205233904014" style="zoom:30%;" /></center><h2 id="4-2-流量整形-traffic-shaping"><a href="#4-2-流量整形-traffic-shaping" class="headerlink" title="4.2 流量整形[traffic shaping]"></a>4.2 流量整形[traffic shaping]</h2><center><img src="image-20191206000433623.png" srcset="/img/loading.gif" alt="image-20191206000433623" style="zoom:50%;" /></center><h1 id="5-INTERNETWORKING-网络互连"><a href="#5-INTERNETWORKING-网络互连" class="headerlink" title="5. INTERNETWORKING [网络互连]"></a>5. INTERNETWORKING [网络互连]</h1><h2 id="5-1-How-networks-differ"><a href="#5-1-How-networks-differ" class="headerlink" title="5.1 How networks differ"></a>5.1 How networks differ</h2><center><img src="image-20191224232122964.png" srcset="/img/loading.gif" alt="image-20191224232122964" style="zoom:40%;" /></center><h2 id="5-2-How-networks-can-be-connected"><a href="#5-2-How-networks-can-be-connected" class="headerlink" title="5.2 How networks can be connected"></a>5.2 How networks can be connected</h2><p>多协议路由器[multiprotocol router]</p><center><img src="image-20191224232335024.png" srcset="/img/loading.gif" alt="image-20191224232335024" style="zoom:40%;" /></center><h2 id="5-3-Tunneling"><a href="#5-3-Tunneling" class="headerlink" title="5.3 Tunneling"></a>5.3 Tunneling</h2><p>处理两个不同网络相互连接时的一般情况超级困难。然而，却存在一种最常见的甚至可管理不同网络协议的情形。</p><blockquote><p>这种情形就是源主机和目标主机所在网络的类型完全相同， 但它们中间却隔着一个不同类型的网络。举例来说，请考虑一家跨国银行，它在巴黎有一 个IPv6 网，在伦敦也有一个 IPv6 网, 但是连接巴黎和伦敦办事处的却是 IPv4 Internet</p></blockquote><p>可以用tunneling来解决这个问题。</p><ul><li>为了给伦敦办事处的主机发送一个 IP 数据包，巴黎的主机构造一个包含伦敦 IPv6 地址的数据包</li><li>然后将该数据包发送到连接巴黎 IPv6 网络到 IPv4 Internet 上的多协议路由器</li><li>当该多协议路由器获得 IPv6数据包后，它把该数据包用一个 IPv4 头封装，封装后的 IPv4 数据包指向多协议路由器另 一边的 IPv4，该网络与伦敦的 IPv6网络相连：也就是说，路由器将一个IPv6数据包放 入到一个IPv4数据包中。</li><li>当这个包裹着的数据包到达伦敦路由器，原来的 IPv6 数据包 被提取出来，并被发送给最终的目标主机。</li></ul><div class="note note-success">            <p>可以把通过 IPv4 Internet 的路径看作是一根从一个多协议路由器延伸到另一个多协议路由器的大隧道。</p>          </div><center><img src="image-20191224232619688.png" srcset="/img/loading.gif" alt="image-20191224232619688" style="zoom:40%;" /></center><h2 id="5-4-Internetwork-Routing"><a href="#5-4-Internetwork-Routing" class="headerlink" title="5.4 Internetwork Routing"></a>5.4 Internetwork Routing</h2><h3 id="AS-Autonamous-System"><a href="#AS-Autonamous-System" class="headerlink" title="AS[Autonamous System]"></a>AS[Autonamous System]</h3><blockquote><p>each network is operated independently of all the others, it is often referred to as an AS (Autonomous System).</p></blockquote><p>Use Two-level routing</p><ul><li>Internet(inter-AS) routing: Exterior gateway protocol, like BGP</li><li>Intranet(intra-AS) routing: Interior gateway protocol, like LS, DV</li></ul><h2 id="5-5-Internetworking-Fragmentation"><a href="#5-5-Internetworking-Fragmentation" class="headerlink" title="5.5 Internetworking: Fragmentation"></a>5.5 Internetworking: Fragmentation</h2><p>每个网络或链路都会限制其数据包的最大长度。主机一般倾向于传输大的数据包，因为这样可以降低开销，比如浪费在头字节上的带宽。当一个大数据包要穿过一个最大数据包尺寸太小的网络时，一个明显的网络互联问题就出现了。</p><p>MTU[path Maximum Transmission Unit]</p><blockquote><p>到达接收方可以发送的最大数据包尺寸</p></blockquote><p>可以对数据包进行分段来解决这个问题，有两种分段策略</p><h3 id="A-transparent"><a href="#A-transparent" class="headerlink" title="A. transparent"></a>A. transparent</h3><blockquote><p>由“小数据 包”网络引起的分段过程对于沿途后续的网络都是透明的，也就是说，从该网络一直到最终的目标途中的每个网络都感觉不到曾经发生过分段</p></blockquote><p>一些问题</p><ul><li>出口路由器必须知道什么时候它己经接收到了全部的段，所以每个分段中必须提供一个计数字段或者一个“数据包结束”标志位。</li><li>由于所有的数据包必须经过同一个出口路由器才能进行重组，因此路由受到了限制。由于不允许有些段沿着一条路径到达最终目标，而另一些段沿着一条不相交路径到达最终目标，所以，可能会损失一些性能。</li><li>路由器可能不得不做大量的工作。如果不是所有的段都己到达，它还需要缓冲到达的段，并且决定何时丢弃这些段。</li></ul><center><img src="image-20191224233917684.png" srcset="/img/loading.gif" alt="image-20191224233917684" style="zoom:40%;" /></center><h3 id="B-nontransparent"><a href="#B-nontransparent" class="headerlink" title="B. nontransparent"></a>B. nontransparent</h3><p><code>优点</code></p><p>是路由器做的工作比较少</p><p>IP采用的是非透明方式。</p><blockquote><p>给每个段一个数据包序号(所有的数据包都携带), 一个数据包内的绝对字节偏移量和一个指明是否到达数据包末尾的标志位</p></blockquote><center><img src="image-20191224234335972.png" srcset="/img/loading.gif" alt="image-20191224234335972" style="zoom:40%;" /></center><p><strong><em>path MTU discovery</em></strong></p><p>这样还是会存在问题。但真正的问题首先还是因为段的存在，因此开销可能比透明分段高。因为除了增加头开销，数据包的丢失概率也增加了。</p><p>我们要提供在网络中避免分段操作的方式。</p><blockquote><p>每个 IP 数据包发出时在它的头设置一个比特，指示不允许对该数据包实施分段操作。</p><p>如果一个路由器接收的数据包太大，它就生成一个报错数据包并发送给源端，然后丢弃该数据包</p><p>当源端收到报错数据包，它就使用报错数据包携带的信息重新将出错数据包分段，每个段足够小到报错路由器能处理。</p><p>如果沿着路径前进又遇到一个MTU更小的路由器，那么重复上述过程。</p></blockquote><center><img src="image-20191224234604657.png" srcset="/img/loading.gif" alt="image-20191224234604657" style="zoom:50%;" /></center><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><h2 id="6-1-IPv4协议"><a href="#6-1-IPv4协议" class="headerlink" title="6.1 IPv4协议"></a>6.1 IPv4协议</h2><p>IP数据包包含：</p><ul><li>一个头[20bytes的定长部分和可选的变长部分组成]</li><li>一个正文</li></ul><center><img src="image-20191126085207750.png" srcset="/img/loading.gif" alt="image-20191126085207750" style="zoom:50%;" /></center><ul><li><p>version: 数据报属于协议的哪个版本, IPv4该字段总是4</p></li><li><p>IHL[internet header length]: 由于头的长度不固定，IHL字段指明头到底有多长，以32bits长度为单位。</p><p>IHL的最小值为5，5words=160bits=20bytes, 这表明头没有options字段。</p><p>IHL的最大值为15</p></li><li><p>Differentiated services: </p><ul><li><strong>Type of service</strong> (past): 3 for priority, 3 for Delay, Throughput, and Reliability, and 2 unused. </li><li><strong>Differentiated services</strong> (now): 6 for service class, 2 for congestion (e.g. ECN). </li></ul></li><li><p>Total length: the length of header and data. 以bytes为单位 最大值为65535bytes</p></li><li><p>Identification: 让目标主机确定一个新到达的分段<strong><em>属于哪一个数据报</em></strong>。同一个数据报的所有段包含同样的表示值</p></li><li><p>灰色的部分是一个未使用的位</p></li><li><p>DF： Don’t fragment，不分段标志位 。只有当 DF = 0 时才允许分片  </p></li><li><p>MF：more fragment。除了最后一个段，其他段都必须设置这一位。MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片</p></li><li><p>Fragment: 指明该段在数据报中的位置。除了数据包的最后一个段，其他所有段的长度必须是8bytes的倍数。这个值是该段第一个比特在未分段的数据中所处的位置/8</p></li><li><p>Time to live: 限制数据报生存期的计数器。计数单位被设置为秒。在每一跳上该计数器必须被递减。实际上是<strong><em>跳计数器</em></strong>，当他递减到0时，数据报就被丢弃。</p></li><li><p>Protocol: 指明该将它交给哪个传输进程[TCP UDP …]</p></li><li><p>Header checksum: </p></li><li><p>Source address: 源IP地址</p></li><li><p>Destination address： 目标IP地址</p></li><li><p>options</p></li></ul><center><img src="image-20191126090914574.png" srcset="/img/loading.gif" alt="image-20191126090914574" style="zoom:50%;" /></center><p><a href="https://blog.csdn.net/ztguang/article/details/70949781" target="_blank" rel="noopener">OSPF protocol</a></p><h3 id="数据包分段"><a href="#数据包分段" class="headerlink" title="数据包分段"></a>数据包分段</h3><p>注意除了数据包的最后一个段，其他所有段的长度必须是8bytes的倍数</p><center><img src="image-20191225002643293.png" srcset="/img/loading.gif" alt="image-20191225002643293" style="zoom:50%;" /></center><ul><li><p>先找total length字段，知道数据包header+data的byte数</p></li><li><p>再找IHL, 知道header的word数</p></li><li><p>total-length得到data.</p></li><li><p>一个数据包最多发送max byte, 用max - IHL就是一个数据包可以发送的data大小</p><ul><li>如果不是最后一个fragment的话，需要减去一些大小，使得发送的数据是8bytes的倍数</li><li>如果不是最后一个分段，无所谓</li></ul></li><li>设置DF=0, MF=1[如果不是最后一个fragment], offset用上述方法计算</li></ul><h2 id="6-2-IP地址"><a href="#6-2-IP地址" class="headerlink" title="6.2 IP地址"></a>6.2 IP地址</h2><p>一个IP地址并不真正指向一台主机，而是指向一个网络接口，所以如果一台主机在两个网络上，它必须有两个IP地址。然而大多数主机都连在一个网络，因而只有一个IP地址。</p><p>路由器有多个接口，从而有多个IP地址</p><h3 id="A-前缀"><a href="#A-前缀" class="headerlink" title="A.前缀"></a>A.前缀</h3><p>IP地址具有层次性，可以将IP地址分成两部分</p><ul><li>高位可变长网络</li><li>低位的主机</li></ul><center><img src="image-20191126091437663.png" srcset="/img/loading.gif" alt="image-20191126091437663" style="zoom:50%;" /></center><p><strong>子网掩码</strong>可以与一个IP地址进行AND操作，提取出IP地址的network部分</p><p>如上图，子网掩码为255.255.255.0</p><h3 id="B-子网"><a href="#B-子网" class="headerlink" title="B.子网"></a>B.子网</h3><center><img src="image-20191126091938551.png" srcset="/img/loading.gif" alt="image-20191126091938551" style="zoom:50%;" /></center><h3 id="C-CIDR-无类域间路由"><a href="#C-CIDR-无类域间路由" class="headerlink" title="C. CIDR 无类域间路由"></a>C. CIDR 无类域间路由</h3><center><img src="image-20191126113616524.png" srcset="/img/loading.gif" alt="image-20191126113616524" style="zoom: 33%;" /></center><p>Question:</p><center><img src="image-20191126113649618.png" srcset="/img/loading.gif" alt="image-20191126113649618" style="zoom: 33%;" /></center><p><strong><em>对于A:</em></strong></p><center><img src="image-20191126114956080.png" srcset="/img/loading.gif" alt="image-20191126114956080" style="zoom:50%;" /></center><p>因为需要1024个地址，所以host有10位，子网掩码是22位</p><p>202.101.0.0/22</p><p><strong><em>对于B:</em></strong></p><center><img src="image-20191126115309939.png" srcset="/img/loading.gif" alt="image-20191126115309939" style="zoom:50%;" /></center><p>host有11位，子网掩码是21位</p><p>202.101.8.0/21</p><p><strong><em>对于C:</em></strong></p><center><img src="image-20191126115323260.png" srcset="/img/loading.gif" alt="image-20191126115323260" style="zoom:50%;" /></center><p>host有11位，子网掩码是21位</p><p>202.101.16.0/21</p><h3 id="E-NAT"><a href="#E-NAT" class="headerlink" title="E. NAT"></a>E. NAT</h3><p>处理IPv4地址短缺的问题。</p><blockquote><p>NAT 的基本思想是 ISP 为每个家庭或每个公司分配一个IP地址，用这个 IP 地址来传输Internet 流量。在客户网络内部，每台计算机有唯一的IP 地址，该地址主要用来路由内部流量。然而，当一个数据包需要离开客户网络，发向其他 ISP 时，它必须执行一个地址转换，把唯一的内部 IP 地址转换成那个共享的公共 IP 地址。这种地址转换使用了 IP 地址的三个范围，这些地址己经被声明为私有化。任何网络可以在内部随意地使用这些地址。仅有的规则是不允许包含这些地址的数据包出现在 Internet 上。这 3 个保留的地址范围为：</p><p>10.0.0.0~ 10.255.255.255/8 (16 777216 个主机）</p><p>172.16.0.0 ~ 172.31.255.255/12 ( 1048576 个主机〉</p><p>192.168.0.0~ 192.168.255.255/16 (65536 个主机〉</p></blockquote><center><img src="image-20191227230836370.png" srcset="/img/loading.gif" alt="image-20191227230836370" style="zoom:35%;" /></center><h2 id="6-4-IPv6-Protocol"><a href="#6-4-IPv6-Protocol" class="headerlink" title="6.4 IPv6 Protocol"></a>6.4 IPv6 Protocol</h2><p>IPv6协议采用128位地址，基本在未来任何时间都不可能出现地址短缺问题</p><h3 id="主要的IPv6头-40bytes"><a href="#主要的IPv6头-40bytes" class="headerlink" title="主要的IPv6头[40bytes]"></a>主要的IPv6头[40bytes]</h3><center><img src="image-20191126120754968.png" srcset="/img/loading.gif" alt="image-20191126120754968" style="zoom: 40%;" /></center><ul><li><p>version: 对于IPv6,总是6</p></li><li><p>Differentiated services: 区分数据包的服务类别</p></li><li><p>Flow label: 为源端和接收方提供了一种建立伪连接的方式，即源端和接收方把一组具有同样需求并希望得到网络同等对待的数据报打上标记。</p></li><li>payload length: 数据的字节数，这里是不包括头的，和IPv4不一样</li><li>Next header: 指明当前头后还有哪种扩展头。如果当前的头是最后一个IP头，那么下一个头字段指定了该数据报将被传递给哪个传输协议处理(TCP, UDP)</li><li><p>Hop limit: 跳数限制，相当于IPv4的TTL</p></li><li><p>entension</p></li></ul><p>IPv6地址的书写</p><p><strong>8</strong> groups of <strong>4</strong> hexadecimal digits with colons between the groups</p><p>e.g. 8000:0000:0000:0000:0123:4567:89AB:CDEF</p><p>优化</p><ol><li><p>leading zeros within a group can be omitted</p><p>0123可以写作123</p></li><li><p>one or more groups of 16 zero bits can be replaced by a pair of colons</p><p>8000::123:4567:89AB:CDEF</p></li><li><p>IPv4 addresses can be written as a pair of colons and an old dotted decimal number</p><p>::192.31.20.46</p></li></ol><h2 id="6-4-Internet控制协议"><a href="#6-4-Internet控制协议" class="headerlink" title="6.4 Internet控制协议"></a>6.4 Internet控制协议</h2><h3 id="ICMP—-Internet-Control-Message-Protocol"><a href="#ICMP—-Internet-Control-Message-Protocol" class="headerlink" title="ICMP—-Internet Control Message Protocol"></a>ICMP—-Internet Control Message Protocol</h3><p>当路由器在处理一个数据包的过程中发生了意外，可以用过ICMP向数据包的源端报告有关事件</p><p>ICMP还可以用来测试Internet</p><center><img src="image-20191129174803743.png" srcset="/img/loading.gif" alt="image-20191129174803743" style="zoom:50%;" /></center><h3 id="ARP—-The-address-resolution-protocol"><a href="#ARP—-The-address-resolution-protocol" class="headerlink" title="ARP—-The address resolution protocol"></a>ARP—-The address resolution protocol</h3><center><img src="image-20191227233627543.png" srcset="/img/loading.gif" alt="image-20191227233627543" style="zoom:50%;" /></center><p>作用是：将IP地址解析为MAC地址</p><p>为什么同时需要IP地址和MAC地址呢？</p><p><a href="https://www.jianshu.com/p/0ce15c07b294" target="_blank" rel="noopener">IP/MAC address</a></p><p>ip地址负责标记发送方和接收方，MAC地址负责传输过程中的分段传送，比如下一跳的MAC地址。</p><p><a href="https://blog.csdn.net/u010164190/article/details/79446575" target="_blank" rel="noopener">ARP详解</a></p><p><a href="https://blog.csdn.net/lm409/article/details/80299823" target="_blank" rel="noopener">ARP详解2</a></p><h3 id="DHCP—-Dynamic-Host-Configuration-Protocol"><a href="#DHCP—-Dynamic-Host-Configuration-Protocol" class="headerlink" title="DHCP—-Dynamic Host Configuration Protocol"></a>DHCP—-Dynamic Host Configuration Protocol</h3><p>动态获取IP地址</p><p><a href="https://blog.csdn.net/wuruixn/article/details/8282554" target="_blank" rel="noopener">DHCP协议的工作过程</a></p><center><img src="image-20191227233813861.png" srcset="/img/loading.gif" alt="image-20191227233813861" style="zoom:50%;" /></center><blockquote><p>采用 DHCP 时，每个网络必须有一个 DHCP 服务器负责地址配置。</p><ul><li>当计算机启动时， 它有一个嵌入在 NIC 中的内置以太网地址或其他链路层地址，但没有 IP 地址。像 ARP 一 样，该计算机在自己的网络上广播一个报文，请求 IP 地址。这个请求报文就是 DHCP DISCOVER 包</li><li>这个包必须到达 DHCP 服务器。如果 DHCP 服务器没有直接连在本地网络， 那么必须将路由器配置成能接收 DHCP 广播并将该请求报文中继给 DHCP 服务器，由 DHCP 服务器来处理 DHCP 报文。</li><li>当 DHCP 服务器收到请求，它就为该主机分配一个空闲的 IP 地址，并通过 DHCP OFFER 包返回给主机（这个报文或许也要通过路由器中继〉。为了在主机没有 IP 地址的情况下完成此项工作，服务器用主机的以太网地址来标识这台主机（主机的以太网地址由 DHCP DISCOVER 包携带过来）。</li></ul></blockquote><p>为了确定一个主机拥有IP地址的时间，采用了leasing技术。在leasing期满前，主机必须和DHCP续订。</p><h3 id="Label-Switching-and-MPLS"><a href="#Label-Switching-and-MPLS" class="headerlink" title="Label Switching and MPLS"></a>Label Switching and MPLS</h3><p>MPLS(multiprotocol label switching)</p><p>MPLS 在每个数据包前面增加一个标签，路由器根据<strong><em><u>数据包标签</u></em></strong>而不是数据包目标地址实施转发。用标签作为一个内部表的索引，快速查找该表找出正确的输出线路，因而这只是一个表查操作。使用这种技术，路由器的转发速度非常快。</p><center><img src="image-20191227234537219.png" srcset="/img/loading.gif" alt="image-20191227234537219" style="zoom:50%;" /></center>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer network--网络层part1</title>
    <link href="/2019/12/06/ComputerNetwork/NetworkLayer/"/>
    <url>/2019/12/06/ComputerNetwork/NetworkLayer/</url>
    
    <content type="html"><![CDATA[<h1 id="1-网络层的设计问题"><a href="#1-网络层的设计问题" class="headerlink" title="1. 网络层的设计问题"></a>1. 网络层的设计问题</h1><h2 id="1-1-存储转发数据包交换"><a href="#1-1-存储转发数据包交换" class="headerlink" title="1.1 存储转发数据包交换"></a>1.1 存储转发数据包交换</h2><p>阴影椭圆中的是网络服务提供商(ISP)的设备</p><p>如果一台主机想要发送一个数据包，他就将数据包传输给最近的路由器。</p><p>在该数据包到达路由器，并且路由器的链路层完成了对它校验和的验证之后，它先被存储在路由器上；然后沿着路径被转发到下一个路由器，直至到达目标主机</p><center><img src="image-20191119095439198.png" srcset="/img/loading.gif" alt="image-20191119095439198" style="zoom: 25%;" /></center><h2 id="1-2-提供给传输层的服务"><a href="#1-2-提供给传输层的服务" class="headerlink" title="1.2 提供给传输层的服务"></a>1.2 提供给传输层的服务</h2><ol><li>向上提供的服务应该独立于路由器技术。</li><li>应该向传输层屏蔽路由器的数量、类型和拓扑关系。 </li><li>传输层可用的网络地址应该有一个统一编址方案，甚至可以跨越 LAN 和 WAN。</li></ol><h2 id="1-3-无连接服务的实现"><a href="#1-3-无连接服务的实现" class="headerlink" title="1.3 无连接服务的实现"></a>1.3 无连接服务的实现</h2><blockquote><p>所有的数据包都被独立地注入到网络中，并且每个数据包独立路由，不需要提前建立任何 设置。在这样的上下文中，数据包通常称为数据报[datagram]，它类似于电报[telegram], 对应的网络称为数据报网络[datagram network]</p></blockquote><center><img src="image-20191219154907937.png" srcset="/img/loading.gif" alt="image-20191219154907937" style="zoom:40%;" /></center><h2 id="1-4-面向连接服务的实现"><a href="#1-4-面向连接服务的实现" class="headerlink" title="1.4 面向连接服务的实现"></a>1.4 面向连接服务的实现</h2><blockquote><p>在发送数据包之前，必须首先建立起一条从源路由器到目标路由器之间的路径。这个连接称为虚电路[VC, virtual circuit]，它类似于电话系统中建立的物理电路，对应的网络称为虚电路网络[virtual-circuit network]</p></blockquote><p>虚电路背后的思想是避免为要发送的数据包选择新路径。相反，当建立一个连接时，从源机器到目标机器之间的一条路径就被当作这个连接的一部分确定了下来，并且保存在这些中间路由器的表中。所有需要在这个连接上通过的流量，都使用这条路径。</p><p>如图，主机H1与主机H2之间建立了连接1。这条连接被记录在每个路由表中的第一项中。 </p><p>A 路由表的第一行说明如果一 个标示了连接标识符1的数据包来自于H1，那么它将被发送到路由器 C，并且赋予连接标识符 1 。类似地， C路由表中的第一项将该数据包路由到 E，也赋予连接标识符 1</p><p>现在我们来考虑如果 H3 也希望与 H2 建立连接则情形会怎么样。 H3 选择连接标识符 1 [因为是它发起连接，而且这是它唯一的连接]，并且告诉网络要建立虚电路。因此路由表增加了第二行。请注意，这里有一个冲突，因为，尽管 A 很容易区分出标识连接 1 的数据包是来自H1还是来自 H3 ，但是， C 无法区分它们。基于这个原因， A 给第二个连接的出境流量分配一个不同的连接标识符。这种避免冲突的做法说明了为什么路由器需要具备替换出境数据包中连接标识符的能力。</p><center><img src="image-20191219154931266.png" srcset="/img/loading.gif" alt="image-20191219154931266" style="zoom:50%;" /></center><h2 id="1-5-虚电路和数据报网络的比较"><a href="#1-5-虚电路和数据报网络的比较" class="headerlink" title="1.5 虚电路和数据报网络的比较"></a>1.5 虚电路和数据报网络的比较</h2><center><img src="image-20191219222827287.png" srcset="/img/loading.gif" alt="image-20191219222827287" style="zoom:40%;" /></center><ul><li>建立时间： <ul><li>虚电路需要一个建立阶段，这个阶段花费时间也消耗资源。但是，付出这个代价后，处理一个数据包的方法却非常简单：路由器只要使用电路号作 为索引，在表中找到该数据包的去向即可。</li><li>在数据报网络中，不需要建立电路，但路由器需要执行一个更为复杂的查找过程以便找到目标表项。</li></ul></li><li>避免拥塞：<ul><li>虚电路在建立连接接时，资源可以提前预留（比如缓冲区空间、带宽和 CPU 周期〉。一旦数据包开始到来， 所需要的带宽和路由器容量都已经准备就绪。</li><li>而对于数据报网络，避免拥塞更困难些。</li></ul></li><li>脆弱性：<ul><li>虚电路也存在脆弱性问题。如果一台路由器崩溃并且内存中的数据全部丢失，那么即 使它一秒钟之后又重新启动，所有从它这里经过的虚电路都将不得不中断。</li><li>如果一台数据报路由器岩机，只有那些当时尚留在路由器队列中的数据包用户会受到影响</li></ul></li></ul><h1 id="2-路由算法"><a href="#2-路由算法" class="headerlink" title="2. 路由算法"></a>2. 路由算法</h1><p>路由算法是网络层软件的一部分，负责确定一个入境数据包应该被发送到哪一条输出线路上。</p><p><strong>路由</strong>和<strong>转发</strong>这两个功能的区别</p><ul><li>路由</li></ul><div class="note note-warning">            <p>涉及一个网络的<strong>所有路由器</strong>，经由路由选择协议共同交互，来决定分组从源到目的地结点所采取的路 </p>          </div><ul><li>转发</li></ul><div class="note note-warning">            <p>分组在<strong>单一的路由器</strong>从一条入链路到一条出链路到传送 </p>          </div><p><br/></p><p>路由算法可以分成两类</p><blockquote><ul><li><p>非自适应算法：不会根据当前测量或者估计的流量和拓扑结构，来调整它们的路由决策。</p></li><li><p>自适应算法</p></li></ul></blockquote><h2 id="2-1-优化原则"><a href="#2-1-优化原则" class="headerlink" title="2.1 优化原则"></a>2.1 优化原则</h2><p>最优化原则：</p><div class="note note-warning">            <p>如果路由器J在从路由器I到路由器K的最优路径上，那么从J到K到最优路径必定遵循同样的路由</p>          </div><center><img src="image-20191129193218868.png" srcset="/img/loading.gif" alt="image-20191129193218868" style="zoom:50%;" /></center><p>直接推论：从所有的源到一个指定目标的最优路径的集合构成了一棵以目标节点为根的树。这样的树称为<strong><em>汇集树[sink tree]</em></strong></p><p>路由算法的目标就是为所有的路由器找到汇集树，并根据汇集树来转发数据包</p><center><img src="image-20191129193740688.png" srcset="/img/loading.gif" alt="image-20191129193740688" style="zoom:50%;" /></center><h2 id="2-2-最短路径算法"><a href="#2-2-最短路径算法" class="headerlink" title="2.2 最短路径算法"></a>2.2 最短路径算法</h2><p>可以选择距离、带宽、平均流量、通信成本、平均延迟等作为路径的权重</p><p>使用Dijkstra算法</p><table>  <tr>    <td><img src="image-20191202182043293.png" srcset="/img/loading.gif" alt="image-20191202182043293" style="zoom:50%;" /></td>    <td><img src="image-20191202182130071.png" srcset="/img/loading.gif" alt="image-20191202182130071" style="zoom:50%;" /></td>  </tr>  <tr>    <td><img src="image-20191202182159979.png" srcset="/img/loading.gif" alt="image-20191202182159979" style="zoom:50%;" /></td>    <td><img src="image-20191202182231738.png" srcset="/img/loading.gif" alt="image-20191202182231738" style="zoom:50%;" /></td>  </tr>  <tr>    <td><img src="image-20191202182426228.png" srcset="/img/loading.gif" alt="image-20191202182426228" style="zoom:50%;" /></td>  </tr></table><h2 id="2-3-泛洪算法-flooding"><a href="#2-3-泛洪算法-flooding" class="headerlink" title="2.3 泛洪算法[flooding]"></a>2.3 泛洪算法[flooding]</h2><p>flooding将每一个入境数据包发送到除了该数据包到达的那条线路以外的每条出境线路。</p><p>泛洪法会产生大量的重复数据包。事实上，除非采取某些措施来抑制泛洪过程，否则将会产生无限多的数据包。</p><ul><li><p>在每个数据包的header中设置一个hop counter</p><blockquote><p>每经过一跳该计数器减一，当计数器到达 0 时就丢弃该数据包。</p><p>理想情况下，跳计数器的初始值应该等于从源端到接收方之间路径的长度。如果发送方不知道该路径有多长， 它可以将计数器的初始值设置为最坏情形下的长度，即网络的直径。</p></blockquote></li><li><p>keep track of which packets have been flooded, to avoid sending them out a second time.</p></li></ul><p><br/></p><h2 id="2-4-距离矢量算法-Distance-Vector"><a href="#2-4-距离矢量算法-Distance-Vector" class="headerlink" title="2.4 距离矢量算法[Distance Vector]"></a>2.4 距离矢量算法[Distance Vector]</h2><blockquote><p>每个路由器维护一张表（即 一个矢量〉，表中列出了当前己知的到每个目标的最佳距离，以及所使用的链路。</p><p>这些表通过邻居之间相互交换信息而不断被更新，最终每个路由器都了解到达每个目的地的最佳链路。</p></blockquote><p><a href="https://blog.csdn.net/u013007900/article/details/45565389" target="_blank" rel="noopener">距离矢量算法详解</a></p><h3 id="i-count-to-infinity-problem"><a href="#i-count-to-infinity-problem" class="headerlink" title="i. count-to-infinity problem"></a>i. count-to-infinity problem</h3><p>虽然DV算法总是能够收敛到正确的答案，但速度可能非常慢。尤其是它</p><ul><li>对于好消息的反应非常迅速</li><li>而对于坏消息的反应异常迟缓。</li></ul><h4 id="i-A-来看一下对好消息是怎么反应的"><a href="#i-A-来看一下对好消息是怎么反应的" class="headerlink" title="i.A 来看一下对好消息是怎么反应的"></a>i.A 来看一下对好消息是怎么反应的</h4><center><img src="image-20191202184133049.png" srcset="/img/loading.gif" alt="image-20191202184133049" style="zoom: 40%;" /></center><p>以跳数作为路径的权重</p><p>假设A最初处于停机状态，考虑A突然启动的情况</p><blockquote><ol><li><p>一开始，B、C、D、E都不和A连通，所以都是“·”状态</p></li><li><p>在第一次交换时， B 知道它左边的邻居到 A 的延迟为 0 。于是 B 在它的路由表中建立一个表项，说明 A 离它一跳远。所有其他的路由器仍然认为 A 是停机的。</p></li><li>在接下去的交换中，C知道B有一条路径通向A，并且路径长度为1，所以它更新自己的路由表，指明它到 A 的路径长度为 2，但是 D 和 E 要到以后才能听到这个好消息。</li></ol></blockquote><p>从上面的例子可以看出</p><p>好消息扩散的速度是每交换一次往远处走一跳。如果一个网络中最长路径是 N 跳，那么经过 N 次交换之后，每个路由器都将知道新恢复的链路和路由器。</p><h4 id="i-B-再来看一下对坏消息的反应"><a href="#i-B-再来看一下对坏消息的反应" class="headerlink" title="i.B 再来看一下对坏消息的反应"></a>i.B 再来看一下对坏消息的反应</h4><center><img src="image-20191202185212842.png" srcset="/img/loading.gif" alt="image-20191202185212842" style="zoom:40%;" /></center><p>以跳数作为路径的权重</p><p>假设A最初处于启动状态，考虑A突然停机或者A和B之间链路断了的情况</p><blockquote><ol><li>一开始，B、C、D、E都有通向A的链路</li><li>在第一次信息交换时， B 没有听到来自 A 的任何信息。幸运的是， C 说“别担心，我有一条通向 A 的长度为 2 的路径”， B 并不怀疑 C 如何到达A。因此， B 认为它可以通过 C 到达 A，路径长度为 3 。在第一次交换之后， D 和 E 并不更新它们的 A 表项。</li><li>在第二次信息交换时， C 注意到，它的每一个邻居都声称有一条通向 A 的长度为 3 的路径。它随机地挑选出一条，并且将它到A的距离更新为4。</li><li>通过后续的交换，可以得到图中余下的记录历史。</li></ol></blockquote><p>逐渐地，所有的路由器都会趋向无穷大，但是所需交换的次数依赖于代表无穷大的数值。由于这样的原因，明智的做法是将无穷大设置为最长的路径+1</p><p><a href="https://blog.csdn.net/tianlongtc/article/details/80261581" target="_blank" rel="noopener">毒性逆转</a></p><p><br/></p><h2 id="2-5-链路状态路由-link-state-routing"><a href="#2-5-链路状态路由-link-state-routing" class="headerlink" title="2.5 链路状态路由[link state routing]"></a>2.5 链路状态路由[link state routing]</h2><ol><li>发现它的邻居节点，并了解其网络地址。</li><li>设置到每个邻居节点的距离或者成本度量值。</li><li>构造一个包含所有刚刚获知的链路信息包。</li><li>将这个包发送给所有其他的路由器，并接收来自所有其他路由器的信息包。</li><li>计算出到每个其他路由器的最短路径。</li></ol><p><br/></p><h3 id="i-发现邻居"><a href="#i-发现邻居" class="headerlink" title="i. 发现邻居"></a>i. 发现邻居</h3><p>首先路由器要找到它的邻居。</p><p>路由器在每一条点到点线路上发送一个特殊的 HELLO 数据包，线路另一端的路由器应该返回一个应答说明自己是谁。</p><p><br/></p><p>注意，这里会将LAN看成一个pseudonode</p><center><img src="image-20191224223921157.png" srcset="/img/loading.gif" alt="image-20191224223921157" style="zoom:50%;" /></center><h3 id="ii-设置链路成本"><a href="#ii-设置链路成本" class="headerlink" title="ii. 设置链路成本"></a>ii. 设置链路成本</h3><p>需要每条链路以距离、成本、延迟度量。</p><p>测定延迟的方法是：</p><blockquote><p>通过线路给另一边发送一个特殊的 ECHO 数据包，要求对方立即发回。通过测量往返时间再除以 2</p></blockquote><p><br/></p><h3 id="iii-构造链路状态包-link-state-packets"><a href="#iii-构造链路状态包-link-state-packets" class="headerlink" title="iii. 构造链路状态包[link state packets]"></a>iii. 构造链路状态包[link state packets]</h3><center><img src="image-20191203080937476.png" srcset="/img/loading.gif" alt="image-20191203080937476" style="zoom: 33%;" /></center><h4 id="iii-A-link-state-packets的结构"><a href="#iii-A-link-state-packets的结构" class="headerlink" title="iii.A link state packets的结构"></a>iii.A link state packets的结构</h4><ul><li>发送方的标识符</li><li>序号[Seq]</li><li>年龄[Age]</li><li>邻居列表，对于每个邻居，同时给出到这个邻居的延迟</li></ul><h4 id="iii-B-什么时候构造数据包"><a href="#iii-B-什么时候构造数据包" class="headerlink" title="iii.B 什么时候构造数据包"></a>iii.B 什么时候构造数据包</h4><ul><li>周期性地创建数据包</li><li>每当发生某些重要的事情时才创建数据包，比如一条线路断掉或者一个邻居节点停机…</li></ul><p><br/></p><h3 id="iv-分发链路状态包"><a href="#iv-分发链路状态包" class="headerlink" title="iv. 分发链路状态包"></a>iv. 分发链路状态包</h3><p>链路状态路由算法最技巧的部分在于分发链路状态数据包</p><p><br/></p><p>思路：</p><p>泛洪将link state packets分发给所有路由器。为了控制flooding规模，每个数据包都有一个序号。</p><ul><li><p>Sequence number increments for each new pkt sent.</p></li><li><p>Routers keeps track of all the (source router, sequence) pairs they see.</p></li><li><p>If pkt is new, forward to lines except the incoming one</p></li><li><p>Else, discard.</p></li><li><p>If sequence number is lower than highest one seen so far, reject as obsolete.</p></li><li><p>To include age of each packet and decrement it once per second. If age hits 0, discard the information.</p></li></ul><p><br/></p><p>可能产生的问题与解决方法</p><ul><li><p>如果序号绕回，可能会产生混淆。</p><blockquote><p>解决方案：使用一个 32 位的序号。</p></blockquote></li><li><p>如果一个路由器崩溃了，那么它将丢失所有的序号记录表。如果它再从 0 开始， 那么，下一个数据包将被作为重复数据包而拒绝。</p><p>再次，如果一个序号被破坏了，比如发送方发送的序号为 4，但是由于产生了 1 位错 误，所以接收方看到的序号是 65540 ，那么，序号从 5 到 65540 的数据包都将被当作过时数据包而拒绝接受，因为接收方认为当前的序号是 65540 。</p><blockquote><p>解决方案：在每个数据包的序号之后包含一个年龄[ age ]宇段， 并且每秒钟将年龄减 1 。当年龄字段的值被减到 0 时，来自路由器的该信息将被丢弃。通常情况下，每隔一段时间，比如说 10 秒，一个新的数据包就会到来：</p></blockquote></li></ul><center><img src="image-20191203083626941.png" srcset="/img/loading.gif" alt="image-20191203083626941" style="zoom:40%;" /></center><h3 id="v-Computing-the-new-routes"><a href="#v-Computing-the-new-routes" class="headerlink" title="v. Computing the new routes"></a>v. Computing the new routes</h3><p>Once a router has accumulated a full set of link state packets, it can construct the entire subnet graph because every link is represented.</p><p>在路由器本地运行Dijkstra算法，来计算路由</p><p><br/></p><h3 id="LS-DV的比较"><a href="#LS-DV的比较" class="headerlink" title="LS-DV的比较"></a>LS-DV的比较</h3><center><img src="image-20191203084340533.png" srcset="/img/loading.gif" alt="image-20191203084340533" style="zoom: 40%;" /></center><h2 id="2-6-层次路由"><a href="#2-6-层次路由" class="headerlink" title="2.6 层次路由"></a>2.6 层次路由</h2><p>为什么要分层：</p><div class="note note-info">            <p>随着网络规模的增长，路由器的路由表也成比例地增长．不断增长的路由表不仅消耗路由器内存，而且还需要更多的 CPU 时间来扫描路由表以及更多的带宽来发送有关的状态 报告。当网络增长到一定时可能会达到某种程度，此时每个路由器不太可能再为其他每一个路由器维护一个表项。所以 ， 路由不得不分层次进行</p>          </div><p><br/></p><p>Two level routing:</p><blockquote><ul><li><p>Every router knows all the details about how to route packets to destinations within its own region</p></li><li><p>but knows nothing about the internal structure of other regions.</p></li></ul></blockquote><p><br/></p><p>Multiple-level routing</p><blockquote><p>regions-&gt;clusters-&gt;zones-&gt;groups-&gt;…</p></blockquote><p><br/></p><p>下面是一个two-level routing的例子，其中有5个区域</p><p>路由器1A的完整路由表[图b]有17个表项。</p><p>如果采用分级路由，则路由器如图c所示，路由表有7项</p><center><img src="image-20191203084908185.png" srcset="/img/loading.gif" alt="image-20191203084908185" style="zoom:35%;" /></center><p>应该分成多少层</p><blockquote><p>对于一个包含 N 个路由器的网络，最优的层数是 lnN，每个路由器所需的路由器表项是 elnN 个。</p></blockquote><p>例如，考虑一个具有 720 个路由器的子网。如果没有分层，每个路由器需要 720 个路由表项</p><p>如果子网被分 成 24 个区域，每个区域 30 个路由器，那么每个路由器只需要 30 个本地表项，加上 23 个 远程表项，总共 53 个表项</p><p>如果采用三级层次结构，总共 8 个簇，每个簇包含 9 个区域，每个区域 10 个路由器，那么，每个路由器需要 10 个表项用于记录本地路由器， 8 个表项用于到同一簇内其他区域的路由， 7 个表项用于远程的簇，总共 25 个表项。</p><h2 id="2-7-广播路由"><a href="#2-7-广播路由" class="headerlink" title="2.7 广播路由"></a>2.7 广播路由</h2><p>广播：to send a packet to all destinations simultaneously.</p><p>广播的方法</p><ul><li><p>让源机器给每一个目标单独发送一个数据包</p><blockquote><p>不仅浪费带宽，而且要求源机器拥有所有目标机器的完整地址</p></blockquote></li><li><p>多目标路由[multidestination routing]</p><blockquote><p>每个数据包包含一组目标地址，或者一个位图，由该位图指定所期望到达的目标。</p><p>当一个数据包到达一个路由器时， 路由器检查数据包携带的所有目标，确定哪些输出线路是必要的[只要一条输出线路是到达至少一个目标的最佳路径，那么它就是必要的]。</p><p>路由器为每一条需要用到的输出线路生成一份该数据包新的副本，在这份副本中只包含那些使用这条线路的目标地址。实际上，原来的目标集合被分散到这些输出线路上。</p><p>在经过了足够多的跳数之后，每个数据包将只包含一个目标地址，因此可以被当作普通的数据包来对待。</p><p>优点：当多个数据包必须遵循同样的路径时，其中一个数据包承担了全部的费用，而其他的数据包则是免费搭载。因此，网络带宽的利用率更高。</p><p>缺点：依然要求源端知道全部的目标地址，对于路由器来说，要确定从哪些线路转发多目标数 据包的工作量太大，尤其是处理多个不同的数据包时。</p></blockquote></li><li><p>flooding</p></li><li><p>逆向路径转发[reverse path forwarding]</p><p>当一个广播数据包到达一个路由器时，路由器检查它到来的那条线路是否正是通常用来给广播源端发送数据包用的那条线路。</p><ul><li>如果是，则该广播数据包是沿着最佳路径被转发过来的，因而是到达当前路由器的第一份副本。该路由器将该数据包转发到除了到来的那条线路之外的所有 其他线路上。</li><li>如果广播数据包是从其他任何一条并非首选的到达广播源的线路入境的话，该数据包被当作一个可能的重复数据包而丢弃。</li></ul><center><img src="image-20191205155744495.png" srcset="/img/loading.gif" alt="image-20191205155744495" style="zoom:40%;" /></center><p><br/></p></li></ul><center><img src="image-20191205154558002.png" srcset="/img/loading.gif" alt="image-20191205154558002" style="zoom:50%;" /></center><blockquote><p>(a)部分显示了一个网络， (b )部分显示了该网络中路由器 <strong><em>I</em></strong> 的一棵汇集树，图(c部分显示了逆向路径算法是如何工作的。</p><ol><li>在第一跳， I 发送数据包给 F、 H、 J 和 N，如树中第二行所示。这些数据包中的每一个都是在通向 I 的首选路径（假定首选的路径都沿着汇集树)到来的， 这点用字母外面加一个圆圈来表示。</li><li>在第二跳，共产生了 8 个数据包，其中，在第一跳接收到数据包的路由器各产生 2 个数据包。结果，所有这 8 个数据包都到达了以前没有访问过的路由器，其中 5 个是沿着首选线路到来的。</li><li>在第三跳所产生的 6 个数据包中，只有 3 个是沿首选路径（在 C、 E 和 K）到来的，其他的都是重复数据包。在经过五跳和 24 个数据包以 后，广播过程终止。相比之下，如果完全沿着汇集树的话，只需要 4 跳和 14 个数据包。</li></ol></blockquote><ul><li>spanning tree</li></ul><p>改进了逆向路径转发。</p><p>每个路由器都知道它的哪些线路属于生成树，它就可以将一个人境广播数据包复制到除了该数据包到来的那条线路之外的所有<strong><em><u>生成树线路</u></em></strong>上。</p><blockquote><p>和逆向路径转发相比，逆向路径转发并不只转发到生成树线路，还会转发到其他线路，这些数据包会被认为是可能的重复数据包而被丢弃；而生成树算法没有丢弃问题</p></blockquote><p><br/></p><h2 id="2-8-组播路由-multicast"><a href="#2-8-组播路由-multicast" class="headerlink" title="2.8 组播路由[multicast]"></a>2.8 组播路由[multicast]</h2><p>to send messages to well-defined groups that are numerically large in size but small compared to the network as whole.</p><center><img src="image-20191205155836717.png" srcset="/img/loading.gif" alt="image-20191205155836717" style="zoom: 40%;" /></center><p>通过修建广播生成树把不通往组成员的链路从树中删掉。修建结果得到的是一颗有效的组播生成树。</p><p><br/></p><p>生成树的修建方法：</p><ul><li><p>link state: </p></li><li><p>DV</p></li><li><p>core-based trees</p><blockquote><p>所有路由器都同意某个路由器作为根，这个根称为核心（ core ）或会聚点（rendezvous point )，然后每个成员通过给根发送一个数据包来建立这棵树。</p><p>为了把数据包发送到这个组，发送者把数据包发给核心：当数据包到达核心后，它再被沿着树往下转发</p></blockquote></li></ul><h2 id="2-9-选播路由-Anycast-routing"><a href="#2-9-选播路由-Anycast-routing" class="headerlink" title="2.9 选播路由[Anycast routing]"></a>2.9 选播路由[Anycast routing]</h2><p>在选播方式下，数据包被传 递给最近的一个组成员。</p><h3 id="为什么要选播？"><a href="#为什么要选播？" class="headerlink" title="为什么要选播？"></a>为什么要选播？</h3><blockquote><p>有时，对客户最重要的是获得正确的信息而不是与哪个节点取得联系，任何节点都可以， 只要它能提供所需的服务</p></blockquote><p>LS, DV算法可以用来生产选播路由。</p><p>假设我们要选播数据包到组1的成员，该组成员都将被赋予 一个组地址1而不是一个个独立的地址。距离矢量路由将像往常一样分发向量，并且节点将只选择到目的地1的最短路径。这将导致数据包被发送到目的地1的最近实例。</p><p>此过程之所以能正常工作是因为路由协议认为节点1的实例都是同一个节点，</p><center><img src="image-20191224225002633.png" srcset="/img/loading.gif" alt="image-20191224225002633" style="zoom:50%;" /></center><p>总结</p><ul><li><p>unicast：源给单个目标节点发送</p></li><li><p>broadcast: 源给所有目标节点发送</p></li><li><p>multicast: 源给一组目标节点发送</p></li><li><p>Anycast: a packet is delivered to the nearest member of a group.</p></li></ul><h2 id="2-10-Routing-for-the-mobile-hosts"><a href="#2-10-Routing-for-the-mobile-hosts" class="headerlink" title="2.10 Routing for the mobile hosts"></a>2.10 Routing for the mobile hosts</h2><center><img src="image-20191224231029464.png" srcset="/img/loading.gif" alt="image-20191224231029464" style="zoom:50%;" /></center><h2 id="2-11-Routing-in-Ad-Hoc-Networks"><a href="#2-11-Routing-in-Ad-Hoc-Networks" class="headerlink" title="2.11 Routing in Ad Hoc Networks"></a>2.11 Routing in Ad Hoc Networks</h2><p>In ad-hoc network, the network topology may be changing all the time.</p><p><strong><em>AODV</em></strong>: </p><blockquote><p>Ad hoc On-demand Distance Vector. The most popular routing algorithm for Ad Hoc Networks.</p></blockquote><p>Consider the problem: A wants to send to I</p><blockquote><p>(a) A broadcasts, attempting to reach I.</p><p>(b) B and D received, establish reverse paths to A.</p><p>(c) B and D broadcast. C, F, and G received, establish reverse paths to B and D.</p><p>(d) C,F,G broadcast. E, H, and I received (I reached!).</p><p>I sends back a REPLY along the reverse path. G and D establish to path to I when they process REPLY.</p></blockquote><center><img src="image-20191224231601828.png" srcset="/img/loading.gif" alt="image-20191224231601828" style="zoom:50%;" /></center>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Memory Management</title>
    <link href="/2019/11/22/MemoryManagement/"/>
    <url>/2019/11/22/MemoryManagement/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><style>  .page__header .header__brand path {    fill: rgba(255, 255, 255, .95);  }</style><p><br/></p><h1 id="1-虚拟内存基础"><a href="#1-虚拟内存基础" class="headerlink" title="1. 虚拟内存基础"></a>1. 虚拟内存基础</h1><h2 id="1-1-物理和虚拟寻址"><a href="#1-1-物理和虚拟寻址" class="headerlink" title="1.1 物理和虚拟寻址"></a>1.1 物理和虚拟寻址</h2><p>主存[main memory]是一个由M个连续的byte组成的数组。<strong><em>每个byte都有一个物理地址与他对应</em></strong>。比如第1个byte对应0的物理地址，第二个byte对应1的物理地址。</p><p>可以使用物理地址访问内存。如图，CPU向主存请求物理地址4为起点的4个bytes。</p><p>CPU执行这条加载指令时</p><ul><li>会生成一个有效物理地址，通过内存总线，传递给主存</li><li>主存取出数据返回给CPU</li><li>CPU将数据放在一个寄存器里。</li></ul><center><img src="image-20191122221045486.png" srcset="/img/loading.gif" alt="image-20191122221045486" style="zoom: 67%;" /></center><p>现在计算机都会使用虚拟寻址</p><p>CPU生成一个虚拟地址来访问主存</p><p>这个虚拟地址在被送到内存之前先转换成适当的物理地址，这个过程叫做地址翻译。需要CPU芯片上的MMU于OS合作</p><center><img src="image-20191122222054227.png" srcset="/img/loading.gif" alt="image-20191122222054227" style="zoom:50%;" /></center><p><br/></p><h2 id="1-2-地址空间"><a href="#1-2-地址空间" class="headerlink" title="1.2 地址空间"></a>1.2 地址空间</h2><p>地址空间是以一个非负整数地址的有序集合：${0,1,2,\cdots}$，</p><p>如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间。</p><p><br/></p><p>在一个带虚拟内存的系统中，CPU从一个有$N=2^n$个地址的地址空间中生成虚拟地址，虚拟地址空间的集合为${0,1,2,\cdots,N-1}$，这个虚拟地址空间就叫做一个n位地址空间，现代系统通常支持32位或者64位虚拟地址空间</p><p>物理地址空间对应于物理内存的M个字节${0,1,2,\cdots,M-1}$, M并不要求是2的幂，为了简化问题，我们假设$M=2^m$</p><center><img src="image-20191123110239273.png" srcset="/img/loading.gif" alt="image-20191123110239273" style="zoom:50%;" /></center><p><br/></p><h2 id="1-3-虚拟内存作为缓存的工具"><a href="#1-3-虚拟内存作为缓存的工具" class="headerlink" title="1.3 虚拟内存作为缓存的工具"></a>1.3 虚拟内存作为缓存的工具</h2><p>磁盘上的数据被分割成块，块是磁盘是主存之间的传输单元。</p><p>内存又是怎么分割的呢？</p><h3 id="emsp-emsp-分页"><a href="#emsp-emsp-分页" class="headerlink" title="&emsp;&emsp;分页"></a>&emsp;&emsp;分页</h3><p>页面是主存物理空间中划分出来的等长的固定区域。分页方式的优点是页长固定，因而便于构造页表、易于管理，且不存在外碎片。但分页方式的缺点是页长与程序的逻辑大小不相关。例如，某个时刻一个子程序可能有一部分在主存中，另一部分则在辅存中。这不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。</p><h3 id="emsp-emsp-分段"><a href="#emsp-emsp-分段" class="headerlink" title="&emsp;&emsp;分段"></a>&emsp;&emsp;分段</h3><p>段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。</p><p> 段表本身也是一个段，可以存在辅存中，但一般是驻留在主存中。将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。</p><p>(1)    段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序共享。</p><p>(2)    段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。</p><p>(3)    方便编程，分段共享，分段保护，动态链接，动态增长</p><p> 因为段的长度不固定，段式虚拟存储器也有一些缺点：</p><p>(1)    主存空间分配比较麻烦。</p><p>(2)    容易在段间留下许多碎片，造成存储空间利用率降低。</p><p>(3)    由于段长不一定是2的整数次幂，因而不能简单地像分页方式那样用虚拟地址和实存地址的最低若干二进制位作为段内地址，并与段号进行直接拼接，必须用加法操作通过段起址与段内地址的求和运算得到物理地址。因此，段式存储管理比页式存储管理方式需要更多的硬件支持。</p><table>  <tr>    <td><img src="image-20191125130737955.png" srcset="/img/loading.gif" alt="image-20191125130737955" style="zoom:50%;" /></td>    <td><img src="image-20191125130301483.png" srcset="/img/loading.gif" alt="image-20191125130301483" style="zoom: 33%;" /></td>  </tr></table><p>VM将虚拟内存分割成虚拟页[Virtual Page, VP]，每一个page是磁盘中一个块的大小，虚拟页的大小为$P=2^p$。同样物理内存也被分割为物理页[Physical Page, PP 也被称为页帧page frame]，大小也为P bytes</p><ul><li><h3 id="intel-pentium-支持分页加分段"><a href="#intel-pentium-支持分页加分段" class="headerlink" title="intel pentium[支持分页加分段]"></a>intel pentium[支持分页加分段]</h3></li></ul><center><img src="image-20191202130520024.png" srcset="/img/loading.gif" alt="image-20191202130520024" style="zoom:50%;" /></center><h4 id="A-pentium分段："><a href="#A-pentium分段：" class="headerlink" title="A. pentium分段："></a>A. pentium分段：</h4><p>pentium允许一个段段大小最多可达4GB，每个进程最多的段段数量为16K个</p><blockquote><p>进程的逻辑地址空间分成两部分</p><ul><li>私有：8K个段————————-信息保存在local descriptor table, LDT中</li><li>所有进程共享：8K个段——信息保存在glocal descriptor table, GDT中</li></ul><p>LDT，GBT的每个条目为<u>8B</u>，包括一个段段详细信息，如基位置和段界限</p></blockquote><p><strong><em>i. <u>逻辑地址</u>是一对[selector, offset]，48bits</em></strong></p><ul><li>selector 16bits</li></ul><center><img src="image-20191202130545949.png" srcset="/img/loading.gif" alt="image-20191202130545949" style="zoom:50%;" /></center><blockquote><p>其中s表示段号，g表示段是在GDT还是在LDT中，p表示保护信息</p></blockquote><ul><li>offset 32bits</li></ul><blockquote><p> 用来表示字节[或者 字]在段内的位置</p></blockquote><p>机器有6个段寄存器，允许一个进程同时访问6个段。</p><p>它还有6个8B的微程序寄存器，用来保存相应的来自LDT或GDT的描述符。这个缓冲区允许pentium不必在每次内存引用时都从内存中读取描述符</p><p><strong><em>ii.pentium<u>线性地址</u> 32bits</em></strong></p><p>线性地址的形成方式：</p><blockquote><p>段寄存器指向LDT或GDT中的适当条目</p><p>段的基地址和界限信息用来产生线性地址</p><ul><li>界限用来检查地址的合法性。如果地址无效，就产生内存出错；如果有效，偏移值就和基地址的值相加，产生32位线性地址</li></ul></blockquote><center><img src="image-20191202132646744.png" srcset="/img/loading.gif" alt="image-20191202132646744" style="zoom:50%;" /></center><h4 id="B-pentium分页"><a href="#B-pentium分页" class="headerlink" title="B. pentium分页"></a>B. pentium分页</h4><p>pentium体系结构允许页的大小为4KB或者4MB。</p><p>对于4KB的页，pentium采用二级分页方案，其中32位线性地址按如下形式划分</p><center><img src="image-20191202133553560.png" srcset="/img/loading.gif" alt="image-20191202133553560" style="zoom:50%;" /></center><p>最高10位引用最外层页表的条目，被称为page directory。</p><p>page directory线性地址中内存的10位内容索引的内部页表。最低的11位是页表项所指向的4KB页面内的偏移。</p><p>页目录中的一个条目是page size标志，如果设置了这个标志，就表示页帧的大小为4MB，page directory直接指向4MB的页帧，绕过了内层页表</p><center><img src="image-20191202133744592.png" srcset="/img/loading.gif" alt="image-20191202133744592" style="zoom:50%;" /></center><h3 id="back-to-分页"><a href="#back-to-分页" class="headerlink" title="back to 分页"></a>back to 分页</h3><p>任意时刻，虚拟页中的页都属于以下三种状态中的一种</p><ul><li>未分配的：没有磁盘数据与其对应</li><li>缓存的：对应磁盘中的一个块，并且缓存进了物理内存</li><li>未缓存的：对应磁盘中的一个块，但是还没有缓存进物理内存</li></ul><center><img src="image-20191122231457120.png" srcset="/img/loading.gif" alt="image-20191122231457120" style="zoom:50%;" /></center><h3 id="1-3-1-page-table"><a href="#1-3-1-page-table" class="headerlink" title="1.3.1 page table"></a>1.3.1 page table</h3><p>如下图所示，page table是page table entry组成的数组。他是被存在内存中的</p><p>一个page table entry[PTE]有一个有效位和一个物理页号。</p><p>如果有效位是1，说明他已缓存</p><p>如果有效位是0</p><ul><li>null代表未分配的</li><li>如果是未缓存的，这个地址指向该虚拟页在<strong>磁盘</strong>上的起始位置</li></ul><center><img src="image-20191122231829304.png" srcset="/img/loading.gif" alt="image-20191122231829304" style="zoom: 50%;" /></center><h4 id="A-page-hit"><a href="#A-page-hit" class="headerlink" title="A. page hit"></a>A. page hit</h4><p>如果CPU想要读在VP2中的虚拟内存中的一个word</p><ul><li><p>MMU将虚拟地址作为索引来定位PTE2，并从内存中读取PTE2</p></li><li><p>因为PTE2的有效位是1，所以MMU知道了VP2已经缓存在内存中了。它使用PTE2中的物理页号，构造出这个word的物理地址</p></li></ul><center><img src="image-20191122232635336.png" srcset="/img/loading.gif" alt="image-20191122232635336" style="zoom:50%;" /></center><h4 id="B-page-fault"><a href="#B-page-fault" class="headerlink" title="B. page fault"></a>B. page fault</h4><p>CPU想要访问VP3中的一个word,但是VP3并未缓存在内存中</p><ul><li>MMU从内存中读取PTE3，从有效位推断VP3未被缓存，触发缺页异常</li><li>缺页异常调用内核中的缺页异常处理程序，这个程序选择一个牺牲页，比如放在PP3中的VP4。并且修改page table entry，反映出VP4不再缓存在主存里了<ul><li>如果VP4已经被修改了，内核就会将其复制回磁盘</li></ul></li></ul><center><img src="image-20191122233502102.png" srcset="/img/loading.gif" alt="image-20191122233502102" style="zoom: 50%;" /></center><ul><li>内核从磁盘复制VP3到内存中的PP3，更新PTE3，然后返回</li><li>异常处理程序返回时，它会重新启动导致缺页的指令</li><li>重复同上page hit的过程</li></ul><h4 id="C-分配页面"><a href="#C-分配页面" class="headerlink" title="C. 分配页面"></a>C. 分配页面</h4><center><img src="image-20191122235308295.png" srcset="/img/loading.gif" alt="image-20191122235308295" style="zoom:50%;" /></center><h4 id="虚拟内存效率怎么样呢？"><a href="#虚拟内存效率怎么样呢？" class="headerlink" title="虚拟内存效率怎么样呢？"></a>虚拟内存效率怎么样呢？</h4><p>因为<strong><em>局部性原理</em></strong>，虚拟内存工作得非常好</p><p>尽管在程序运行过程中程序饮用的不同页面的总数可鞥超出物理内存总的大小，但是局部性原理保证在任意时刻，程序去相遇在一个较小的活动页面[active page]集合上工作，这个集合叫做<strong><em>工作集</em></strong>[working set]或者<strong><em>常驻集合</em></strong>[resident set]</p><p>在初始开销，也就是将工作集页面调度到内存中之后，接下来对这个工作集的引用就会hit,不会产生额外的磁盘流量</p><p>但是如果工作集的大小超过了物理内存的大小，就会产生<strong><em>抖动</em></strong>[thrashing],这个时候页面会不断换进换出，程序运行的非常慢</p><h2 id="1-4-虚拟内存作为内存管理的工具"><a href="#1-4-虚拟内存作为内存管理的工具" class="headerlink" title="1.4 虚拟内存作为内存管理的工具"></a>1.4 虚拟内存作为内存管理的工具</h2><p>操作系统位每个进程提供了一个独立的页表，也就是一个独立的虚拟地址空间</p><center><img src="image-20191123001058693.png" srcset="/img/loading.gif" alt="image-20191123001058693" style="zoom: 50%;" /></center><p>虚拟内存的作用</p><blockquote><ul><li><p>简化链接。</p><p>独立地址空间允许每个进程的内存映像都使用相同的格式。如1.2中地址空间的图所示，代码段总是从0x400000开始，数据段跟在代码段之后,…。</p><p>这样的一致性简化了连接器的设计，允许连接器生成完全链接的可执行文件，这些可执行文件独立于独立内存中的代码和数据位置</p></li></ul><ul><li><p>简化加载</p><p>虚拟内存使向内存中加载可执行文件和共享对象文件变得容易。</p><p>要把.text和.data加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页，标记为无效的，并将页表中的地址指向目标文件中适当的位置，这样他处于未缓存的状态。</p><p>但是加载器并不做从磁盘到内存复制数据的工作。在每个页被初次使用时，虚拟内存系统会<strong><em>按需调页</em></strong>。</p><p>将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称为<strong><em>内存映射</em></strong>，Linux提供<code>mmap</code>系统调用，允许应用程序自己做内存映射</p></li><li><p>简化共享</p><p>如果要共享代码和数据，操作系统hi将不同进程中适当的虚拟页映射到相同的物理页面</p></li><li><p>简化内存分配</p><p>虚拟内存为用户提供了一个简单的分配额外内存的机制。比如调用malloc,操作系统分配一个适当数字个连续的虚拟内存页面，并且将它们映射到物理内存中的任意位置的k个任意的物理页面。操作系统并不需要分配k个连续的物理内存页面，页面可以随机的分散在物理内存中。</p></li></ul></blockquote><p><br/></p><h2 id="1-5-虚拟内存作为内存保护的工具"><a href="#1-5-虚拟内存作为内存保护的工具" class="headerlink" title="1.5 虚拟内存作为内存保护的工具"></a>1.5 虚拟内存作为内存保护的工具</h2><p>每次CPU生成一个地址时，地址翻译硬件都会读一个PTE，通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问</p><center><img src="image-20191123112329424.png" srcset="/img/loading.gif" alt="image-20191123112329424" style="zoom:50%;" /></center><p>如上图示例，每个PTE中加入三个许可位。</p><ul><li><code>SUP</code> 进程是否必须运行在内核模式下才能访问该页</li><li><code>READ</code> 控制读权限</li><li><code>WRITE</code> 控制写权限</li></ul><p>如果进程i运行在用户模式下，那么它有读VP0和读写VP1的权限，但是不允许它访问VP2</p><p>如果一条指令违反了这些许可条件，CPU就会触发保护故障，将控制传递给一个内核中的一场处理程序。Linux shell一般将这种一场报告为<code>segmentation fault</code></p><h2 id="1-6-地址翻译"><a href="#1-6-地址翻译" class="headerlink" title="1.6 地址翻译"></a>1.6 地址翻译</h2><center><img src="image-20191123114305099.png" srcset="/img/loading.gif" alt="image-20191123114305099" style="zoom:50%;" /></center><p>地址翻译是一个N元素的VAS中的元素和一个M元素的PAS中元素的映射</p><script type="math/tex; mode=display">MAP: VAS\rightarrow PAS\cup \varnothing</script><script type="math/tex; mode=display">MAP(A)=\{\begin{aligned}&A' if\,A\,in\,physical\,address\,A'\\ &\varnothing if A \,not\,in \,physical\,memory\end{aligned}</script><center><img src="image-20191123114337785.png" srcset="/img/loading.gif" alt="image-20191123114337785" style="zoom:50%;" /></center><h4 id="A-page-hit的步骤"><a href="#A-page-hit的步骤" class="headerlink" title="A. page hit的步骤"></a>A. page hit的步骤</h4><ul><li>CPU抛出一个虚拟地址，传给MMU</li><li>MMU生成PTE地址，并从高速缓存/主存请求page table entry</li><li>告诉缓存/主存向MMU返回该PTE</li><li>MMU根据PTE构造出物理地址，并传给高速缓存/主存</li><li>高速缓存/主存返回所请求的数据给CPU</li></ul><center><img src="image-20191123115551431.png" srcset="/img/loading.gif" alt="image-20191123115551431" style="zoom:50%;" /></center><h4 id="B-Page-fault的步骤"><a href="#B-Page-fault的步骤" class="headerlink" title="B. Page fault的步骤"></a>B. Page fault的步骤</h4><ul><li>CPU抛出一个虚拟地址，传给MMU</li><li>MMU生成PTE地址，并从高速缓存/主存请求page table entry</li><li>告诉缓存/主存向MMU返回该PTE</li><li>PTE有效位是0，MMU触发一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序</li><li>缺页处理程序确定物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘</li><li>缺页处理程序页面调入心的页面，并更新内存中的PTE</li><li>缺页处理程序返回到原来的进程，再次执行导致缺页的指令。</li></ul><center><img src="image-20191123120431404.png" srcset="/img/loading.gif" alt="image-20191123120431404" style="zoom:50%;" /></center><h3 id="1-6-1-结合cache和虚拟内存"><a href="#1-6-1-结合cache和虚拟内存" class="headerlink" title="1.6.1 结合cache和虚拟内存"></a>1.6.1 结合cache和虚拟内存</h3><p>使用虚拟地址还是使用物理地址来访问SRAM呢？</p><blockquote><p>一般使用物理地址</p><p>使用物理寻址，多个进程同时在高速缓存中有存储块和共享来自相同虚拟页面的块成为很简单的事，而且高速缓存无需处理保护问题，因为访问权限的检查是地址翻译的一部分。</p></blockquote><center><img src="image-20191123123805540.png" srcset="/img/loading.gif" alt="image-20191123123805540" style="zoom:50%;" /></center><h3 id="1-6-2-利用TLB加速地址翻译"><a href="#1-6-2-利用TLB加速地址翻译" class="headerlink" title="1.6.2 利用TLB加速地址翻译"></a>1.6.2 利用TLB加速地址翻译</h3><p>因为page table放在内存中。每次CPU产生一个虚拟地址，MMU就必须查阅一个PTE。</p><blockquote><p>在最糟糕的情况下，这会要求从内存多取一次数据，代价是几十到几百个周期</p><p>如果PTE碰巧缓存在L1中，那么开销就下降到1-2个周期</p></blockquote><p>为了减小开销，很多系统都在MMU中包括了一个关于PTE的小缓存，TLB</p><p>如下图，虚拟地址被分成</p><center><img src="image-20191123130033197.png" srcset="/img/loading.gif" alt="image-20191123130033197" style="zoom:50%;" /></center><p>TLB index来索引TLB中的block, TLB tag来检查是否是对应的地址</p><p>步骤</p><ul><li>第一步：CPU产生一个虚拟地址</li><li>第二、三步：MMU从TLB中取出相应的PTE</li><li>第四步：MMU将虚拟地址翻译成一个物理地址，并且发送给告诉缓存/主存</li><li>第五步：告诉缓存/主存将请求的数据返回给CPU</li></ul><p>若TLB miss, MMU 必须从L1缓存/主存中取出相应的PTE，新取出的PTE放在TLB中，可能会覆盖一个已经存在的条目</p><center><img src="image-20191125112258140.png" srcset="/img/loading.gif" alt="image-20191125112258140" style="zoom:50%;"  /></center><p><br/></p><h3 id="1-6-3-多级页表"><a href="#1-6-3-多级页表" class="headerlink" title="1.6.3 多级页表"></a>1.6.3 多级页表</h3><p>一级页表有什么问题：</p><blockquote><p>假设有一个32位的地址空间，4KB的page，4bytes的page table entry</p><p>即使应用需要的只是虚拟地址空间中很小的一部分，也总是需要一个4MB的页表驻留在内存中。</p></blockquote><p>怎么做可以压缩页表呢？——&gt; <strong><em>多级页表</em></strong></p><p><br/></p><blockquote><p>一级页表中的每个PTE对应虚拟内存中的一个4MB的chunk, 每一个chunk都是由1024个连续的页面组成的。</p><p>如果chunk i中的每个page都没有被分配，那么一级页表PTE i就是空的。</p><p>如果chunk i中至少有一个page被分配了，那么一级PTE i就指向一个二级页表的基址。二级页表中的每个PTE负责映射一个4KB的虚拟内存页面</p><p>一个一级页表和一个二级页表的大小是一样的，都是4KB</p></blockquote><p>这样做能够减少内存要求是因为</p><ul><li>如果一级页表中的一个PTE是空的，那么相应的二级页表根本就不会存在</li><li>只有一级页表才需要总是在内存中，虚拟内存系统可以在需要时创建、页面调入、调出二级页表，这就减少了主存的压力，只有最经常使用的二级页表菜需要缓存在主存中</li></ul><center><img src="image-20191125112718240.png" srcset="/img/loading.gif" alt="image-20191125112718240" style="zoom:50%;" /></center><p><br/></p><center><img src="image-20191125112730298.png" srcset="/img/loading.gif" alt="image-20191125112730298" style="zoom:50%;" /></center><h2 id="1-7-案例：Intel-Core-i7-Linux内存系统"><a href="#1-7-案例：Intel-Core-i7-Linux内存系统" class="headerlink" title="1.7 案例：Intel Core i7/Linux内存系统"></a>1.7 案例：Intel Core i7/Linux内存系统</h2><h3 id="1-7-1-地址翻译"><a href="#1-7-1-地址翻译" class="headerlink" title="1.7.1 地址翻译"></a>1.7.1 地址翻译</h3><center><img src="image-20191125120512021.png" srcset="/img/loading.gif" alt="image-20191125120512021" style="zoom:50%;" /></center><h3 id="1-7-2-Linux虚拟内存系统"><a href="#1-7-2-Linux虚拟内存系统" class="headerlink" title="1.7.2 Linux虚拟内存系统"></a>1.7.2 Linux虚拟内存系统</h3><center><img src="image-20191125120939273.png" srcset="/img/loading.gif" alt="image-20191125120939273" style="zoom:50%;" /></center><h1 id="2-按需调页"><a href="#2-按需调页" class="headerlink" title="2. 按需调页"></a>2. 按需调页</h1><p>程序开始时载入整个程序 VS 在需要时才调入相应的页</p><p>emmmm, vote for 按需调页</p><p><br/></p><p>按需调页的性能</p><p>内存访问时间为$ma$, 设p为page fault的概率[$0\leq p \leq 1$]</p><p>有效访问时间$=(1-p)\times ma + p\times$page fault时间</p><p><br/></p><h1 id="3-页面置换"><a href="#3-页面置换" class="headerlink" title="3. 页面置换"></a>3. 页面置换</h1><p>页面置换的步骤</p><ul><li>查找所需页在磁盘上的位置</li><li>查找一个空闲帧<ul><li>如果有空闲帧，就使用它</li><li>如果没有空闲帧，就使用页置换算法来选择一个牺牲帧[victim frame]</li><li>将牺牲帧的内容写到磁盘上，改变页表和帧表[用dirty bit来控制是否写回]</li></ul></li><li>将所需页读入新空闲帧，改变页表和帧表</li><li>重启用户进程</li></ul><center><img src="image-20191202135842164.png" srcset="/img/loading.gif" alt="image-20191202135842164" style="zoom: 40%;" /></center><h2 id="3-1-FIFO"><a href="#3-1-FIFO" class="headerlink" title="3.1 FIFO"></a>3.1 FIFO</h2><center><img src="image-20191202140215811.png" srcset="/img/loading.gif" alt="image-20191202140215811" style="zoom:50%;" /></center><p>FIFO : 0虽然最近访问过，但是是first in的，<strong><em>FIFO的first in是只看谁最先进入memory</em></strong></p><p><br/></p><h2 id="3-2-最优置换"><a href="#3-2-最优置换" class="headerlink" title="3.2 最优置换"></a>3.2 最优置换</h2><p>开天眼，可以预测未来</p><p>置换在将来最晚被使用的页</p><center><img src="image-20191202154701416.png" srcset="/img/loading.gif" alt="image-20191202154701416" style="zoom:50%;" /></center><p><br/></p><h2 id="3-3-LRU页置换"><a href="#3-3-LRU页置换" class="headerlink" title="3.3 LRU页置换"></a>3.3 LRU页置换</h2><p>选择内存中最久没有引用的页面被置换。</p><p>这是局部性原理的合理近似，性能接近最佳算法</p><p>但是由于需要记录页面使用时间，硬件开销太大</p><center><img src="image-20191202155058918.png" srcset="/img/loading.gif" alt="image-20191202155058918" style="zoom:50%;" /></center><p><br/></p><p>实现方式：</p><ul><li><p>计数器: 每个页表关联一个使用时间域，并未CPU增加一个逻辑时钟或计数器。</p><p>对每次内存引用，计数器都会增加，时钟寄存器的内容被复制到对应页表项的使用时间域内。</p><p>This scheme requires </p><ul><li>a search of the page table to find the LRU page and a write to memory [to the time-of-use field in the page table] for each memory access. </li><li>The times must also be maintained when page tables are changed [due to CPU scheduling]. </li><li>Overflow of the clock must be considered.</li></ul></li><li><p>栈：keep a stack of page numbers. Whenever a page is referenced, it is removed from the stack and put on the top. 这样，most recently used page总是在top, least recently used page 总是在bottom。</p><p>可以实现为具有头尾指针的双向链表</p></li></ul><p><br/></p><h2 id="3-4-LRU-Approximation-Page-Replacement"><a href="#3-4-LRU-Approximation-Page-Replacement" class="headerlink" title="3.4 LRU-Approximation Page Replacement"></a>3.4 LRU-Approximation Page Replacement</h2><p>页表内的每个page table entry 都关联着一个引用位[reference bit]。每当引用一个页时[无论读写], 相应的page table entry的引用位就被置位</p><h3 id="A-Additional-Reference-Bits-Algorithm"><a href="#A-Additional-Reference-Bits-Algorithm" class="headerlink" title="A. Additional-Reference-Bits Algorithm"></a>A. Additional-Reference-Bits Algorithm</h3><p>We can keep an 8-bit byte for each page in a table in memory.用来存放8个时钟周期的引用位</p><ul><li>在规定时间间隔内，时钟定时器产生中断并将控制权转交给操作系统。</li><li>操作系统把每个页的引用位转移到8bits的最高位，其他位右移并抛弃最低位</li></ul><p>比如：</p><blockquote><p>如果移位寄存器内容是00000000，说明这个页在最近8个周期没有被使用过</p><p>如果移位寄存器内容是11111111，说明这个页在最近8个周期都被至少使用过一次</p><p>具有值11000100的移位寄存器的页比具有01110111的页更为最近被使用</p></blockquote><p>如果将这8个bits作为无符号整数，那么具有最小值的页就是least recently used</p><center><video id="video" controls="" preload="none" width="400"><source id="mp4" src="https://miaochenlu.github.io/2020/09/17/MemoryManagement/referencebit.mov">       <p>Your user agent does not support the HTML5 Video element.</p></video></center><h3 id="B-二次机会算法"><a href="#B-二次机会算法" class="headerlink" title="B. 二次机会算法"></a>B. 二次机会算法</h3><p>为了避免FIFO可能会把经常使用的页替换出去的问题，我们可以对它做一个简单的修改：对最老页面的R位进行检查。</p><ul><li>如果是0，那么这个页既老又没用，应该被立刻替换掉</li><li>如果是1，就清除这个位，把这个页放到页链表的尾端，修改它的装入时间让它就象刚装入的一样，然后继续搜索下一个FIFO页。</li></ul><center><video id="video" controls="" preload="none" width="400"><source id="mp4" src="https://miaochenlu.github.io/2020/09/17/MemoryManagement/secondchance.mov">       <p>Your user agent does not support the HTML5 Video element.</p></video></center><p><a href="http://netclass.csu.edu.cn/NCourse/hep086/chapter4/section4/4.4.4.htm" target="_blank" rel="noopener">second chance</a></p><center><video id="video" controls="" preload="none" width="400"><source id="mp4" src="https://miaochenlu.github.io/2020/09/17/MemoryManagement/clockreplace.mov"      <p>Your user agent does not support the HTML5 Video element.</p></video></center><h3 id="C-增强型二次机会算法"><a href="#C-增强型二次机会算法" class="headerlink" title="C. 增强型二次机会算法"></a>C. 增强型二次机会算法</h3><p>考虑到替换脏页需要将页从内存写回磁盘，所以脏页并不是比较好的替换选择</p><p>考虑[引用位, 修改位]的有序对</p><ul><li>[0, 0]最近既没有使用页没有修改—-置换的最佳页</li><li>[0, 1]最近没有使用但是被修改过—-不是很好，因为被置换需要写到磁盘</li><li>[1, 0]最近使用过但是没有修改—-他有可能很快又要被使用</li><li>[1, 1]最近使用过并且修改过—-他又可能很快又要被使用，并且置换之前需要将页写回磁盘</li></ul><p>每个有序对都代表了一个类，[0,0]是最小的类，[1, 0]类的页在它的R位被时钟中断清除后就成了[0,0]类。</p><center><video id="video" controls="" preload="none" width="400"><source id="mp4" src="https://miaochenlu.github.io/2020/09/17/MemoryManagement/advancesecondchance.mov">       <p>Your user agent does not support the HTML5 Video element.</p></video></center><p>从编号最小的非空类中挑选出一个页淘汰。注意在找到置换页之前，可能需要多次搜索整个循环队列</p><h2 id="3-5-页缓冲算法？？？？？"><a href="#3-5-页缓冲算法？？？？？" class="headerlink" title="3.5 页缓冲算法？？？？？"></a>3.5 页缓冲算法？？？？？</h2><p>通过被置换页面的缓冲，有机会找回刚被置换的页面</p><ul><li><p>被置换页面的选择和处理：用FIFO算法选择被置换页，把被置换的页面放入两个链表之一。即：如果页面未被修改，就将其归入到空闲页面链表的末尾，否则将其归入到已修改页面链表。</p></li><li><p>需要调入新的页面时，将新页面内容读入到空闲页面链表的第一项所指的页面，然后将第一项删除。</p></li><li><p>空闲页面和已修改页面，仍停留在内存中一段时间，如果这些页面被再次访问，这些页面还在内存中。</p></li><li><p>当已修改页面达到一定数目后，再将它们一起调出到外存，然后将它们归入空闲页面链表。</p></li></ul><p><br/></p><h1 id="4-帧分配"><a href="#4-帧分配" class="headerlink" title="4. 帧分配"></a>4. 帧分配</h1><p>如何在各个进程之间分配一定的空闲内存</p><h2 id="4-1-帧的最少数量"><a href="#4-1-帧的最少数量" class="headerlink" title="4.1 帧的最少数量"></a>4.1 帧的最少数量</h2><p>分配的帧不能超过可用帧的数量[除 非有页共享], 页必须分配至少最少数量的帧。</p><p>为什么要定最少帧数</p><blockquote><ul><li>性能: 随着分配给每个进程的帧数量的减少，页错误会增加，从而减慢进程的执行。</li></ul></blockquote><p>每个进程帧的最少数量是由体系结构决定的，而最大数量是由可用物理内存的数量来决定。</p><p><br/></p><h2 id="4-2-分配算法"><a href="#4-2-分配算法" class="headerlink" title="4.2 分配算法"></a>4.2 分配算法</h2><ul><li><p>平均分配</p><p>在n个进程之间分配m个帧，每个进程获得$\frac{m}{n}$帧</p></li><li><p>比例分配</p><p>各个进程需要不同数量的内存。</p><p>根据进程大小，将可用内存分配给每个进程。</p><p>设进程$p_i$的虚拟内存大小为$s_i$,定义$S=\sum s_i$</p><p>如果可用帧的数量为m,那么进程$p_i$可以分配到$ a_i$,   $a_i\approx \frac{s_i}{S}\times m$</p><p>调整$a_i$使得，最小数量$&lt;a_i&lt;$m</p></li></ul><p><br/></p><h2 id="4-3-全局分配和局部分配"><a href="#4-3-全局分配和局部分配" class="headerlink" title="4.3 全局分配和局部分配"></a>4.3 全局分配和局部分配</h2><ul><li><h3 id="全局置换"><a href="#全局置换" class="headerlink" title="全局置换"></a>全局置换</h3></li></ul><blockquote><p>允许一个进程从所有帧集合中选择一个置换帧，不管这个帧是否已经分配给其他进程</p></blockquote><p>例如：允许高优先级进程从低优先级进程中选择帧以便置换。这种方法允许高优先级进程增加其帧分配而以损失低优先级进程为代价。</p><p>优点：</p><blockquote><p>全局置换会有更好的系统吞吐量，且更为常用</p></blockquote><p>问题：</p><blockquote><p>进程不能控制其page fault率。一个进程的位于内存的页集合不但取决于该进程本身的调页行为，还取决于其他进程的调页行为。</p></blockquote><ul><li><h3 id="局部置换"><a href="#局部置换" class="headerlink" title="局部置换"></a>局部置换</h3></li></ul><blockquote><p>进程仅从自己的分配帧中进行选择</p></blockquote><p>优点：</p><blockquote><p>page fault数量可控</p></blockquote><p>问题：</p><blockquote><p>局部置换不能使用其他进程不常用的内粗，所以会阻碍一个进程。</p></blockquote><p><br/></p><h1 id="5-系统颠簸-Thrashing"><a href="#5-系统颠簸-Thrashing" class="headerlink" title="5. 系统颠簸[Thrashing]"></a>5. 系统颠簸[Thrashing]</h1><p>If a process does not have “enough” pages, the page-fault rate is very high. This leads to:</p><ul><li><p>很低的CPU利用率</p></li><li><p>误导OS以为有必要提高多任务的程度</p></li><li><p>误导OS装入更多作业，内存中驻留更多进程</p></li><li><p>于是，每个进程拥有的页帧数更少</p></li></ul><p>thrashing是page频繁的换入换出操作, 将导致严重的性能问题</p><center><img src="image-20191205135228155.png" srcset="/img/loading.gif" alt="image-20191205135228155" style="zoom:50%;" /></center><p><br/></p><h2 id="5-1-Working-set-model"><a href="#5-1-Working-set-model" class="headerlink" title="5.1 Working-set model"></a>5.1 Working-set model</h2><p>working-set model基于局部性的假设</p><p>$\Delta$定义为working set window的大小。</p><p>检查最近$\Delta$个页的引用。这最近$\Delta$个引用的页集合称为working set</p><p><br/></p><p>如果一个页正在使用中，那么它就在工作集合中。</p><p>如果这个页不再使用，那么它会在其上次引用的$\Delta$时间单位后从working set中删除。</p><p>也就是说，working set是程序局部的近似</p><center><img src="image-20191205140609132.png" srcset="/img/loading.gif" alt="image-20191205140609132" style="zoom:50%;" /></center><blockquote><p>举个例子, $\Delta=10$, 那么t1时刻的working set就是{1, 2, 5, 6, 7}</p><p>t2时刻的working set就是{3, 4}</p></blockquote><p>考虑每个进程工作集的大小，如果每个进程的工作集合为$WSS_i$, D是总的帧需求量</p><script type="math/tex; mode=display">D=\sum WSS_i</script><p>如果D&gt;m，那么就有的进程得不到足够的帧，就会出现颠簸</p><p>如何使用working-set model来handle thrashing呢？</p><blockquote><p>确定了$\Delta$后，操作系统跟踪每个进程的工作集合，并为进程分配大于其工作集合的帧数</p><ul><li>如果还有空闲帧，则可以启动另一个进程。</li><li>如果所有working set之和的增加超过了可用帧的总数，那么操作系统会选择暂停一个进程，该进程的页被写出，他的帧可以分配给其他进程，挂起的进程可以在以后重启。</li></ul></blockquote><h2 id="5-2-page-fault-frequency"><a href="#5-2-page-fault-frequency" class="headerlink" title="5.2 page fault frequency"></a>5.2 page fault frequency</h2><p>working set来控制thrashing并不灵活，一种更加直接的方法是页错误频率[page fault frequency, PFF]</p><p>当PFF太高时，说明进程需要更多帧，如果PFF太低，说明进程有太多帧。可以为PFF设置上限和下限。</p><ul><li><p>如果PFF超过上限，可以为进程分配更多的帧。如果没有可用帧，那么必须选择一个进程暂停，并将释放的帧分配给那些具有高PFF的进程</p></li><li><p>如果PFF低于下限，可以从进程中移走帧。</p></li></ul><p>可以直接测量和控制PFF来防止颠簸</p><center><img src="image-20191205142402546.png" srcset="/img/loading.gif" alt="image-20191205142402546" style="zoom:45%;" /></center>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer network--MAC子层</title>
    <link href="/2019/11/12/ComputerNetwork/MACLayer/"/>
    <url>/2019/11/12/ComputerNetwork/MACLayer/</url>
    
    <content type="html"><![CDATA[<p>计算机网络课程-MAC子层总结</p><a id="more"></a><style>  .page__header .header__brand path {    fill: rgba(255, 255, 255, .95);  }</style><p>网络链路可以分成两类</p><ul><li>点到点连接[PPP协议]</li><li>广播信道</li></ul><h1 id="1-信道分配问题"><a href="#1-信道分配问题" class="headerlink" title="1. 信道分配问题"></a>1. 信道分配问题</h1><h2 id="1-1静态信道分配"><a href="#1-1静态信道分配" class="headerlink" title="1.1静态信道分配"></a>1.1静态信道分配</h2><p>在多个竞争用户之间分配单个信道的传统做法是把信道容量拆开分给多个用户使用</p><h2 id="1-2-动态信道分配"><a href="#1-2-动态信道分配" class="headerlink" title="1.2 动态信道分配"></a>1.2 动态信道分配</h2><h3 id="1-2-1-关键假设"><a href="#1-2-1-关键假设" class="headerlink" title="1.2.1 关键假设"></a>1.2.1 关键假设</h3><ul><li><p>流量独立</p><p>模型由N个独立的站组成，每个站都有一个程序或者用户要传输的帧。在长度为$\Delta t$的间隔内，期望产生的帧数是$\lambda \Delta t$。这里的$\lambda$为常数(新帧的到达率)。</p></li><li><p><strong>单信道</strong></p><p>所有的通信都用这一个信道</p></li><li><p>冲突可观察</p><p>如果两帧同时传输，则他们在时间上就有重叠，产生混乱的信号，这就是冲突。所有的站都能检测到冲突。冲突的帧必须在以后再次被发送</p><p>[冲突的话会发送站点会检测到增强的信号</p></li><li><p>时间连续或分槽</p><p>时间可以假设连续：任意时刻都可以开始传输帧</p><p>时间可以分槽（离散）</p></li><li><p>载波侦听或不听</p></li></ul><h3 id="1-2-2-多路访问协议"><a href="#1-2-2-多路访问协议" class="headerlink" title="1.2.2 多路访问协议"></a>1.2.2 多路访问协议</h3><h4 id="i-纯ALOHA"><a href="#i-纯ALOHA" class="headerlink" title="i. 纯ALOHA"></a>i. 纯ALOHA</h4><p>思想:</p><blockquote><p>有数据要发就发送</p><p>如果帧破坏了，则发送方等待一个随机时间后再次发送</p></blockquote><p><img src="image-20191115204112604.png" srcset="/img/loading.gif" alt="image-20191115204112604" style="zoom:50%;" /></p><p>帧时[frame time]</p><blockquote><p>传输一个标准的、固定长度的帧需要的时间[帧的长度/比特率]</p></blockquote><p>假定站产生的新帧可以模型化为一个平均每“帧时”产生 N 个帧的泊松分布</p><p>出了新生成的帧外，每个站还会产生由于先前遭受冲突而重传的那些帧</p><p>进一步假设在每个“帧时”中，老帧和新帧合起来也符合泊松分布，每个帧时的平均帧数是G，显然$G\geq N$</p><p>参数定义</p><ul><li>帧时T[..frame length/bit rate]：发送一个标准长的帧所需的时间</li><li>吞吐率Throughput S：在一个帧时T内发送成功的平均帧数（0&lt;S&lt;1，S=1时信道利用率100%）</li><li>运载负载Offered load G：一个帧时T内所有通信站总共发送的帧平均值（包括原发和重发帧）（G≥S，G=S表示无冲突）</li><li>P0：一帧发送成功（未发生冲突）的概率，发送成功的分组在已发送分组的总数中所占的比例；公式：$S = G\times P0$</li></ul><p>如何计算P0</p><p>冲突危险期：2T[2个帧时]</p><p>在这个危险期，生成帧的均值为2G</p><p><img src="image-20191115204525493.png" srcset="/img/loading.gif" alt="image-20191115204525493" style="zoom:50%;" /><br><br/></p><p><img src="IMG_2DF27CD714C6-1.png" srcset="/img/loading.gif" alt="IMG_2DF27CD714C6-1" style="zoom: 33%;" /><br>在2T时间内发送成功的概率=2T时间内没有其他帧生成的概率</p><p>$P_0=\frac{(G\cdot 2)^0e^{-G\cdot 2}}{0!}=e^{-2G}$</p><p>$S=GP_0=Ge^{-2G}$</p><h4 id="ii-分槽ALOHA"><a href="#ii-分槽ALOHA" class="headerlink" title="ii. 分槽ALOHA"></a>ii. 分槽ALOHA</h4><p>思想</p><blockquote><p>时间离散化</p><p>必须要等到一个时间槽点开始时刻才能发送帧</p></blockquote><p><img src="image-20191115210524429.png" srcset="/img/loading.gif" alt="image-20191115210524429" style="zoom:50%;" /><br>性能如何？</p><p>只需要在当前帧时没有其他站发送帧就可以保证一个帧发送成功</p><p>$P_0=\frac{(G\cdot 1)^0e^{-G\cdot 1}}{0!}=e^{-G}$</p><p>$S=GP_0=Ge^{-G}$</p><p><img src="image-20191115210722147.png" srcset="/img/loading.gif" alt="image-20191115210722147" style="zoom:50%;" /></p><h3 id="1-2-3-载波侦听多路访问协议"><a href="#1-2-3-载波侦听多路访问协议" class="headerlink" title="1.2.3 载波侦听多路访问协议"></a>1.2.3 载波侦听多路访问协议</h3><p>上面两种属于不听就说</p><p>下面我们可以尝试先听再说的方式[发送帧之前检测信道中是否有数据在发送]</p><h4 id="i-CSMA-Carrier-sense-multiple-access-without-CD-collision-detection"><a href="#i-CSMA-Carrier-sense-multiple-access-without-CD-collision-detection" class="headerlink" title="i. CSMA[Carrier sense multiple access] without CD[collision detection]"></a>i. CSMA[Carrier sense multiple access] without CD[collision detection]</h4><p>A. Persistent CSMA[1-persistent]</p><ul><li>If the channel is <strong>idle</strong>, the station <strong>transmits</strong> a frame. </li><li>If the channel is <strong>busy</strong>, the station <strong>waits</strong> until it becomes idle. Then the station transmits a frame. </li><li>If a <strong>collision occurs</strong>, the station <strong>waits a random</strong> <strong>amount of time</strong> and starts all over again. </li></ul><p>这个协议也叫1-persistent，因为<strong>不停地去sense信道</strong>，只要信道空闲就能发现。当新到空闲时，他传输数据的概率为1。问题是，如果两个station都在等待信道，那么当信道空闲时，他们同时发送，这必然产生冲突</p><p><br/></p><p>B. Non-persistent CSMA</p><ul><li><p>If the channel is <strong>idle</strong>, the station <strong>transmits</strong> a frame. </p></li><li><p>If the channel is <strong>in use</strong>, the station <strong>does not</strong> continually sense it. Instead, it <strong>waits a random</strong> <strong>period of time</strong> and then repeats the algorithm. </p></li><li><p>If a <strong>collision occurs</strong>, the station <strong>waits a random</strong> <strong>amount of time</strong> and starts all over again. </p></li></ul><p>这种方式信道利用率比1-persistent高，但是比1-persistent的delay时间长</p><p><br/></p><p>C. p-persistent CSMA</p><p> <strong>Applied to slotted channels</strong></p><ul><li>If the channel is <strong>idle</strong>, it <strong>transmits with a probability</strong> <strong>p</strong>. With a probability <em>q=1-p</em>, it defers until the next slot. </li><li>If that slot is also idle, it either transmits or defers again, with probabilities <em>p</em> and <em>q</em>. </li><li>This process is repeated until either the frame has been transmitted or another station has begun transmitting. </li><li>If the channel is <strong>busy</strong>, it <strong>waits until the next slot</strong> and applies the above algorithm.</li></ul><p><img src="image-20191115220004447.png" srcset="/img/loading.gif" alt="image-20191115220004447" style="zoom: 25%;" /></p><h4 id="ii-CSMA-with-CD"><a href="#ii-CSMA-with-CD" class="headerlink" title="ii. CSMA with CD"></a>ii. CSMA with CD</h4><p>思想</p><blockquote><p>As soon as stations detect a collision, they stop their transmissions</p></blockquote><p>CSMA/CD可以出于以下几种状态</p><ul><li>contention</li><li>transmission</li><li>idle</li></ul><p><img src="image-20191115220550462.png" srcset="/img/loading.gif" alt="image-20191115220550462" style="zoom: 33%;" /><br>竞争算法：</p><blockquote><p>假设两个站同时在t0时刻开始传送数据，他们需要多长时间才能意识到发生冲突呢？ 2$\tau$</p><p>因此，将CSMA/CD竞争看成一个分槽ALOHA系统，时间槽宽度为$2\tau$</p><p>CSMA/CD 和分槽 ALOHA 的区别在于， 只有一个站能用来传输的时间槽（即信道被抓住了）<strong><em>后面紧跟的那些时间槽被用来传输该帧的其余部分</em></strong>。如果帧时相比传播时间长很多，这种差异将能大大提高协议的性能。</p></blockquote><p><img src="IMG_D9933EA1BF2A-1.png" srcset="/img/loading.gif" alt="IMG_D9933EA1BF2A-1" style="zoom: 33%;" /></p><h3 id="1-2-4-无冲突协议"><a href="#1-2-4-无冲突协议" class="headerlink" title="1.2.4 无冲突协议"></a>1.2.4 无冲突协议</h3><h4 id="i-位图协议"><a href="#i-位图协议" class="headerlink" title="i. 位图协议"></a>i. 位图协议</h4><p>一共有N个station，每个竞争期包含N个槽。如果0号station有一帧要发送，那么他在0号槽中传输1位。这个槽不允许其他station发送。</p><p>当所有N个槽都经过后，每个站都知道哪些站希望传送数据。</p><p>这是，按照数字顺序开始传送数据</p><p><img src="image-20191115224154892.png" srcset="/img/loading.gif" alt="image-20191115224154892" style="zoom:50%;" /><br>每个站都同意下一个是谁传输，所以永远不会发生冲突</p><p>当最后一个就绪站传送完它的帧后，另一个N位竞争期又开始了</p><p>Notations</p><ul><li>The time unit is one contention bit </li><li><em>N</em>: contention period</li><li><em>d</em>: data frame length </li></ul><p>性能分析</p><ul><li>low load</li></ul><blockquote><ul><li>for low-numbered stations ,比如0，1</li></ul><p>如果当这个station做好发送数据的准备时，当前槽出于位图中间的某个地方，那么这个station需要等待完成当前扫描的N/2个槽，在等待完成下一次扫描的另外N个槽，然后才能开始传输数据</p><p>如果处于开头的话，一种情况是刚好轮到他的槽，那么等待N就可以；一种情况是错过他的槽，那么他要等过这N次以及下个N个槽。平均为1.5</p><p>等待时间为1.5N</p><ul><li>for high-numbered stations, 比如上图6,7</li></ul><p>要么刚好轮到他不等，要么刚好错过他等N</p><p>平均等待0.5N个槽</p></blockquote><p>平均而言，delay for all stations is N</p><p>信道利用率为: $\frac{d}{N+d}$ 每一帧的额外开销是N位，数据长度为d位</p><ul><li>high load</li></ul><blockquote><p>the 𝑁 bit contention period is distributed over 𝑁 frames, yielding an overhead of only 1 bit per frame, </p></blockquote><p>the efficiency: $\frac{𝑑}{d + 1}$ </p><h4 id="ii-token-passing"><a href="#ii-token-passing" class="headerlink" title="ii. token passing"></a>ii. token passing</h4><p>令牌代表发送权限，令牌以预定义的顺序从一个站传到下一个站</p><p>如果站有个等待传输的帧队列，当他接收到令牌就可以发送帧，然后再把令牌传递到下一站；如果没有帧要传，则只是简单把令牌传递下去</p><p><img src="image-20191115233333760.png" srcset="/img/loading.gif" alt="image-20191115233333760" style="zoom:50%;" /></p><h4 id="iii-Binary-Countdown"><a href="#iii-Binary-Countdown" class="headerlink" title="iii. Binary Countdown"></a>iii. Binary Countdown</h4><h3 id="1-2-5-有限竞争协议"><a href="#1-2-5-有限竞争协议" class="headerlink" title="1.2.5 有限竞争协议"></a>1.2.5 有限竞争协议</h3><p>目前为止</p><ul><li>Methods with contention <ul><li><strong>Under</strong> <strong>low</strong> <strong>load</strong>, the contention method (i.e., pure or slotted ALOHA, CSMA) is preferable due to its low delay.  </li><li><strong>Under</strong> <strong>high</strong> <strong>load</strong>, the contention method becomes increasingly less efficient. </li></ul></li><li>Methods without contention <ul><li>Under low load, the collision-free method has high delay. </li><li>Under high load, the collision-free method becomes increasingly more efficient. </li></ul></li></ul><p>综合他们的优点缺点，提出limited-contention protocols</p><p>有限竞争协议在低负载下来用竞争的做法而提供较短的延迟，但在高负载下来用无冲突技术， 从而获得良好的信道效率</p><h4 id="Adaptive-Tree-Walk"><a href="#Adaptive-Tree-Walk" class="headerlink" title="Adaptive Tree Walk"></a>Adaptive Tree Walk</h4><p>把站看作二叉树的<strong>叶节点</strong></p><p>在一次成功传送之后的第一个竞争槽，即 0 号槽中，允许所有的站尝试获取信道。</p><p>如果它们之中的某一个获得了信道，则很好；如果发生了冲突，则在1号槽中， 只有位于树中 2 号节点之下的那些站才可以参与竞争。</p><p>如果其中的某个站获得了信道，则 在该站发送完一帧之后的那个槽被保留给位于节点 3 下面的那些站。</p><p>另一方面，如果节点 2 下面的两个或者多个站都要传输数据，则在 1 号槽中就会发生冲突，此时，下一个槽， 即 2 号槽就由位于节点 4 下面的站来竞争。</p><p><img src="image-20191115234633276.png" srcset="/img/loading.gif" alt="image-20191115234633276" style="zoom:50%;" /></p><h3 id="1-2-6-无限局域网协议"><a href="#1-2-6-无限局域网协议" class="headerlink" title="1.2.6 无限局域网协议"></a>1.2.6 无限局域网协议</h3><p>假设每个无线电发射器有某个固定的传播范围，用一个圆形覆盖区域表示，在这区域内的另一个站可以侦听并接收该站的传输</p><h4 id="隐藏终端问题"><a href="#隐藏终端问题" class="headerlink" title="隐藏终端问题"></a>隐藏终端问题</h4><blockquote><p>假设有3无线通信站ABC如下所示：<br>A        B         - C </p><p>其中B在C的无线电波范围内，但A不在C的无线电波范围内。此时C正在向B传送数据，而A也试图向B传送数据。此时，A不能够监听到B正在忙（因为A在监听信道的时候什么也听不到，所以它会错误的认为此时可以向B传送数据了）。如果A向B传送数据，则将导致错误。此即隐藏站问题。其中C是A的隐藏站。</p></blockquote><h4 id="暴露终端问题"><a href="#暴露终端问题" class="headerlink" title="暴露终端问题"></a>暴露终端问题</h4><blockquote><p>假设有3无线通信站ABC如下所示：<br>-A        B          C </p><p>其中B在A的无线电波范围内，但C不在A的无线电波范围内。此时A正在传送数据（向除B以外的某通信站），而B希望给C发送数据，但是错误地认为该传送过程将会失败（因为B会监听到一次传输，所以它会错误地认为此时不能向C发送数据）。此即暴露站问题。其中A是B的暴露站</p></blockquote><h4 id="冲突避免多路访问（MACA-Multiple-Access-with-Collision-Avoidance"><a href="#冲突避免多路访问（MACA-Multiple-Access-with-Collision-Avoidance" class="headerlink" title="冲突避免多路访问（MACA, Multiple Access with Collision Avoidance)"></a>冲突避免多路访问（MACA, Multiple Access with Collision Avoidance)</h4><p><img src="image-20191116001108257.png" srcset="/img/loading.gif" alt="image-20191116001108257" style="zoom:50%;" /></p><p>考虑A如何向B发送一帧。 </p><blockquote><ul><li><p>A首先给B发送一 个 RTS (Request To Send帧)，这个短帧 (30 字节）包含了随后将要发送的数据帧的长度</p></li><li><p>然后， B 用一个 CTS (Clear to Send ）作为应答， 此 CTS 帧也包含了数据长度（从 RTS 帧中复制过来）。 A 在收到了CTS 帧之后便开始传输。</p></li></ul></blockquote><p>现在我们来看，如果其他站也听到了这些帧，它们会如何反应。</p><blockquote><ul><li>如果一个站听到了 RTS 帧，那么它一定离 A 很近，它必须保持沉默，至少等待足够长的时间以便在无冲突情况下 CTS 被返回给 A</li><li>如果一个站听到了 CTS ，则它一定离 B 很近，在接下来的数据传送过程 中它必须一直保持沉默，只要检查 CTS 帧，该站就可以知道数据帧的长度（即数据传输要持续多久）。</li></ul></blockquote><p>但是这样仍然可能发生冲突：B 和 C 可能同时给 A 发送 RTS</p><p>这种方法对隐藏终端比较有效，无助于暴露终端问题</p><h1 id="2-以太网"><a href="#2-以太网" class="headerlink" title="2. 以太网"></a>2. 以太网</h1><h2 id="2-1-经典以太网物理层"><a href="#2-1-经典以太网物理层" class="headerlink" title="2.1 经典以太网物理层"></a>2.1 经典以太网物理层</h2><p><img src="image-20191116182110572.png" srcset="/img/loading.gif" alt="image-20191116182110572" style="zoom:50%;" /></p><p>采用Machester encoding</p><p>Differential Manchester encoding :</p><p>时钟的频率是比特率的两倍，也就是在一个bit 时间内，时钟会产生一次跳变。时钟XOR bit，产生输出</p><p><img src="image-20191116183235764.png" srcset="/img/loading.gif" alt="image-20191116183235764" style="zoom:50%;" /></p><blockquote><p>第一个bit时间t内，传输的bit是1，时钟在[0,t/2]内是0，与bit 1异或，编码成1;</p><p>在[t/2, t]内时钟跳变到1，与bit 0异或，编码成0.</p><p>因此我们在第一个bit时间看到的编码先是1后翻转到0</p></blockquote><p>问题：需要两倍于NRZ的带宽，一个bit时间他要传输两个信号</p><h2 id="2-2-经典以太网MAC子层协议"><a href="#2-2-经典以太网MAC子层协议" class="headerlink" title="2.2 经典以太网MAC子层协议"></a>2.2 经典以太网MAC子层协议</h2><p><img src="image-20191116183434635.png" srcset="/img/loading.gif" alt="image-20191116183434635" style="zoom:50%;" /></p><p><img src="IMG_2710(20191116-184052).png" srcset="/img/loading.gif" alt="IMG_2710(20191116-184052)" style="zoom: 33%;" /></p><p>这里有效帧长必须&gt;=64字节</p><p>减去目的地址原地址类型和checksum之后，数据部分部分&gt;=46字节</p><blockquote><p>因为争用期为$2\tau$，通常取为51.2us</p><p>对于10Mb/s以太网，在争用期可以发送512bit，也就是64字节</p><p>使用CSMA/CD, 直到信道空闲才会发送帧</p><p>如果两个站同时发送数据，则在$2\tau$时间内会检测到冲突。也就是在前64个字节就可以检测到冲突。如果前64个字节不冲突，则就不会冲突。</p></blockquote><h3 id="二进制指数后退-binary-exponential-backoff-的CSMA-CA"><a href="#二进制指数后退-binary-exponential-backoff-的CSMA-CA" class="headerlink" title="二进制指数后退[binary exponential backoff]的CSMA/CA"></a>二进制指数后退[binary exponential backoff]的CSMA/CA</h3><p>这个协议确定了随机等待时间</p><p>一个时间槽为$2\tau$, 基本退避时间为$2\tau$</p><p>第一次冲突发生后，每个站随机等待 0 个或者 1 个时间槽，之后再重试发送。如果两个站冲突之后选择了同一个随机数，那么它们将再次冲突。在第二次冲突后，每个站随机选择等待0、1、2或3个时间槽 。如果第三次冲突又发生了（发生的概率为 0.25 ），则下一次等待的时间槽数从 0 到 $2^3-1$ 之间随机选择。</p><p>达到 10 次冲突之后，随机数的选择区间被固定在最大值 1023 ，以后不再增加。 在 16 次冲突之后，控制器放弃努力，并给计算机返回一个失败报告 。</p><p>总而言之，如下</p><p><img src="IMG_D69A5042B9FC-1%202.png" srcset="/img/loading.gif" alt="IMG_D69A5042B9FC-1 2" style="zoom:76%;" /></p><p>实质：</p><blockquote><p> 冲突的次数大概能确定要发送的站的数量，二进制退避快速收敛到适应的数量</p></blockquote><p><br/></p><h2 id="2-3-Switched-Ethernet交换式以太网"><a href="#2-3-Switched-Ethernet交换式以太网" class="headerlink" title="2.3 Switched Ethernet交换式以太网"></a>2.3 Switched Ethernet交换式以太网</h2><p>在集线器中，所有站都位于同一个冲突域 (<strong><em>collision domain</em></strong>), 它们必须使用 CSMA/CD 算法来调度各自的传输。在交换机中，每个端口有自己独立的冲突域。</p><p>In a hub, all stations are in the same collision domain; while in a switch, each portis a collision domain.</p><p>通常情况下，电缆是全双工的[同时允许两个方向发送数据]，站和端口可以同时往电缆上发送帧，根本无须担心其他站或者端口。现在冲突不可能发生，因而 CSMA/CD 也就不需要了。然后，如果电缆是半双工的[同时只允许一个方向发送数据]，则站和端口必须以通常的 CSMA/CD 方式竞争传输。</p><p><img src="my_1568281840_ZK4myJNWO8.png" srcset="/img/loading.gif" alt="_1568281840_ZK4myJNWO8" style="zoom:67%;" /></p><blockquote><p>交换机的性能优于集线器有两方面的原因。</p><ul><li>由于没有冲突，容量的使用更为有效。</li><li>有了交换机可以同时发送多个帧（由不同的站发出〉。这些帧到达交换机端口井穿过交换机背板输出到适当的端口。然而，由于两帧可能在同一时间去往同一个输出端口，交换机必须有缓冲，以便它暂时把输入帧排入队列直到帧被传输到输出端口。</li></ul></blockquote><p>不可能做到的。系统总吞吐量通常可以提高一个数量级，主要取决于端口数目和流量模式。</p><h2 id="2-4-Fastethernet-100Mbps"><a href="#2-4-Fastethernet-100Mbps" class="headerlink" title="2.4 Fastethernet[100Mbps]"></a>2.4 Fastethernet[100Mbps]</h2><p>802.3u</p><p><img src="image-20191231000041449.png" srcset="/img/loading.gif" alt="image-20191231000041449" style="zoom:50%;" /></p><h2 id="2-5-Gigabit-Ethernet-1Gbps"><a href="#2-5-Gigabit-Ethernet-1Gbps" class="headerlink" title="2.5 Gigabit Ethernet[1Gbps]"></a>2.5 Gigabit Ethernet[1Gbps]</h2><p><img src="image-20191231000139476.png" srcset="/img/loading.gif" alt="image-20191231000139476" style="zoom:50%;" /></p><h2 id="2-6-10-Gigabit-Ethernet-10Gbps"><a href="#2-6-10-Gigabit-Ethernet-10Gbps" class="headerlink" title="2.6 10 Gigabit Ethernet[10Gbps]"></a>2.6 10 Gigabit Ethernet[10Gbps]</h2><p><img src="image-20191231000528967.png" srcset="/img/loading.gif" alt="image-20191231000528967" style="zoom:50%;" /></p><h1 id="3-无限局域网"><a href="#3-无限局域网" class="headerlink" title="3. 无限局域网"></a>3. 无限局域网</h1><h2 id="3-1-The-802-11-Architecture-and-Protocol-Stack"><a href="#3-1-The-802-11-Architecture-and-Protocol-Stack" class="headerlink" title="3.1 The 802.11: Architecture and Protocol Stack"></a>3.1 The 802.11: Architecture and Protocol Stack</h2><p><img src="image-20191231001119031.png" srcset="/img/loading.gif" alt="image-20191231001119031" style="zoom:50%;" /></p><p>802.11 网络的使用模式有两种：</p><blockquote><ul><li>最普遍使用的把客户端（比如笔记本电脑和智能手机客户端），连接到另一个网络（比如公司内联网或 Internet ）。这种使用模式如图 (a) 所示。在有架构模式下，每个客户端与一个接入点（ AP, Access Point ）关联，该接入点又与其他网络连接。客户端发送和接收数据包都要通过 AP 进行。几个接入点可通过一个称为分布式系统（ distribution system ）的有线网络连接在一起，形成一个扩展的 802.11 网络。 在这种情况下，客户端可以通过它们的接入点向其他客户端发送帧。</li><li>另一种模式，如图 4-23 (b ）所示，是一种自组织网络（ ad hoc network ）。这种模式下 的网络由一组相互关联的计算机组成，它们相互之间可以直接向对方发送帧。这里没有接入点。由于 Internet 接入是无线的杀手级应用，自组织网络并没有那么受欢迎。</li></ul></blockquote><p><img src="image-20191231222744244.png" srcset="/img/loading.gif" alt="image-20191231222744244" style="zoom:50%;" /></p><p>所有 802 协议的数据链路层分为两个或更多个子层。在 802.11 中 </p><blockquote><ul><li>介质访问控制（MAC, Medium Access Control) 子层决定如何分配信道，也就是说下一个谁可以发送。</li><li>在它上方的是逻辑链路控制（ LLC, Logical Link Control) 子层，它的工作是隐藏 802 系列协议之间的差异，使它们在网络层看来并无差别。</li></ul></blockquote><h2 id="3-2-The-802-11-Physical-Protocol"><a href="#3-2-The-802-11-Physical-Protocol" class="headerlink" title="3.2 The 802.11: Physical Protocol"></a>3.2 The 802.11: Physical Protocol</h2><ul><li>802.11: FHSS(Frequency Hopping Spread Specture) and Infrared[2.4Mbps]</li><li>802.11a: OFDM(Orthogonal Frequency Division Multiplexing) at 5GHz (54Mbps)</li><li>802.11b: HR-DSSS (High Rate Direct Sequence Spread Spectrum) (11Mbps)</li><li>802.11g: OFDM(Orthogonal Frequency Division Multiplexing) at 2.4 GHz (54Mbps)</li><li>802.11n: MIMO OFDM (Multiple-Input Multiple-Output Orthogonal Frequency Division Multiplexing) at multiple frequencies. (600Mbps)</li></ul><h2 id="3-3-The-802-11-Sublayer-Protocol"><a href="#3-3-The-802-11-Sublayer-Protocol" class="headerlink" title="3.3 The 802.11: Sublayer Protocol"></a>3.3 The 802.11: Sublayer Protocol</h2><h3 id="A-问题1"><a href="#A-问题1" class="headerlink" title="A. 问题1"></a>A. 问题1</h3><blockquote><p>无线电几乎总是半双工的，这意味着它们不能在一个频率上传输的同时侦听该频率上的突发噪声。接收到的信号很容易变得比发射信号弱上一百万倍，因此它无法在同一时间听到这么微弱的信号。而在以太网中，一个站只要等到介质空闲，然后开始传输。 如果它没有在发送的前 64 个字节期间收到返回的突发噪声，则几乎可以肯定帧能正确地传送出去。但对于无线介质，这种冲突检测机制根本不起作用。</p><p>因为冲突检测不起作用，所以802.11尝试避免冲突。采用的协议为带有冲突避免的CSMA/CA，CSMA with collision avoidance.</p></blockquote><h4 id="解决方式：CSMA-CA"><a href="#解决方式：CSMA-CA" class="headerlink" title="解决方式：CSMA/CA"></a>解决方式：CSMA/CA</h4><ul><li><p>通过侦听确定在一个很短的时间内[这段时间称为 <strong><em>DIFS</em></strong> ]没有信号：然后倒计数空闲时间槽</p></li><li><p>当有帧在发送时暂停该计数器：当计数器递减到 0, 该站就发送自己的帧。</p><ul><li>如果帧发送成功，目标站立即发送一个短确认。</li><li>如果没有收到确认， 则可推断出传输发生了错误，无论是冲突或是其他什么错。在这种情况下，发送方要加倍后退选择的时间槽数，再重新试图发送。如此反复，连续像以太网那样以指数后退，直到成功发送帧或达到重传的最大次数。</li></ul></li></ul><blockquote><p>下图给出了一个发送帧的时序例子。 </p><p>A 站首先发出一个帧。</p><p>当 A 发送时， B 站和 C 站准备就绪发送。它们看到信道正忙，便等待它变成空闲。不久， A 收到一个确认，信道进入空闲状态。</p><p>然而，不是两个站都发出一帧从而立即产生冲突，而是 B 站和 C 站都执行后退算法。 C 站选择了一个较短的后退时间，因而先获得发送权。 B 站侦听到 C 在使用信道时<u>暂停自己的倒计时</u>，并在 C 收到确认之后立即<u>恢复倒计时</u>。一旦 B 完成了后退，立即发送自己的帧。</p></blockquote><p><img src="image-20191231223848359.png" srcset="/img/loading.gif" alt="image-20191231223848359" style="zoom:50%;" /></p><p>802.11和以太网有两个主要区别</p><ul><li>首先，早期的后退有助于避免冲突。冲突避免在无线传输中非常重要，即使只发生一个冲突因为整个帧都被传输了出去，因此冲突的代价非常昂贵。</li><li>其次，利用确认来推断是否发生冲突，因为冲突无法被检测出来。</li></ul><p>这种操作模式称为<strong><em><u>分布式协调功能 DCF Distributed Coordination Function</u></em></strong>。因为每个站都独立行事，没有任何一种中央控制机制。[…标准还包括一个可选的操作模式，称为点协调功能（ PCF, Point Coordination Function）。在这种模式下， AP 控制自己覆盖范围内的一切活动。</p><h3 id="B-问题2-隐藏暴露终端问题"><a href="#B-问题2-隐藏暴露终端问题" class="headerlink" title="B. 问题2: 隐藏暴露终端问题"></a>B. 问题2: 隐藏暴露终端问题</h3><p>为了减少究竟哪个站在发送的模糊不清， 802.11 定义信道侦听包括物理侦听和虚拟侦听两部分。</p><ul><li>物理侦听只是简单地检查介质，看是否存在有效的信号</li><li>虚拟侦听，每个站可以保留一个信道何时要用的逻辑记录，这是通过跟踪网络分配向量（ NAV, Network Allocation Vector）获得的。每个帧携带一个 NAV字段，说明这个帧所属的一系列数据将传输多长时间。无意中听到这个帧的站就知道无论自己是否能够侦听到物理信号，由 NAV所指出的时间段信道一定是繁忙的。例如，一个数据帧的 NAV 给出了发送一个确认所需要的时间。所有听到该数据帧的站将在发送确认期间推迟发送，而不管它们是否能听到确认的发送。</li></ul><p>可选的 RTS/CTS 机制使用 NAV 来防止隐藏终端在同一时间发送。</p><blockquote><p>在下面这个例子中， A 想给 B 发送， C 是 A 范围内的一个站（也有可能在 B 的范围内，但 这并不重要）。 D 在 B 范围内，但不在 A 的范围内。</p><p>C A B  D</p></blockquote><p><img src="image-20191231233241805.png" srcset="/img/loading.gif" alt="image-20191231233241805" style="zoom:50%;" /></p><p>具体的</p><p>对A和B来说</p><blockquote><ul><li>该协议开始于当 A 决定向 B 发送数据时。 A 首先给 B 发送一个 RTS 帧，请求对方允许自己发送一个帧给它。</li><li>如果 B 接收到这个请求，它就以 CTS 帧作为应答，表明信道被清除可以发送。</li><li>一旦收到 CTS 帧， A 就发送数据帧，井启动一个 ACK 计时器。</li><li>当正确的数据帧到达后， B 用一个 ACK 帧回复 A，完成此次交流。如果 A 的 ACK 计时器超时前， ACK 没有返回，则可视为发生了一个冲突，经过一次后退整个协议重新开始运行。</li></ul></blockquote><p>对C和D来说</p><blockquote><p>C 和 D 的角度来看这次数据交流。 C 在 A 的范围内，因此它可能会收到 RTS 帧。</p><p>如果收到了，它就意识到很快有人要发送数据。从 RTS 请求帧提供的信息，可以估算出数据序列将需要传多长时间，包括最后的 ACK。因此，它停止传输任何东西，直到此次数据交换完成。它通过更新自己的 NAV 记录表明信道正忙。</p><p>D 无法听到 RTS ，但它确实听到了 CTS ，所以它也更新自己的 NAV。 请注意， NAV 信号是不传输的，它们只是由站内部使用，提醒自己保留一定时间内的安静。</p></blockquote><ul><li>可靠性： 无线网络环境嘈杂，并且不可靠，这是因为相当大一部分要受到来自其他种类设备的干扰</li></ul><blockquote><p>增加传输成功概率所用的策略是</p><ul><li><p>降低传输速率。在一个给定的信噪比环境下，速度放慢可以使用更健壮的调制解调技术，帧就越有可能被正确接收。</p></li><li><p>发送短帧。考虑任何一位都有可能出错，短帧每一位都不出错的概率比长帧高</p></li></ul></blockquote><ul><li>节省电源</li><li>服务质量</li></ul><blockquote><p>扩展了 CSMA/CA，并且仔细定义帧之间的各种时间间隔。 一帧发出去后，需要保持一段特定时间的空闲以便检查信道不在被用，然后任何站才可以发送帧。</p><p>这里的关键就在于<strong><em><u>为不同类型的帧确定不同的时间间隔</u></em></strong>。</p><p>5 个时间间隔如下图。常规的数据帧之间的间隔称为 DCF 帧间隔 [DIFS, DCF InterFrame Spacing ]。任何站都可以在介质空闲 DIFS 后尝试抓取信道发送一个新帧。采用通常的竞争规则，如果发生冲突或许还需要二进制指数后退。最短的间隔是短帧间间隔( SIFS, Short InterFrame Spacing ）。它允许一次对话的各方具有优先抓住信道的机会。例子 包括让接收方发送 ACK、诸如 RTS 和 CTS 的其他控制帧序列， 或者让发送方突发一系列 段。发送方只需等待 SIFS 即可发送下一段，这样做是为了阻止一次数据交流中间被其他站 横插一帧。</p></blockquote><p><img src="image-20200101001413274.png" srcset="/img/loading.gif" alt="image-20200101001413274" style="zoom:50%;" /></p><blockquote><ul><li><p>最短的间隔是短帧间间隔( SIFS, Short InterFrame Spacing ）。它允许一次对话的各方具有优先抓住信道的机会</p></li><li><p>常规的数据帧之间的间隔称为 DCF 帧间隔 (DIFS, DCF InterFrame Spacing ）。任何站都可以在介质空闲 DIFS 后尝试抓取信道发送一个新帧</p></li><li>两个仲裁帧间空间（ AIFS, Arbitration lnterFrame Space ）间隔显示了两个不同优先级 的例子。短的时间间隔 AIFS1 小于 DIFS ，但比 SIFS 长。较长的时间间隔 AIFS4 比 DIFS 还大</li><li>扩展帧间间隔 （EIFS, Extended InterFrame Spacing ） ，仅用于一个站刚刚收到坏帧或未知帧后报告问题</li></ul></blockquote><h2 id="3-4-802-11帧结构"><a href="#3-4-802-11帧结构" class="headerlink" title="3.4 802.11帧结构"></a>3.4 802.11帧结构</h2><p>The 802.11 standard defines three different classes of frames:</p><ul><li><p>Data</p></li><li><p>Control</p></li><li><p>Management</p></li></ul><p><img src="image-20200101005700537.png" srcset="/img/loading.gif" alt="image-20200101005700537" style="zoom:40%;" /></p><h1 id="4-Data-link-layer-Switching"><a href="#4-Data-link-layer-Switching" class="headerlink" title="4. Data link layer Switching"></a>4. Data link layer Switching</h1><p>网桥工作在<strong><em>数据链路层</em></strong>，因此它们通过检查数据链路层地址来转发帧。</p><h2 id="4-1-Uses-of-Bridges"><a href="#4-1-Uses-of-Bridges" class="headerlink" title="4.1 Uses of Bridges"></a>4.1 Uses of Bridges</h2><p>Why bridges are used?</p><ul><li><p>Different organizations have different LANs, but need communicate.</p></li><li><p>Different locations have different LANs. Using bridges are cost effective than using a centralized switch.</p></li><li><p>Multiple LANs are used to accommodate the load.</p></li></ul><p><img src="image-20200101010533214.png" srcset="/img/loading.gif" alt="image-20200101010533214" style="zoom:50%;" /></p><h2 id="4-2-Learning-Bridges"><a href="#4-2-Learning-Bridges" class="headerlink" title="4.2 Learning Bridges"></a>4.2 Learning Bridges</h2><p>所有附在网桥同一端口的站都属于<strong><em><u>同一个冲突域</u></em></strong>，该冲突域和其他端口的冲突域是不同。如果存在多个站，例如传统的以太网、集线器或半双工链路，那么帧的发送需要用到 CSMA/CD 协议。</p><p>两个局域网桥接在一起的拓扑结构分两种情况</p><ul><li>左侧两个多点局域网，比如经典以太网通过一个特殊的站连接在一起，这个站就是同属于两个局域网的网桥。</li><li>在右侧，局域网用点到点电缆连接在一起，包括一个集线器。</li></ul><p><img src="image-20200101010628782.png" srcset="/img/loading.gif" alt="image-20200101010628782" style="zoom:50%;" /></p><p>网桥算法</p><ul><li><p>When the first bridges are first plugged in, all the hash tables are empty. None of the bridges know where any of the destinations are, so they use the <strong><em>flooding algorithm</em></strong>.对于每个发向未知目 标地址的入境帧，网桥将它输出到所有的端口，但它来的那个输入端口除外</p></li><li><p>As time goes on, the bridges learn where destinations are. (<strong><em>backward learning</em></strong>)网桥可以看得到每个端口上发送的所有帧。通过检查这些帧的源地址， 网桥就可获知通过那个端口能访问到哪些机器。例如，上图(b)中，网桥 B1看到端口 3 上的一帧来自站 C，那么它就知道通过端口 3 一定能到达 C ，因此它就在哈希表 中构造一项。以后所有抵达 B1 要去 C 的帧都将被转发到端口 3。</p></li><li><p>Whenever a frame whose source is already in the table arrives, its entry is updated with the current time. (time updating) </p></li><li>Periodically, a process in the bridge scans the hash and purges all entries more than a few minutes old. (Aging)</li></ul><p>对于一个入境帧，它在网桥中的路由过程取决于它从哪个端口来（源端口），以及它要往哪个目标地址去（目标端口）。整个转发过程如下： </p><ol><li><p>如果去往目标地址的端口与源端口相同，则丢弃该帧。</p><blockquote><p>考虑上图b中，站 E 和 F 都连到集线器 H1，进而再连接到网桥 B2 。如果 E 发送一个帧给 F ，集线器将中继该帧到 B2 以及 F。这就是集线器该做的事情一一它们用有线把所有端口连在一起，这样从一个端口输入的帧只是输出到所有其他端口。该帧最终将从端口 2 到达 B2 ，这正是它到达目的地的正确输出端口。网桥 B2 只需丢弃该帧。</p></blockquote></li><li><p>如果去往目标地址的端口与源端口不同，则转发该帧到目标端口。</p></li><li><p>如果目标端口未知，则使用泛洪法，将帧发送到所有的端口，除了它入境的那个。</p></li></ol><h2 id="4-3-Spanning-Tree-Bridges"><a href="#4-3-Spanning-Tree-Bridges" class="headerlink" title="4.3 Spanning Tree Bridges"></a>4.3 Spanning Tree Bridges</h2><p>为了提高可靠性，网桥之间可使用冗余链路。在下图所示的例子中，在一对网桥之间并行设置了两条链路。这种设计可确保一条链路岩掉后，网络不会被分成两组计算机， 使得它们之间无法通信。</p><p>这种冗余引入了一些额外的问题，因为它生成了拓扑环路。</p><p><img src="image-20200101013110957.png" srcset="/img/loading.gif" alt="image-20200101013110957" style="zoom:40%;" /></p><p>解决环路问题的方法是，构造生成树</p><blockquote><p>5 个网桥互联在一起，同时还有站与这些网桥连接。每个站只与一个网桥相连。在网桥之间有一些冗余连接，因此如果这些链路都用，帧就有可能沿着环路转发。</p><p>我们可以将这种拓扑结构抽象成一个图，网桥为节点。点到点的链路是边。 通过去掉一些链路（图中用虚线表示），整个图即被简化为一棵生成树， 按照定义这树上没有环路。利用这棵生成树，从每个站到每个其他站恰好只有一条路径。 </p><p>一旦网桥同意这棵生成树，则站之间的所有转发都将沿着这棵树进行。由于从每个源到每 个目标都只有唯一一条路径可走，所以不可能产生环路。</p></blockquote><p><img src="image-20200101013333406.png" srcset="/img/loading.gif" alt="image-20200101013333406" style="zoom:50%;" /></p><h2 id="4-4-中继器／集线器／网桥／交换机／路由器和网关"><a href="#4-4-中继器／集线器／网桥／交换机／路由器和网关" class="headerlink" title="4.4 中继器／集线器／网桥／交换机／路由器和网关"></a>4.4 中继器／集线器／网桥／交换机／路由器和网关</h2><p><img src="image-20200101013706679.png" srcset="/img/loading.gif" alt="image-20200101013706679" style="zoom:50%;" /></p><h3 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h3><h4 id="A-Repeater中继器"><a href="#A-Repeater中继器" class="headerlink" title="A. Repeater中继器"></a>A. Repeater中继器</h4><p>用来在物理层放大信号</p><h4 id="B-Hub集线器"><a href="#B-Hub集线器" class="headerlink" title="B. Hub集线器"></a>B. Hub集线器</h4><p>集线器有许多条输入线路，它将这些输入线路连接在一起。从任何 一条线路上到达的帧都被发送到所有其他的线路上。如果两帧同时到达，它们将会冲突。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="A-网桥-交换机"><a href="#A-网桥-交换机" class="headerlink" title="A. 网桥/交换机"></a>A. 网桥/交换机</h4><p><img src="my_1568281840_ZK4myJNWO8.png" srcset="/img/loading.gif" alt="_1568281840_ZK4myJNWO8" style="zoom:67%;" /></p><p>与集线器不同的是网桥的每个端口被隔离成它 自己一个冲突域：如果端口是全双工的点到点线路，则需要用到 CSMA/CD 算法。当到达 一帧时，网桥从帧头提取出帧的目的地址，并用该地址查询一张应该把帧发往哪里去的表。</p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h2 id="4-5-VLAN"><a href="#4-5-VLAN" class="headerlink" title="4.5 VLAN"></a>4.5 VLAN</h2><p><img src="image-20200101014524120.png" srcset="/img/loading.gif" alt="image-20200101014524120" style="zoom:50%;" /></p><p>为了使VLAN正常地运行，网桥必须建立配置表。这些配置表指明了通过哪些端口可以访问哪些VLAN。当一帧到来时，比如说来自灰色VLAN，那么这帧必须被转发到所有标记为 G 的端口。这一条规则对于网桥不知道目的地位置的普通流量（即单播）以及组播和广播流量都适用。注意，一个端口可以标记为多种VLAN颜色。</p><p>refences</p><p>[1]<a href="https://blog.csdn.net/Jaihk662/article/details/80386620" target="_blank" rel="noopener">https://blog.csdn.net/Jaihk662/article/details/80386620</a></p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer network--数据链路层</title>
    <link href="/2019/10/16/ComputerNetwork/DataLinkLayer/"/>
    <url>/2019/10/16/ComputerNetwork/DataLinkLayer/</url>
    
    <content type="html"><![CDATA[<p>计算机网络课程—数据链路层总结</p><a id="more"></a><style>  .page__header .header__brand path {    fill: rgba(255, 255, 255, .95);  }</style><p><br/></p><h1 id="1-数据链路层的设计问题"><a href="#1-数据链路层的设计问题" class="headerlink" title="1. 数据链路层的设计问题"></a>1. 数据链路层的设计问题</h1><p>数据链路层使用物理层提供的服务在通信信道上发送和接收比特。要实现的功能包括</p><ul><li>向网络层提供一个定义良好的服务接口</li><li>处理传输错误</li><li>调节数据流，确保慢速的接受方不会被快速的发送方淹没</li></ul><p>数据包被封装成帧，每个帧包含一个Header,一个Payload field,一个Trailer</p><center><img src="image-20191012225542485.png" srcset="/img/loading.gif" alt="image-20191012225542485" style="zoom:50%;" /></center><h2 id="1-1-提供给网络层的服务"><a href="#1-1-提供给网络层的服务" class="headerlink" title="1.1 提供给网络层的服务"></a>1.1 提供给网络层的服务</h2><p>三种服务类型</p><ul><li>无确认的无连接服务</li></ul><blockquote><p>特点</p><ul><li><p>事先不用建立物理连接，事后也不用释放逻辑连接</p></li><li><p>源机器向目标机器发送独立的frame,目标机器不对这些frame进行确认</p></li></ul><p>适合的场合</p><ul><li><p>实时通信[数据迟到比数据受损更难忍受]</p></li><li><p>错误率比较低的场合[因为数据链路层可靠性不高，所以物理层reliable要求会高一点，适合有线网络</p></li></ul></blockquote><ul><li>有确认的无连接服务</li></ul><blockquote><p>特点</p><ul><li>不用建立物理连接</li><li>发送的每一帧都要单独确认，这样发送方可以知道一个帧是否已经正确到达目的地。如果一个帧在制定时间间隔内还没有到达，则发送方将再次发送该帧</li><li>不能保证收到包的顺序和发送顺序一致</li></ul><p>适用场合</p><ul><li>不可靠的信道：无线系统,WiFi</li></ul></blockquote><ul><li>有确认的有连接服务</li></ul><blockquote><p>源机器和目标机器在传输任何数据之前要建立一个连接，连接发送每一帧都被编号，数据链路层确保发出的每个帧都会真正被接收方按顺序收到且只收到一次。相当于提供了一个可靠的比特流</p><p>适用场合</p><ul><li>长距离且不可靠的链路 </li></ul></blockquote><h2 id="1-2-framing-成帧"><a href="#1-2-framing-成帧" class="headerlink" title="1.2 framing[成帧]"></a>1.2 framing[成帧]</h2><p>数据链路层要检测和纠正错误。</p><p>数据链路层通常的做法是将比特流拆分成多个离散的帧。</p><p>为每个帧计算一个称为校验和的短令牌，放在帧中一起传输。</p><p>帧到达目标机器时，重新计算校验和。如果新计算的校验和与传输过来的不同，说明产生了错误。</p><p><br/></p><p>拆分方法</p><h3 id="1-2-1-Byte-count"><a href="#1-2-1-Byte-count" class="headerlink" title="1.2.1 Byte count"></a>1.2.1 Byte count</h3><p>Method: to use a field in the header to specify the number of characters in the frame.</p><center><img src="image-20191008100755672.png" srcset="/img/loading.gif" alt="image-20191008100755672" style="zoom:35%;" /></center><p>problem:</p><p>错了一个character count就会全错</p><center><img src="image-20191012232424422.png" srcset="/img/loading.gif" alt="image-20191012232424422" style="zoom:50%;" /></center><h3 id="1-2-2-flag-bytes-with-byte-stuffing字节填充的标志字节法"><a href="#1-2-2-flag-bytes-with-byte-stuffing字节填充的标志字节法" class="headerlink" title="1.2.2  flag bytes with byte stuffing字节填充的标志字节法"></a>1.2.2  flag bytes with byte stuffing字节填充的标志字节法</h3><p>考虑到出错之后到重新同步问题，用一些标志字节(flag byte)作为一个帧开始和结束</p><center><img src="image-20191012233630323.png" srcset="/img/loading.gif" alt="image-20191012233630323" style="zoom:50%;" /></center><p>如图所示的这种frame的结构</p><p>两个连续的flag标志了一帧的结束和下一帧的开始。</p><p>problem:</p><p>如果标志字节在数据中出现，会干扰到帧的分界</p><p><br/></p><p>所以提出的解决方法是字节填充(byte stuffing)，发送方的数据链路层在数据中偶尔出现的每个标志字节前面插入一个特殊的转义字节(ESC),如果转移字符也出现在数据中，再用一个转义字符填充</p><center><img src="image-20191012234408243.png" srcset="/img/loading.gif" alt="image-20191012234408243" style="zoom:35%;" /></center><h3 id="1-2-3-flag-bit-with-bit-stuffing"><a href="#1-2-3-flag-bit-with-bit-stuffing" class="headerlink" title="1.2.3 flag bit with bit stuffing"></a>1.2.3 flag bit with bit stuffing</h3><p>考虑到字节填充只能使用8bits的字节，这里bit填充可以使帧包含任意大小单元</p><p>flag bits 01111110</p><p>也要考虑数据中出现flag的问题，所以发送方的数据链路层在数据中每遇到连续的5个1，就添加1个0</p><p>接收方看到5个连续的1，后面紧跟1个0，就自动剔除这个0</p><center><img src="image-20191013180557730.png" srcset="/img/loading.gif" alt="image-20191013180557730" style="zoom:50%;" /> </center><h3 id="1-2-4-physical-layer-encoding-violation"><a href="#1-2-4-physical-layer-encoding-violation" class="headerlink" title="1.2.4 physical layer encoding violation"></a>1.2.4 physical layer encoding violation</h3><p>物理层有讲过4B/5B的编码，4个比特被映射成5个比特，说明有16种信号不会出现在数据中，可以用来作为flag</p><h2 id="1-3-Error-control"><a href="#1-3-Error-control" class="headerlink" title="1.3 Error control"></a>1.3 Error control</h2><p>如何保证所有帧最终传递给目标机器的网络层，并且保持正确的顺序</p><p>– To provide the sender with some feedback</p><ul><li>Positive acknowledgement (ACK) 收到信号回一个ack</li><li>Negative acknowledgement (NAK) 没收到信号回一个nack， 潜在的假设是我知道发送的包以及发送的顺序</li></ul><p>– To provide timeout timers</p><ul><li>Resend as necessary</li></ul><p>– To number frames</p><ul><li>To distinguish retransmissions from originals</li></ul><h2 id="1-4-Flow-control"><a href="#1-4-Flow-control" class="headerlink" title="1.4 Flow control"></a>1.4 Flow control</h2><p>发送方发送帧的速度超过了接收方接收的速度，该如何处理</p><ul><li><p>To introduce flow control to throttle the sender into sending no faster than the receiver can handle the traffic.</p></li><li><p>Flow control protocol contains well-defined rules about when a sender may transmit the next frame.</p></li><li><p>Two approaches<br>– <strong>Feedback-based flow control</strong> 由receiver决定发送的速度</p><p>– Rate-based flow control</p></li></ul><h1 id="2-Error-Detection-and-Correction"><a href="#2-Error-Detection-and-Correction" class="headerlink" title="2. Error Detection and Correction"></a>2. Error Detection and Correction</h1><p>Error Types</p><blockquote><p>isolated errors单个的错误</p><p>burst errors一连串的错误</p></blockquote><p>approaches: 在数据中引入一些<u>冗余</u>来进行error detection和error correction</p><h2 id="2-1-一些概念"><a href="#2-1-一些概念" class="headerlink" title="2.1 一些概念"></a>2.1 一些概念</h2><h3 id="i"><a href="#i" class="headerlink" title="i."></a>i.</h3><p>一帧有</p><ul><li>m个数据位</li><li>r个冗余位。r个校验位是由m个数据位的函数计算得到的</li></ul><p>令数据块总长度为n(n=m+r)，我们称其为(n,m)码。</p><p><u>码字</u>(codeword): 一个包含了数据位和校验位的n位单元</p><p>码率(code rate): codeword中数据部分占比m/n</p><h3 id="ii"><a href="#ii" class="headerlink" title="ii."></a>ii.</h3><p>Hamming distance of 2 codewords</p><blockquote><p> 两个codeword中不相同的bit的个数</p></blockquote><p>Hamming distance of complete code(all valid codewords)</p><blockquote><p>The minimum Hamming distance of two valid codewords in the code</p></blockquote><center><img src="image-20191013185144979.png" srcset="/img/loading.gif" alt="image-20191013185144979" style="zoom:33%;" /></center><p>To detect d errors, you need d+1 Hamming distance code.</p><blockquote><p>因为，d+1的hamming distance,说明两个codeword之间最少有d+1位不相同。所以如果d个错误出现，这个codeword也不会错成一个valid codeword.</p></blockquote><p>To correct d errors, you need 2d+1 Hamming distance code</p><blockquote><p>因为,两个codeword之间最少有2d+1个bits不相同，如果有d errors,那么偏离原codeword的hamming distance 为d, 2d+1的距离保证了与这个错误的codeword距离最近的依然是原codeword</p></blockquote><h2 id="2-2-Error-Correction-codes"><a href="#2-2-Error-Correction-codes" class="headerlink" title="2.2 Error Correction codes"></a>2.2 Error Correction codes</h2><h3 id="2-2-1-Hamming-code-for-single-error"><a href="#2-2-1-Hamming-code-for-single-error" class="headerlink" title="2.2.1 Hamming code for single error"></a>2.2.1 Hamming code for single error</h3><p>参考以下两篇blog可以有一个基本了解，我结合他们做了一个总结</p><p><a href="https://blog.csdn.net/Yonggie/article/details/83186280" target="_blank" rel="noopener">https://blog.csdn.net/Yonggie/article/details/83186280</a></p><p><a href="https://blog.csdn.net/blue_starry_sky/article/details/53997548" target="_blank" rel="noopener">https://blog.csdn.net/blue_starry_sky/article/details/53997548</a></p><p>(图片中应该是redundancy)</p><table>  <tr>    <td><img src="IMG_5ACFEACB9F7D-1.png" srcset="/img/loading.gif" alt="IMG_5ACFEACB9F7D-1" style="zoom: 30%;" /></td>    <td>    <img src="IMG_AA14DF432E13-1.png" srcset="/img/loading.gif" alt="IMG_AA14DF432E13-1" style="zoom:40%;" /></td>  </tr></table><p>为什么上述纠错可行呢？</p><p>因为如果没有出现错误的话$hi\oplus(P_i组内异或结果)=0$，因为我们计算的时候$h_i=P_i组内异或结果$, 自己和自己异或为0。如果出现了一个错误的话，与这个错误相关的组$hi\oplus(P_i组内异或结果)=1$, 这些组别标识了错误的位置</p><p><br/></p><p><br/></p><p>-你知道吗，Hamming codes也可以用来correct burst error呢？</p><p>-哦？怎么做呢</p><p>-嘿嘿嘿，有一点tricky</p><ul><li>one codeword per row. k consecutive codewords</li><li>–Transmit the matrix by one column at a time.</li></ul><p>这样一行的连串错误，在列看来就是一列可以有一个错误</p><center><img src="image-20191229155224546.png" srcset="/img/loading.gif" alt="image-20191229155224546" style="zoom:50%;" /></center><h2 id="2-3-Error-Detection-codes"><a href="#2-3-Error-Detection-codes" class="headerlink" title="2.3 Error Detection codes"></a>2.3 Error Detection codes</h2><p>相比error correction, error detection代价更小。</p><p>error correction引入太多redundancy bit, 不如用error detection，如果检测到error,就retransmission这样代价小。</p><h3 id="2-3-1-Parity"><a href="#2-3-1-Parity" class="headerlink" title="2.3.1 Parity"></a>2.3.1 Parity</h3><blockquote><p>Append a parity bit to detect single error.</p></blockquote><p>奇校验：数据bit 1的个数为奇数就加一个0bit, 是偶数就加一个1bit。保持1的个数为奇数</p><p>偶校验：数据bit 1的个数为偶数就加一个0bit, 是奇数就加一个1bit。保持1点个数为偶数</p><p>single error显然是可以检测出来，其实burst error也是可以的，如下图，上文提到的按列发送</p><center><img src="image-20191024153859898.png" srcset="/img/loading.gif" alt="image-20191024153859898" style="zoom:50%;" /></center><h3 id="2-3-2-Checksum"><a href="#2-3-2-Checksum" class="headerlink" title="2.3.2 Checksum"></a>2.3.2 Checksum</h3><blockquote><p>将数据分成若干段，做加法，取模</p></blockquote><p>一个internet checksum的例子</p><center><img src="IMG_7FC95B48427A-1.png" srcset="/img/loading.gif" alt="IMG_7FC95B48427A-1" style="zoom: 33%;" />                  </center><p>性质</p><p>– Improved error detection over parity bits</p><p>– Vulnerable to systematic errors, 比如：在后面加了一连串0，检测不出错</p><h3 id="2-3-3-CRC"><a href="#2-3-3-CRC" class="headerlink" title="2.3.3 CRC"></a>2.3.3 CRC</h3><center><img src="IMG_BB50334654CE-1.png" srcset="/img/loading.gif" alt="IMG_BB50334654CE-1" style="zoom:36%;" /></center><center><img src="IMG_B37D4802C2E6-1.png" srcset="/img/loading.gif" alt="IMG_B37D4802C2E6-1" style="zoom:40%;" /></center><center><img src="IMG_CAA2C1958BE2-1.png" srcset="/img/loading.gif" alt="IMG_CAA2C1958BE2-1" style="zoom:31%;" /></center><p>注意一个$x^{k-1}+\cdots+1$是一个$k-1$阶多项式</p><p>选择余数的位数为除数的阶。比如$x^4+x+1$是一个4阶多项式，选择余数为4阶。</p><p><br/></p><h1 id="3-基本数据链路层协议"><a href="#3-基本数据链路层协议" class="headerlink" title="3. 基本数据链路层协议"></a>3. 基本数据链路层协议</h1><center><img src="image-20191024230806384.png" srcset="/img/loading.gif" alt="image-20191024230806384" style="zoom:25%;" /></center><h2 id="3-1-Elementary-Data-Link-Protocol"><a href="#3-1-Elementary-Data-Link-Protocol" class="headerlink" title="3.1 Elementary Data Link Protocol"></a>3.1 Elementary Data Link Protocol</h2><h3 id="3-1-2-Some-Assumptions"><a href="#3-1-2-Some-Assumptions" class="headerlink" title="3.1.2 Some Assumptions"></a>3.1.2 Some Assumptions</h3><ul><li>物理层、数据链路层、网络层都是独立的进程，通过来回传递消息进行通信。</li><li>机器A希望用一个可靠的、面向连接的服务向机器B发送一个长数据流</li><li>机器不会崩溃</li></ul><h3 id="3-1-3-声明"><a href="#3-1-3-声明" class="headerlink" title="3.1.3 声明"></a>3.1.3 声明</h3><p><code>seq_nr</code>对帧进行编号，0~MAX_SEQ</p><p>一个帧由4个字段组成:kind, seq, ack, info 前三个包含控制信息，最后一个可能包含要传输的实际数据，这些字段合起来称为 <strong>帧头</strong></p><blockquote><p>kind指出帧中是否有数据</p><p>seq序号</p><p>ack确认</p><p>info数据包</p></blockquote><p>信道传输，有时会丢失帧，发送方会启动计时器，在预设时间间隔没有收到应答，则时钟超时，链路层发出终端信号。实现</p><blockquote><p>让过程 <code>wait for event</code>返回 <code>event= timeout</code> </p><p>过程 <code>start_timer</code> 和 <code>stop_timer</code> 分别打开和关闭计时器。</p><p>只有当计时器在运行并且调用 <code>stop_timer</code> 之前，超时事件才有可能发生。在计时器运行的同时，允许显式地调用 start_timer: 这样的调用只是重置时钟，等到再经过一个完整的时钟间隔之后引发下一次超时事件（除 非它再次被重置，或者被关闭〉。</p></blockquote><p>过程 <code>start_ack_timer</code> 和 <code>stop_ack_timer</code> 控制一个辅助计时器，该定时器被用于在特定条件下产生确认。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_PKT 1024</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>&#125; boolean;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> seq_nr;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> data[MAX_PKT];&#125; packet;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;data, ack, nak&#125; frame_kind;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  frame_kind kind;  seq_nr seq;  seq_nr ack;  packet info;&#125; frame;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_for_event</span><span class="hljs-params">(event_type* event)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">from_network_layer</span><span class="hljs-params">(packet* p)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">to_network_layer</span><span class="hljs-params">(packet* p)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">from_physical_layer</span><span class="hljs-params">(frame* r)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start_timer</span><span class="hljs-params">(seq_nr k)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop_timer</span><span class="hljs-params">(seq_nr k)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start_ack_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop_ack_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enable_network_layer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disable_network_layer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<span class="hljs-comment">//increment k circularly</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(k) <span class="hljs-meta-keyword">if</span>(k &lt; MAX_SEQ) k = k + 1; <span class="hljs-meta-keyword">else</span> k = 0</span></code></pre></div><h3 id="3-1-4-一个乌托邦式的单工协议"><a href="#3-1-4-一个乌托邦式的单工协议" class="headerlink" title="3.1.4 一个乌托邦式的单工协议"></a>3.1.4 一个乌托邦式的单工协议</h3><ul><li><p>Data are transmitted in <u>one direction only</u>.</p></li><li><p>The communication channel <u>never damages or loses frames</u>.</p></li><li><p>Both the transmitting and receiving network layers are <u>always ready</u>.</p></li><li><p>Processing time can be ignored.</p></li><li><p>Infinite buffer space is available.</p></li></ul><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;frame_arrival&#125; event_type;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"protocol.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sender1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  <span class="hljs-comment">//buffer for an outbound frame</span>  frame s;  <span class="hljs-comment">//buffer for an outbound packet</span>  packet buffer;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    <span class="hljs-comment">//从网络层拿一个包</span>    from_network_layer(&amp;buffer);    <span class="hljs-comment">//放到frame</span>    s.info = buffer;    <span class="hljs-comment">//传包</span>    to_physical_layer(&amp;s);  &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receiver1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  frame r;  <span class="hljs-comment">//filled in by wait, but not used here</span>  event_type event;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    <span class="hljs-comment">//only possibility is frame_arrival</span>    wait_for_event(&amp;event);    <span class="hljs-comment">//go get the inbound frame</span>    from_physical_layer(&amp;r);    <span class="hljs-comment">//pass the data to the network layer</span>    to_network_layer(&amp;r.info);  &#125;&#125;</code></pre></div><h3 id="3-1-5-A-simplex-stop-and-wait-protocol"><a href="#3-1-5-A-simplex-stop-and-wait-protocol" class="headerlink" title="3.1.5 A simplex stop-and-wait protocol"></a>3.1.5 A simplex stop-and-wait protocol</h3><ul><li><p>Data traffic is still <u>simplex protocol</u></p></li><li><p>The communication channel is assumed to be <u>error free</u>. </p></li><li><p>The sender is always ready. <strong><em><u>The receiver is NOT always ready or the receiver has limited buffer space</u></em></strong>.这里放宽了protocol的限制</p><ul><li>The sender simply inserts a delay into protocol 1 to slow it down sufficiently to keep from swamping the receiver. —&gt; low utilization of bandwidth.</li><li>The receiver provides <u>feedback</u> to the sender, permitting the sender to transmit the next frame.</li></ul></li><li><p>Protocol(p2) ensures sender can’t outspace receiver:</p><ul><li>Receiver returns a dummy frame (ack) when ready</li><li>Only one frame out at a time ± called stop-and-wait</li><li>We added flow control!</li></ul></li></ul><center><img src="image-20191025105854425.png" srcset="/img/loading.gif" alt="image-20191025105854425" style="zoom:30%;" /></center><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;frame_arrival&#125; event_type;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"protocol.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sender2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  frame s;  packet buffer;  event_type event;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    from_network_layer(&amp;buffer);    s.info = buffer;    to_physical_layer(&amp;s);    wait_for_event(&amp;event);  &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receiver2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  frame r, s;  event_type event;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    wait_for_event(&amp;event);    from_physical_layer(&amp;r);    to_network_layer(&amp;r.info);    to_physical_layer(&amp;s);  &#125;&#125;</code></pre></div><h3 id="3-1-6-A-simplex-protocol-for-a-noisy-channel"><a href="#3-1-6-A-simplex-protocol-for-a-noisy-channel" class="headerlink" title="3.1.6 A simplex protocol for a noisy channel"></a>3.1.6 A simplex protocol for a noisy channel</h3><ul><li>Data traffic is <u>still simplex</u></li><li>The communication channel is <strong><em><u>NOT free of errors</u></em></strong>.</li><li>The receiver is <strong><em><u>Not always ready</u></em></strong>.</li></ul><p>possible solutions:</p><ul><li><p>Protocol2 + timer —-&gt; duplicate packets</p></li><li><p>Protocol2 + timer + to number the frame</p></li></ul><p>如果在一个协议中，发送方在前移到下一个数据之前必须等待一个肯定确认，这样的协议称为自动重复请求(ARQ, Automatic Repeat Request)或者带有重传的肯定确认(PAR, Positive Acknowledgement with Retransmission)</p><table>  <tr>    <td>      <img src="image-20191025200128444.png" srcset="/img/loading.gif" alt="image-20191025200128444" style="zoom:50%;" />    </td>    <td>      <img src="image-20191025195618998.png" srcset="/img/loading.gif" alt="image-20191025195618998" style="zoom:50%;" />    </td>     <td>      <img src="image-20191025200041993.png" srcset="/img/loading.gif" alt="image-20191025200041993" style="zoom:50%;" />    </td>  </tr></table><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAZ_SEQ1</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;frame_arrival, cksum_err, timeout&#125; event_type;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"protocol.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sender3</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  <span class="hljs-comment">//seq number of next outgoing frame</span>  seq_nr next_frame_to_send;  <span class="hljs-comment">//scratch variable</span>  frame s;  <span class="hljs-comment">//buffer for an outbound packet</span>  packet buffer;  event_type event;  <span class="hljs-comment">//initialize outbound sequence numbers</span>  next_frame_to_send = <span class="hljs-number">0</span>;  <span class="hljs-comment">//fetch first packet</span>  from_network_layer(&amp;buffer);    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    <span class="hljs-comment">//construct a frame for transmission</span>    s.info = buffer;    <span class="hljs-comment">//insert sequence number in frame</span>    s.seq = next_frame_to_send;    <span class="hljs-comment">//send it on its way</span>    to_physical_layer(&amp;s);    <span class="hljs-comment">//if answer takes too long, timeout</span>    start_timer(s.seq);    <span class="hljs-comment">//frame_arrival, cksum_err, timeout</span>    wait_for_event(&amp;event);    <span class="hljs-keyword">if</span>(event == frame_arrival)&#123;      <span class="hljs-comment">//get the acknowledgement</span>        from_physical_layer(&amp;s);        <span class="hljs-keyword">if</span>(s.ack == next_frame_to_send) &#123;          <span class="hljs-comment">//turn the timer off</span>          stop_timer(s.ack);          <span class="hljs-comment">//get the next one to send</span>          from_network_layer(&amp;buffer);          <span class="hljs-comment">//invert next_frame_to_send</span>          inc(next_frame_to_send);      &#125;    &#125;  &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receiver3</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  frame r, s;  event_type event;  frame_expected = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    wait_for_event(&amp;event);<span class="hljs-comment">//frame_arrival, cksum_err</span>    <span class="hljs-keyword">if</span>(event == frame_arrival) &#123;      from_physical_layer(&amp;r);      <span class="hljs-keyword">if</span>(r.seq == frame_expected) &#123;        to_network_layer(&amp;r.info);        inc(frame_expected);      &#125;    &#125;  &#125;  s.ack = <span class="hljs-number">1</span> - frame_expected;&#125;</code></pre></div><table>  <tr>    <td>      <img src="IMG_DA892339BCCD-1.png" srcset="/img/loading.gif" alt="IMG_DA892339BCCD-1" style="zoom:60%;" />    </td>        <td>  <img src="IMG_430578E193A6-1.png" srcset="/img/loading.gif" alt="IMG_430578E193A6-1" style="zoom:70%;" />      </td>   </tr></table><p>​     </p><h3 id="3-1-7-Sliding-window-protocol"><a href="#3-1-7-Sliding-window-protocol" class="headerlink" title="3.1.7 Sliding window protocol"></a>3.1.7 Sliding window protocol</h3><p>前面的协议中，数据帧单向传输，但是大多数情况，需要双向传输。</p><p>实现全双工的一种方法是运行前面协议的两个实例，每个实例使用一条独立的链路进行单工数据传输。但是这样每条链路由一个“前向”信道(用于数据)和一个”逆向”信道(用于确认)组成。两种情况下的逆向带宽几乎被完全浪费了。</p><p>一种更好的做法是使用同一条链路来传输两个方向上的数据。</p><p>机器A向机器B发送数据帧和确认帧[确认收到机器B上一次发送的帧]混合，接收方只需检查帧头部kind字段，就可以分辨数据帧和确认帧</p><p><br/></p><p><strong>i. 捎带确认[piggybacking]</strong>：</p><blockquote><p>暂时延缓确认以便将确认信息搭载在下一个出境数据帧上的技术。确认信息被附加在往外发送的数据帧上[使用帧头的ack字段]</p><p>优化了上述发送数据帧和确认帧的方法，减轻了接收方的处理负担</p></blockquote><p><strong>ii. 滑动窗口[sliding window]</strong>:</p><blockquote><p>所有滑动窗口协议的本质是在任何时刻发送方总是维持一组序号，对应于允许它发送的帧。称这些帧落在<u>发送窗口</u>[sliding window]内。</p><p>接收方也维持一个<u>接受窗口</u>[receiving window]，对应于一组允许它接受的帧。</p><p>发送方的窗口和接收方的窗口不必有同样的上下界，甚至也不必有同样的大小</p><p>任何一个出境帧都包含一个序号， 范围从 0 到某个最大值。序号的最大值通常是$2^n-1$，这样序号正好可以填入到一个n位的字段中。停-等式滑动窗口协议使用n=1，限制了序号只能是 0 和 1 ，但是更加复杂的协议版本可以使用任意的n</p></blockquote><p><a href="https://blog.csdn.net/wdscq1234/article/details/52444277" target="_blank" rel="noopener">https://blog.csdn.net/wdscq1234/article/details/52444277</a></p><p>数据链路层协议将数据包递交给网络层的次序必须  和  发送机器上数据包从网络层传递给数据链路层的次序相同。</p><center><img src="image-20191026220230537.png" srcset="/img/loading.gif" alt="image-20191026220230537" style="zoom:50%;" /></center><p><strong><u>A. 一位滑动窗口协议</u></strong></p><p>窗口尺寸为1，发送方发出一帧以后，必须等待前一帧的确认的到来才能发送下一帧，这个协议使用了停-等式办法</p><table>  <tr>    <td>      <img src="IMG_BE2535BE4B0D.png" srcset="/img/loading.gif" alt="IMG_BE2535BE4B0D-1" style="zoom:55%;" />    </td>    <td>      <img src="https://miaochenlu.github.io/picture/IMG_7FBAD2BAF798-1.png" srcset="/img/loading.gif" alt="IMG_7FBAD2BAF798-1" style="zoom:50%;" />     </td>    </tr></table><center><img src="image-20191025202700163.png" srcset="/img/loading.gif" alt="image-20191025202700163" style="zoom:50%;" /></center><p><strong><u>B. Go back N</u></strong></p><p><a href="http://www.ccs-labs.org/teaching/rn/animations/gbn_sr/" target="_blank" rel="noopener">go back N动画</a></p><p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html" target="_blank" rel="noopener">GBN animination</a></p><p><a href="https://blog.csdn.net/qq_34501940/article/details/51180268" target="_blank" rel="noopener">https://blog.csdn.net/qq_34501940/article/details/51180268</a></p><center><img src="image-20191229212229327.png" srcset="/img/loading.gif" alt="image-20191229212229327" style="zoom:50%;" /></center><blockquote><p>在发送完一个帧后，不用停下来等待确认，而是可以连续发送多个数据帧。收到确认帧时，任可发送数据，这样就减少了等待时间，整个通信的通吞吐量提高。<br>如果前一个帧在超时时间内未得到确认，就认为丢失或被破坏，需要重发出错帧及其后面的所有数据帧。这样有可能有把正确的数据帧重传一遍，降低了传送效率。<br>线路很差时，使用退后N帧的协议会浪费大量的带宽重传帧。</p></blockquote><p><br/></p><p><br/></p><p><strong><u>C. Selective Repeat ARQ</u></strong></p><p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html" target="_blank" rel="noopener">ARQ</a></p><p>如果错误很少发生，则回退 n 协议可以工作得很好：但是，如果线路质量很差，那么重传的帧要浪费大量带宽。另一种处理错误的策略是选择重传协议，允许接收方<strong><em>接受并缓存坏帧</em></strong>或者丢失帧后面的所有帧。</p><center><img src="image-20191229210854474.png" srcset="/img/loading.gif" alt="image-20191229210854474" style="zoom:50%;" /><</center><blockquote><p>NAK：非确认帧，当在一定时间内没有收到某个数据帧的ACK时，回复一个NACK。<br>在发送过程中，如果一个数据帧计时器超时，就认为该帧丢失或者被破坏，接收端只把出错的的帧丢弃，其后面的数据帧保存在缓存中，并向发送端回复NAK。发送端接收到NAK时，只发送出错的帧。<br>如果落在窗口的帧从未接受过，那么存储起来，等比它序列号小的所有帧都按次序交给网络层，那么此帧才提交给网络层。<br>接收端收到的数据包的顺序可能和发送的数据包顺序不一样。因此在数据包里必须含有顺序字符来帮助接受端来排序。<br>选择重传协议可以避免重复传送那些正确到达接收端的数据帧。但是接收端要设置具有相当容量的缓存空间，这在许多情况下是不够经济的。</p></blockquote><p><strong><em>Window size</em></strong></p><ul><li><p>Send Window $Size &lt;= (MAX_SEQ+1)/2$ 注意Max_seq是指最大序号，不是最大数量</p></li><li><p>Receive Window Size = Send Window Size</p></li></ul><blockquote><p>这个问题的本质在于当接收方向前移动它的窗口后，新的有效序号范围与老的序号范围有重叠。因此，后续的一批帧可能是重复的帧（如果所有的确认都丢失了），也可能是新的帧（如果所有的确认都接收到了)。接收方根本无法区分这两种情形。</p></blockquote><center><img src="image-20191229205721964.png" srcset="/img/loading.gif" alt="image-20191229205721964" style="zoom:50%;" /></center><p><img src="image-20200104140132312.png" srcset="/img/loading.gif" alt="image-20200104140132312" style="zoom:50%;" /></p><ol><li>从t0-&gt;t1, Node-B返回的最后一个包是R3,3</li></ol><p>说明Node-B收到了0～2号包，所有下一个期待A发送3号包</p><p>因此，收到的有S0,0 &amp; S1,0 &amp; S2,0</p><ol><li>注意，题目中说，transmission sequence number and acknowledgment sequence number是3bit</li></ol><p>所有一共有8个序号</p><p>在GBN协议中，序号个数≥发送窗口+1</p><p>所以，发送窗口为7</p><p><img src="image-20200104140642889.png" srcset="/img/loading.gif" alt="image-20200104140642889" style="zoom:50%;" /></p><p>A还可以发送5个数据包</p><p>当发送第一个序号为5的数据帧时，可以同时对乙方发来的且按序到达的1号数据帧进行捎带确认，确认序号为2，因此甲方发送的第一个数据帧为S5,2；</p><p>同理，当发送最后一个序号为1的数据帧时，可以同时对乙方发来的且按序到达的1号数据帧进行捎带确认，确认序号为2，因此甲方发送的最后一个数据帧时S1,2。需要注意的是，尽管甲方收到了R3,3，也就是乙方发来的序号为3的数据帧，但是该数据帧并未按序到达，因为甲方之前没有收到序号为2的数据帧，因此甲方不能对R3,3进行捎带确认。</p><ol><li><p>方在t0时刻到t1时刻期间共发送了序号为0~4的5个数据帧。在t1时刻甲方超时重传2号数据帧，这表明甲方没有收到乙方对2号数据帧的确认，这可能是由于2号数据帧未按序到达乙方或按序到达乙方但出现了误码。由于甲乙双方都使用GBN协议，因此甲方需要重传超时的数据帧及其后续数据帧，也就是甲方需要重传序号为2~4的3个数据帧。重传的第一个帧的序号为2，由于之前已经按序正确收到乙方发来的序号为2的数据帧，因此可以进行捎带确认，确认号为3，因此重传的第一个帧为S2,3。</p></li><li></li></ol><script type="math/tex; mode=display">\frac{7\times 1000\times 8/100Mbps}{0.96ms+ 1000\times 8/100Mbps}=50\%</script><h1 id="4-数据链路层协议实例"><a href="#4-数据链路层协议实例" class="headerlink" title="4. 数据链路层协议实例"></a>4. 数据链路层协议实例</h1><h2 id="4-1-PPP"><a href="#4-1-PPP" class="headerlink" title="4.1 PPP"></a>4.1 PPP</h2><p>A standard protocol called PPP (Point to Point Protocol) is used to send packets over the links, including the SONET fiber optic links and ADSL links</p><center><img src="image-20191229214521665.png" srcset="/img/loading.gif" alt="image-20191229214521665" style="zoom:50%;" /></center><p>PPP 功能包括处理错误检测链路的配置、支持多种协议、允许身份认证等。它是一个 早期简化协议的改进，那个协议称为串行线路 Internet 协议 （SLIP, Serial Line Internet Protocol ）。伴随着一组广泛选项， PPP 提供了 3 个主要特性：</p><ul><li><p>一种成帧方法。它可以毫无歧义地区分出一帧的结束和下一帧的开始．</p></li><li><p>一个链路控制协议．它可用于启动线路、测试线路、协商参数， 以及当线路不再需要时温和地关闭线路。该协议称为<strong><em><u>链路控制协议 （LCP, Link Control Protocol）</u></em></strong>。</p></li><li><p>一种协商网络层选项的方式。协商方式独立于网络层协议．所选择的方法是针对每一种支持的网络层都有一个不同的<strong><em><u>网络控制协议 （NCP, Network Control Protocol)</u></em></strong>。</p></li></ul><p>因为没有必要重新发明轮子，所以 PPP 帧格式的选择酷似 HDLC 帧格式。 HDLC 是<strong><em><u>高级数据链路控制协议 （ High-level Data Link Control ）</u></em></strong>，是一个早期被广泛使用的家庭协议实例。</p><p>PPP 和 HDLC 之间的主要区别在于：</p><ul><li><p>PPP 是面向字节而不是面向比特的．特别是 PPP 使用字节填充技术，所有帧的长度均是字节的整数倍。 HDLC 协议则使用比特填充技术， 允许帧的长度不是字节的倍数，例如 30.25 字节。</p></li><li><p>HDLC 协议提供了可靠的数据传输，所采用的方式正是我们已熟悉的滑动窗口、确认和超时机制等。 PPP 也可以在诸如无线网络等嘈杂的环境里提供可靠传输，具体细节由盯Cl663 定义。然而，实际上很少这样做．相反， Internet几乎都是采用一种“无编号模式”来提供无连接无确认的服务．</p></li></ul><center><img src="image-20191229214119334.png" srcset="/img/loading.gif" alt="image-20191229214119334" style="zoom:45%;" /></center><h2 id="4-2-ADSL"><a href="#4-2-ADSL" class="headerlink" title="4.2 ADSL"></a>4.2 ADSL</h2><center><img src="image-20191229214707273.png" srcset="/img/loading.gif" alt="image-20191229214707273" style="zoom:40%;" /></center><center><img src="image-20191229215124692.png" srcset="/img/loading.gif" alt="image-20191229215124692" style="zoom:50%;" /></center>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CA - Pipeline</title>
    <link href="/2019/10/13/ComputerArchitecture/pipeline/"/>
    <url>/2019/10/13/ComputerArchitecture/pipeline/</url>
    
    <content type="html"><![CDATA[<h1><a name="pipline">附录C流水线</a></h1><h2 id="1-什么是流水线"><a href="#1-什么是流水线" class="headerlink" title="1 什么是流水线"></a>1 什么是流水线</h2><p>流水线是一种将多条指令 <strong><em>重叠执行</em></strong> 的实现技术  </p><p>一条执行包含多种操作，流水线充分利用了这些 <strong><em>操作之间的并行性</em></strong><br><br/></p><p>为了能更形象地理解这个问题，不妨用汽车装配线来做类比    </p><blockquote><p>汽车装配线的每一环节负责一项任务，所有环节是并行的（也就是不同的汽车同时在不同的环节上）  </p><p>在流水线中，指令就像是一辆待装配的汽车，不同环节完成指令的一部分,这些环节的每一步称为 <strong><em>流水级或者流水段</em></strong>。流水级前后相连形成流水线  </p><p>汽车装配线的 <strong><em>吞吐量</em></strong> 定义为单位时间生产的汽车数量，由完整汽车退出装配线的频率决定</p><p>流水线的吞吐量由指令退出流水线的频率决定。一条指令在流水线中下移一步需要的时间为 <strong><em>处理器周期</em></strong> 。因为各个环节同时执行，所以处理器周期由最缓慢的流水线级确定。</p></blockquote><p>可以想见，要使流水线性能高，平衡各流水线级很重要  </p><blockquote><p>因为处理器周期由最缓慢的流水线级确定，我们想要使最缓慢环节的加快，就要平衡各流水线级。  [木桶原理]</p></blockquote><p>如果各级达到完美平衡，那么每条指令在流水线处理器中的时间为  </p><script type="math/tex; mode=display">\frac{非流水线机器上每条指令的时间}{流水级的数目}</script><p>在这些条件下，流水线加速比=流水级的数目</p><p><br/></p><h1 id="2-RISC指令集"><a href="#2-RISC指令集" class="headerlink" title="2 RISC指令集"></a>2 RISC指令集</h1><p>我们以RISC指令集为例来了解一下流水线实现。一下，我们会介绍RISC指令集以及没有流水线的实现方式。</p><p>RISC指令集子集中每条指令都可以在5个时钟周期以内实现。以MIPS指令集为例介绍这5个时钟周期</p><ul><li><strong><em>指令提取周期(IF(Instruction Fetch))</em></strong>  </li><li><strong><em>指令译码/寄存器提取周期(ID)</em></strong>  </li><li><strong><em>执行/有效地址周期(EX)</em></strong>  </li><li><strong><em>存储器访问(MEM)</em></strong></li><li><strong><em>写回周期(WB)</em></strong></li></ul><center><img="/Users/jones/Library/Application Support/typora-user-images/image-20191219230108716.png" alt="image-20191219230108716" style="zoom:50%;" /></center><p><a href="http://web.cs.iastate.edu/~prabhu/Tutorial/PIPELINE/DLXimplem.html" target="_blank" rel="noopener">http://web.cs.iastate.edu/~prabhu/Tutorial/PIPELINE/DLXimplem.html</a></p><p><br/></p><h1 id="3-RISC处理器经典五级流水线"><a href="#3-RISC处理器经典五级流水线" class="headerlink" title="3 RISC处理器经典五级流水线"></a>3 RISC处理器经典五级流水线</h1><center><img src="ca20190908-1.png" srcset="/img/loading.gif" width="600"></center><center><img src="ca20190908-2.png" srcset="/img/loading.gif" width="600"></center><p><br/></p><p>在RISC流水线中，多条指令的执行重叠不会引入多少冲突，因为以下三点</p><h4 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h4><p>使用分离的指令存储器和数据存储器。</p><p>这样做是因为指令提取和数据访问都需要访问存储器，会引发冲突，所以分离指令和数据存储器。</p><p>注意：如果流水线处理器时钟周期=多周期处理器时钟周期，存储器需要提供<strong>5倍带宽</strong></p><h4 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h4><p>两个阶段使用了寄存器堆：<strong>ID</strong>阶段decode, <strong>WB</strong>阶段writeback写入</p><p>因此，每个时钟周期寄存器需要两次读取(A=Reg[rs], B=Reg[rt]) 和一次写入</p><p>为了出气对相同寄存器堆多次读取和一次写入，<strong><em>我们在时钟周期的前半部分写寄存器，后半部分读寄存器</em></strong></p><h4 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h4><p>程序计数器在IF阶段要递增</p><p>ID阶段要计算潜在的分支目标。若分支在ID改变程序计数器？</p><p><br/></p><p>除了要确保流水线中的指令不会在相同时间使用相同的硬件资源，还要确保不同流水级的指令不会互相干扰。这是通过在流水级之间引入 <u>流水线寄存器</u>来实现的。将一个给定的流水级得出的结果存储到流水线寄存器，并在下一个时钟周期作为下一个流水级的输入。</p><center><img src="image-20191013133054888.png" srcset="/img/loading.gif" alt="image-20191013133054888" style="zoom: 30%;" /></center><h1 id="4-流水化的主要阻碍-流水线冒险"><a href="#4-流水化的主要阻碍-流水线冒险" class="headerlink" title="4 流水化的主要阻碍-流水线冒险"></a>4 流水化的主要阻碍-流水线冒险</h1><p>冒险降低来了流水化所能带来的理想加速比<br>冒险共有一下三类  </p><ol><li><p>结构冒险  </p><p>在重叠执行模式下，硬件无法同时支持指令的所有可能组合，就会出现资源冲突 [比如大家都想访问存储器]</p></li><li><p>数据冒险  </p><p>指令之间存在先后顺序，一条指令取决于先前指令的结果</p></li><li><p>控制冒险 </p><p>分支指令以及其他改变程序计数器的指令会导致控制冒险</p></li></ol><p>为了避免冒险，要求流水线中的一些指令延迟时，其他指令能够继续执行 。</p><div class="note note-warning">            <p>这里讨论的流水线，当一条指令被stall时，在指令停顿之后发射的<strong><em>所有指令也会被停顿</em></strong>，之前发射的指令不会被停顿</p>          </div><p><br/></p><h2 id="4-1-带有停顿的流水线性能"><a href="#4-1-带有停顿的流水线性能" class="headerlink" title="4.1 带有停顿的流水线性能"></a>4.1 带有停顿的流水线性能</h2><p>$<br>流水化加速比=\frac{非流水化指令平均执行时间}{流水化指令平均执行时间}$<br>$=\frac{非流水化CPI\times 非流水化时钟周期}{流水化CPI\times 流水化时钟周期}$<br>$=\frac{非流水化CPI}{流水化CPI}\times \frac{非流水化时钟周期}{流水化时钟周期}$</p><p><br/></p><p>流水化处理器的理想CPI几乎总是等于1，算上停顿<br>$<br>流水化CPI=理想CPI+每条指令的流水线停顿时钟周期$<br>$=1+每条指令的流水线停顿时间周期$</p><p>所以</p><script type="math/tex; mode=display">加速比=\frac{非流水化CPI}{1+每条指令的流水线停顿周期}</script><p>如果所有指令周期数相同，等于流水级数目(流水线深度)，那么非流水化CPI=流水线深度</p><script type="math/tex; mode=display">加速比=\frac{流水深度}{1+每条指令的流水线停顿周期}</script><div class="note note-warning">            <p><u>所以，如果没有流水线停顿，加速比=流水线深度</u></p>          </div><h2 id="4-2-结构冒险"><a href="#4-2-结构冒险" class="headerlink" title="4.2 结构冒险"></a>4.2 结构冒险</h2><p>i. 什么是结构冒险</p><blockquote><p>指令重叠执行需要实现功能单元的流水化和资源的复制，以允许在流水线中出现所有可能的指令组合</p><p>如果由于资源冲突而不能容许某些指令组合，就说出现结构冒险</p></blockquote><p>ii. 解决方式</p><p>在发生结构冒险时，使流水线停顿一个时钟周期</p><p>停顿称为 <u>流水线气泡</u>，他们漂浮穿过流水线，占有空间但是不执行有效工作。导致CPI增大</p><p><br/></p><h2 id="4-3-数据冒险"><a href="#4-3-数据冒险" class="headerlink" title="4.3 数据冒险"></a>4.3 数据冒险</h2><p>i. 数据冒险是什么</p><blockquote><p>有些指令依赖于之前指令的结果</p></blockquote><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">DADD</span> <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R3</span><span class="hljs-symbol">DSUB</span> <span class="hljs-built_in">R4</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R5</span><span class="hljs-keyword">AND </span> <span class="hljs-built_in">R6</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R7</span><span class="hljs-symbol">OR</span>   <span class="hljs-built_in">R8</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R9</span><span class="hljs-symbol">XOR</span>  <span class="hljs-built_in">R10</span>,<span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R11</span></code></pre></div><p>DADD后的所有指令都用到了DADD指令的结果R1</p><p>所以在DADD的结果writeback之前，下面的指令都是不能execute的</p><center><img src="image-20191013143518878.png" srcset="/img/loading.gif" alt="image-20191013143518878" style="zoom:30%;" /></center><p>ii. 解决方法</p><p>A. 转发(forwarding)</p><p>转发是一个什么思想呢？ </p><blockquote><p>DSUB需要DADD的结果x, 那么不妨DADD在算出x之后，就把结果给到DSUB需要这个x的位置，而不用等到writeback</p></blockquote><p>转发的工作方式</p><ol><li>来自EX/MEM和MEM/WB流水线寄存器的输入总是被反馈回ALU的输入端</li><li>如果转发硬件检测到前一个ALU操作已经对当前ALU操作的原寄存器进行了写入操作，则控制逻辑选择转发结果作为ALU输入，而不是选择从寄存器堆中读区的值</li></ol><center><img src="https://miaochenlu.github.io/picture/屏幕快照 2019-10-13 下午2.56.04.png" srcset="/img/loading.gif" style="zoom: 30%;" /></center><p>B, 需要停顿的数据冒险</p><p>并非所有的潜在数据冒险都可以通过转发处理</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">LD</span>   <span class="hljs-built_in">R1</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">R2</span>)<span class="hljs-symbol">DSUB</span> <span class="hljs-built_in">R4</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R5</span><span class="hljs-keyword">AND </span> <span class="hljs-built_in">R6</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R7</span><span class="hljs-symbol">OR</span>   <span class="hljs-built_in">R8</span>, <span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R9</span></code></pre></div><center><img src="image-20191013151122898.png" srcset="/img/loading.gif" alt="image-20191013151122898" style="zoom:30%;" /></center><center><img src="image-20191013151314878.png" srcset="/img/loading.gif" alt="image-20191013151314878" style="zoom:25%;" /></center><h3 id="More-about-data-dependences-and-hazards"><a href="#More-about-data-dependences-and-hazards" class="headerlink" title="More about data dependences and hazards"></a>More about data dependences and hazards</h3><h4 id="A-data-dependences"><a href="#A-data-dependences" class="headerlink" title="A. data dependences"></a>A. data dependences</h4><ol><li>数据相关[真数据相关]</li></ol><p>指令i生成的结果可能会被指令j用到</p><p>指令j数据相关于指令k, 指令k数据相关于指令i</p><center><img="https://miaochenlu.github.io/picture/image-20191223102354535.png" alt="image-20191223102354535" style="zoom:50%;" /></center><ol><li>名称相关</li></ol><p>当两条指令使用相同的寄存器或者存储器位置[称为名称]， 但与该名称相关的指令之间并没有数据流动时，就会发生名称相关。</p><ul><li><p>Anti-dependence: S1 -&gt; S2 </p><p>(i)  S1 executes before S2<br>(ii) S1 reads from a location that is overwritten later by S2</p></li></ul><div class="note note-warning">            <p>WAR</p><ul><li><p>Output dependence: S1 -&gt; S2 </p><p>(i)  S1 executes before S2<br>(ii) S1 and S2 write to the same location </p></li></ul>          </div><p>WAW</p><p>由于没有在指令之间传递值, 所以antidependence和output dependence只是名称相关，不是真数据相关。改变这些指令中使用的名称[寄存器号或者存储器位置],  就可以使这些指令不再冲突。</p><h4 id="B-data-hazards"><a href="#B-data-hazards" class="headerlink" title="B. data hazards"></a>B. data hazards</h4><ul><li>RAW</li><li>WAW: 对应于output dependence。 只有在前一指令stall时允许后一指令继续执行的流水线中，才会存在WAW冒险</li><li>WAR: 对应于antidependence。</li></ul><h2 id="4-4-分支冒险"><a href="#4-4-分支冒险" class="headerlink" title="4.4 分支冒险"></a>4.4 分支冒险</h2><h3 id="i-分支冒险是什么"><a href="#i-分支冒险是什么" class="headerlink" title="i. 分支冒险是什么"></a>i. 分支冒险是什么</h3><p>执行分支指令时，修改后的PC可能等于也可能不等于PC+4。</p><p>如果分支讲PC改到其目标地址，就是选中了分支；否则就是没有选中分支。一般等到ID末尾，完成地址计算和对比之后才会改变PC</p><p>那么还不知到分支指令跳到哪里，pipeline按顺序执行的指令可能不会被执行到。</p><h3 id="ii-解决方法"><a href="#ii-解决方法" class="headerlink" title="ii. 解决方法"></a>ii. 解决方法</h3><p>一旦在ID期间检测到分支，就对该分支之后的指令重新取值。但是这样处理的问题是，如果分支没有被选中，所以事实上已经正确提取了指令，所以IF的重复没有必要</p><p><img src="image-20191021095111.png" srcset="/img/loading.gif" alt="image-20191021095111" style="zoom:50%;" /></p><p>所以，如何降低流水线分支代价？</p><p>4种简单的编译时机制</p><h4 id="A-冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标"><a href="#A-冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标" class="headerlink" title="A. 冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标"></a>A. 冻结或者冲刷流水线，保留或删除分支之后的所有指令，直到知道分支目标</h4><h4 id="B-将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。"><a href="#B-将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。" class="headerlink" title="B. 将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。"></a>B. 将每个分支看作未选中分支，允许硬件继续执行，就好像分支未被执行一样。</h4><p>这种预测未选中机制的实现方式是继续提取指令，就好像分支指令时一条正常指令一样。但是，如果分支被选中，就要将已经提取的指令转化为空操作，重新开始在目标地址提取指令。</p><p>这一机制的复杂性在于要知道处理器可能何时被指令改变，以及如何撤销这种改变</p><center><img src="image-20191014112116582.png" srcset="/img/loading.gif" alt="image-20191014112116582" style="zoom:35%;" /></center><h4 id="C-将所有分支都看作选中分支"><a href="#C-将所有分支都看作选中分支" class="headerlink" title="C. 将所有分支都看作选中分支"></a>C. 将所有分支都看作选中分支</h4><p>只要对分支指令进行了译码并且计算了目标地址，就假定该分支被选中，开始在目标位置提取和执行。</p><p>但是在我们的五级流水线中，不可能在知道分支输出结果之前知道目标地址，所以这对我们没什么用。</p><h4 id="D-延迟分支"><a href="#D-延迟分支" class="headerlink" title="D. 延迟分支"></a>D. 延迟分支</h4><blockquote><p>分支指令</p><p>依序后续指令[位于delay slots]</p><p>选中时的分支指令</p></blockquote><p>获得编译器支持，编译器让后续指令有效并且可用</p><center><img src="image-20191021095901298.png" srcset="/img/loading.gif" alt="image-20191021095901298" style="zoom: 40%;" ></center><p>延迟调度有局限性，这个局限性是因为</p><blockquote><ol><li>可以排在延迟时隙[delay slots]中的指令有限制</li><li>编译时预测一个分支是否可能被选中的能力有限。为了提高编译器填充delay slots的能力，大多数具有条件分支的处理器引入了<em>canceling</em> or <em>nullifying</em> branch . 在取消分支中，指令包含了预测分支的方向。当分支行为和预期一致时，分支延迟时隙中的指令就想普通的延迟分支一样执行。预测错误时，分支延迟时隙中的指令转为空操作。</li></ol></blockquote><p>看一下这些不同的解决方法效率有什么差别</p><center><img src="image-20191021101747938.png" srcset="/img/loading.gif" alt="image-20191021101747938" style="zoom:50%;" ></center><p>考虑flush pipeline</p><p>unconditional branch指的是像j, jal这种的，这些直到Decode才会知道分支目标，所以penalty=2</p><p>其他conditional，像beq等，需要EXE才知道是否要跳转，所以penalty=3</p><p>这样，考虑predicted untaken</p><p>unconditional 指令被预测不执行，但是一定会执行，代价是2</p><p>conditional的如果没有执行，和预测一致，代价为0。如果和预测不一致，代价为3</p><p>考虑predicted taken</p><p>如果和预测一致。那么在Branch指令的EXE阶段才能知道分支目标，所以要stall 2个时钟周期才能跳转</p><p><br></p><p>当流水线越来越深，分支的潜在代价增加，使用延迟分支是不够的。要更积极地去预测分支。静态机制[依赖编译时信息，成本低]，动态预测[依据程序特性]</p><h4 id="i-静态分支预测"><a href="#i-静态分支预测" class="headerlink" title="i. 静态分支预测"></a>i. 静态分支预测</h4><p>事先收集数据，根据数据来预测分支</p><h4 id="ii-动态分支预测"><a href="#ii-动态分支预测" class="headerlink" title="ii. 动态分支预测"></a>ii. 动态分支预测</h4><p>使用分支预测缓冲区[Branch-Prediction Buffer].</p><p>这是一个cache，分支指令地址的低位部分用来索引，所有访问都会hit。</p><p>这个存储器包含一个bit来标示这个分支最近是否被选中。这个bit可以用来为接下来的这条分支提供指导。如果预测结果和bit不一致，反转bit; 一致则不反转</p><p>但是只有1bit来标示会存在一点问题，比如分支一直被选中，但是某一次没有被选中，bit也会反转，这种反转其实没有必要，会影响效率。</p><p>所以这里提出了2位预测机制。</p><p>两位预测机制，预测必须连续错过两次才会进行修改。</p><center><img src="image-20191021103246990.png" srcset="/img/loading.gif" alt="image-20191021103246990" style="zoom:50%;" ></center><h1 id="5-如何实现流水线"><a href="#5-如何实现流水线" class="headerlink" title="5. 如何实现流水线"></a>5. 如何实现流水线</h1><p>MIPS CPU多周期实现</p><center><img src="image-20191021105802697.png" srcset="/img/loading.gif" alt="image-20191021105802697" style="zoom:45%;" ></center><h2 id="Basic-Pipeline"><a href="#Basic-Pipeline" class="headerlink" title="Basic Pipeline"></a>Basic Pipeline</h2><center><img src="image-20191021110018403.png" srcset="/img/loading.gif" alt="image-20191021110018403" style="zoom:45%;" ></center><h3 id="i-IF"><a href="#i-IF" class="headerlink" title="i. IF"></a>i. IF</h3><div class="hljs"><pre><code class="hljs cpp">IF/ID.IR = Mem[PC];<span class="hljs-comment">//取指令</span><span class="hljs-keyword">if</span>((EX/MEM.opcode == branch) &amp;&amp; EX/MEM.cond) &#123;  IF/IR.NPC = EX/MEM.ALUOutput;  PC = EX/MEM.ALUOutput;&#125; <span class="hljs-keyword">else</span> &#123;  IF/IR.NPC = PC + <span class="hljs-number">4</span>;  PC = PC + <span class="hljs-number">4</span>;&#125;</code></pre></div><h3 id="ii-ID"><a href="#ii-ID" class="headerlink" title="ii. ID"></a>ii. ID</h3><div class="hljs"><pre><code class="hljs cpp">ID/EX.A = Regs[IF/ID.IR[rs]];ID/EX.B = Regs[IF/ID.IR[rt]];ID/EX.NPC = IF/ID.NPC;ID/EX.IR = IF/ID.IR;ID/EX.Imm = sign-extend(IF/ID.IR[immediate]);</code></pre></div><h3 id="iii-EX"><a href="#iii-EX" class="headerlink" title="iii. EX"></a>iii. EX</h3><h4 id="A-ALU-EX"><a href="#A-ALU-EX" class="headerlink" title="A. ALU EX"></a>A. ALU EX</h4><div class="hljs"><pre><code class="hljs cpp">EX/MEM.IR = ID/EX.IR;执行以下之一<span class="hljs-number">1.</span> EX/MEM.ALUOutput = ID/EX.A func ID/EX.B;<span class="hljs-number">2.</span> EX/MEM.ALUOutput = ID/EX.A op ID/EX.Imm</code></pre></div><h4 id="B-Load-Store-EX"><a href="#B-Load-Store-EX" class="headerlink" title="B. Load Store EX"></a>B. Load Store EX</h4><div class="hljs"><pre><code class="hljs cpp">EX/MEM.IR to ID/EX.IR;EX/MEM.ALUOutput = ID/EX.A + ID/EX.imm;EX/MEM.B = ID/EX.B;</code></pre></div><h4 id="C-Branch-EX"><a href="#C-Branch-EX" class="headerlink" title="C. Branch EX"></a>C. Branch EX</h4><div class="hljs"><pre><code class="hljs cpp">EX/MEM.ALUOutput = ID/EX.NPC + (ID/EX.Imm &lt;&lt; <span class="hljs-number">2</span>);EX/MEM.cond = (ID/EX.A == <span class="hljs-number">0</span>);</code></pre></div><h3 id="iv-MEM"><a href="#iv-MEM" class="headerlink" title="iv. MEM"></a>iv. MEM</h3><h4 id="A-ALU-MEM"><a href="#A-ALU-MEM" class="headerlink" title="A. ALU MEM"></a>A. ALU MEM</h4><div class="hljs"><pre><code class="hljs cpp">MEM/WB.IR = EX/MEM.IR;MEM/WB.ALUOutput = EX/MEM.ALUOutput;</code></pre></div><h4 id="B-Load-Store-MEM"><a href="#B-Load-Store-MEM" class="headerlink" title="B. Load Store MEM"></a>B. Load Store MEM</h4><div class="hljs"><pre><code class="hljs cpp">MEM/WB.OR = EX/MEM.IR;<span class="hljs-number">1.</span> MEM/WB.LMD = Mem[EX/MEM.ALUOutput];<span class="hljs-number">2.</span> Mem[EX/MEM.ALUOutput] = EX/MEM.B;</code></pre></div><h3 id="v-WB"><a href="#v-WB" class="headerlink" title="v. WB"></a>v. WB</h3><h4 id="A-ALU-WB"><a href="#A-ALU-WB" class="headerlink" title="A. ALU WB"></a>A. ALU WB</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> Regs[MEM/WB.IR[rd]] = MEM/WB.ALUOutput;<span class="hljs-number">2.</span> Resg[MEM/WB.IR[rt]] = MEM/WB.ALUOutput;</code></pre></div><h4 id="B-Load-Store-WB"><a href="#B-Load-Store-WB" class="headerlink" title="B. Load Store WB"></a>B. Load Store WB</h4><div class="hljs"><pre><code class="hljs cpp">For load onlyRegs[MEM/WB.IR[rt]] = MEM/WB.LMD;</code></pre></div><h2 id="Control-the-Pipeline"><a href="#Control-the-Pipeline" class="headerlink" title="Control the Pipeline"></a>Control the Pipeline</h2><p>instruction issue:</p><blockquote><p>一条指令从ID移入EX的过程</p></blockquote><p>对于整数流水线，所有数据冒险都可以在ID进行检查。</p><p>如果存在数据冒险，这个指令将会在issue之前停顿。</p><p>同样，我们可以确定在ID期间需要哪种转发，并设定适当的控制。</p><center><img src="image-20191021115323894.png" srcset="/img/loading.gif" alt="image-20191021115323894" style="zoom:35%;" /></center><p>pipeline overhead</p><p>due to stage imbalance, pipeline register setup</p><h3 id="Deal-with-forwarding"><a href="#Deal-with-forwarding" class="headerlink" title="Deal with forwarding"></a>Deal with forwarding</h3><center><img="https://miaochenlu.github.io/picture/image-20191222210658336.png" alt="image-20191222210658336" style="zoom:50%;" /></center><h1 id="6-扩展MIPS流水线，以处理多周期操作"><a href="#6-扩展MIPS流水线，以处理多周期操作" class="headerlink" title="6. 扩展MIPS流水线，以处理多周期操作"></a>6. 扩展MIPS流水线，以处理多周期操作</h1><p>扩展mips流水线，以处理浮点运算</p><p>浮点运算的问题</p><blockquote><p>要求所有浮点运算在1个周期内完成时不现实的，甚至2个时钟周期都不太可能</p><p>如果想要在一个时钟周期内完成，就必须降低clock rate, 或者增加大量的逻辑单元。</p><p>所以</p><ul><li>为了完成操作，EX周期可能要根据需要重复多次</li><li>可能存在多个浮点功能单元，如果待发射指令会导致浮点所用功能单元的结构冒险，或者数据冒险，就会出现停顿。</li></ul></blockquote><p>4个独立的功能单元</p><ul><li>主整数单元，处理load, store, 整数ALU operation, branch</li><li>浮点与整数乘法器</li><li>浮点加法器，处理浮点加、减和转换</li><li>浮点和整型除法器</li></ul><p>假定这些功能单元的执行级没有实现流水化</p><center><img="https://miaochenlu.github.io/picture/image-20191111101801471.png" alt="image-20191111101801471" style="zoom:50%;" /></center><p>两个指标</p><ul><li><p>latency</p><p>the number of intervening cycles between an instruction that produces a result and an instruction that uses the result. 一条指令产生结果后，下一条指令等待多久才可以使用这个结果。注意，是等待。</p><blockquote><p>Essentially, pipeline <strong>latency</strong> is 1 cycle less than the depth of the execution pipeline, which is the number of stages from the <strong>EX stage</strong> to the stage that produces the result </p></blockquote></li><li><p>initiation/repeat interval</p><p>同一类型的指令执行之间必须间隔的周期数。比如，integer ALU的一条指令开始执行，下一条integer ALU指令需要在他后面一个周期才能开始执行</p></li></ul><center><img="https://miaochenlu.github.io/picture/IMG_C3E4F59B24C4-1.png" alt="IMG_C3E4F59B24C4-1" style="zoom:50%;" /></center><p><img src="IMG_C3E4F59B24C4.png" srcset="/img/loading.gif" alt="IMG_C3E4F59B24C4-1" style="zoom:50%;" /></p><p>instruction issue: 从ID到EX的阶段</p><p><center><img="image-20191111103138887.png" alt="image-20191111103138887" style="zoom:50%;" /></center></p><p><center><img="image-20191111104720076.png" alt="image-20191111104720076" style="zoom:50%;" /></center></p><table>  <tr>    <td>      <img src="image-20191111103409484.png" srcset="/img/loading.gif" alt="image-20191111103409484" style="zoom:50%;" />    </td>    <td>      <img src="image-20191111103455864.png" srcset="/img/loading.gif" alt="image-20191111103455864" style="zoom:50%;" />    </td>  </tr></table><table>  <tr>    <td>      <img src="image-20191111103637824.png" srcset="/img/loading.gif" alt="image-20191111103637824" style="zoom:50%;" />    </td>    <td>      <img src="image-20191111104058863.png" srcset="/img/loading.gif" alt="image-20191111104058863" style="zoom:50%;" />    </td>  </tr></table>]]></content>
    
    
    <categories>
      
      <category>Computer Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer network--物理层</title>
    <link href="/2019/09/17/ComputerNetwork/PhysicalLayer/"/>
    <url>/2019/09/17/ComputerNetwork/PhysicalLayer/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据通信的理论基础"><a href="#1-数据通信的理论基础" class="headerlink" title="1 数据通信的理论基础"></a>1 数据通信的理论基础</h1><h2 id="1-1傅里叶分析"><a href="#1-1傅里叶分析" class="headerlink" title="1.1傅里叶分析"></a>1.1傅里叶分析</h2><p>任何一个行为合理周期为T的函数g(t)，都可以表示成正弦函数和余弦函数组成的无穷级数</p><script type="math/tex; mode=display">g(t)=\frac{1}{2}c+\sum_{n=1}^{\infty}a_nsin(2\pi nft)+\sum_{n=1}^{\infty}b_ncos(2\pi nft)</script><p>其中$f=\frac{1}{T}$是基本频率，$a_n$和$b_n$是n次谐波的正弦振幅和余弦振幅,c是常数</p><p><br/></p><h2 id="1-2-带宽有限的信号"><a href="#1-2-带宽有限的信号" class="headerlink" title="1.2 带宽有限的信号"></a>1.2 带宽有限的信号</h2><p>我们考虑一个特殊的例子：</p><p>传输ASCII字符b,这个字符被编码成一个8比特长的字节，01100010</p><p>可以得到系数</p><center><img src="image-20190917211816031.png" srcset="/img/loading.gif" alt="image-20190917211816031" style="zoom:50%;" /></center><blockquote><p> 所有传输设施在传输过程中都要损失一些能量    </p><p> 如果所有傅里叶分量都等量衰减，则结果信号将会在振幅上有所减小，但形状不会变。  </p><p>但是，实际情况是，所有传输设施对于不同傅里叶分量的衰减程度并不相同，这会导致接收端接收到的信号发生<strong>变形</strong>。  </p><p>一般对导线来说，在[0,$f_c$]的频率范围，振幅在传输过程中不回衰减，而在$f_c$这个截止频率之上的所有频率的振幅都会有不同程度的减弱。    </p><p>这个在传输过程中振幅不回明显减弱的频率的宽度就称为<strong>带宽</strong>   </p><p>但是截止频率不是一个突变的量，不是说到达某个阈值，振幅就突然减弱了，所以通常引用的带宽是指从0到接收能量保留一半到那个频率位置</p></blockquote><p>带宽是传输介质的一种物理特性，取决于介质  </p><p>一般将从0到某个最大频率的信号称为<strong>基带信号</strong>，将被搬移并占用某个更大频率范围的信号称为<strong>通带信号</strong>  </p><center><img src="image-20190917211449784.png" srcset="/img/loading.gif" alt="image-20190917211449784" style="zoom: 67%;" /></center><p><br/></p><h4 id="带宽很低，会发生什么？"><a href="#带宽很低，会发生什么？" class="headerlink" title="带宽很低，会发生什么？"></a>带宽很低，会发生什么？</h4><p>如果带宽很低，则只有几个最低频率才能被传输</p><p>假设比特率为$b$ bit/s[每秒发送8个比特]</p><p>则发送8个比特所需要的时间是$\frac{8}{b}$秒</p><p>所以第一个谐波频率是$\frac{b}{8}$赫兹</p><p>如果截止频率是3000hz,则可以通过的最高谐波数为</p><script type="math/tex; mode=display">\frac{3000}{\frac{8}{b}}</script><center><img src="image-20190917213738345.png" srcset="/img/loading.gif" alt="image-20190917213738345" style="zoom:50%;" /></center><p>如上图所示，如果能发送的频率数很少，我们就没办法精确表示周期函数</p><p><br/></p><h2 id="1-3-信道的最大数据速率"><a href="#1-3-信道的最大数据速率" class="headerlink" title="1.3 信道的最大数据速率"></a>1.3 信道的最大数据速率</h2><p><a href="https://blog.csdn.net/supreme42/article/details/7734763" target="_blank" rel="noopener">一些概念</a></p><p>波特率[baud rate/ symbol rate]</p><blockquote><p>波特率指的是信号每秒钟电平变化的次数，单位是<em>Hz</em></p></blockquote><p>比特率</p><blockquote><p>信号每秒钟传输的数据的位数。计算机中数据都是用<em>0</em>，<em>1</em>表示的，所以比特率也就是每秒钟传输<em>0</em>和<em>1</em>的个数，单位是<em>bps</em>[<em>bit per second</em>]</p></blockquote><p>波特率和比特率的关系</p><blockquote><p>我们可以假设一个信号只有两个电平，那么这个时候可以把低电平理解为<em>“0”</em>，高电平理解为<em>“1”</em>，这样每秒钟电平变化的次数也就是传输的<em>0</em>，<em>1</em>个数了，即比特率 <em>=</em> 波特率。</p><p>但是有些信号可能不止两个电平，比如一个四电平的信号，那么每个电平就可以被理解成<em>“00”</em>，<em>“01”</em>，<em>“10”</em>，<em>“11”</em>，这样每次电平变化就能传输两位的数据了，即比特率 <em>= 2 ×</em> 波特率。</p><p>一般的，$bit\,rate = buad\,rate × log_2V$，这里V就是信号电平的个数。</p></blockquote><p>Nyquist证明：如果一个任意信号通过一个带宽为B的低通滤波器，那么只要进行每秒2B次确切采样[一个周期采样2次]，就可以完全重构出被过滤的信号</p><p>不考虑噪声，如果信号包含了V个离散等级，那么公式可以写为</p><script type="math/tex; mode=display">最大数据速率=2Blog_2V(bit/s)</script><p>[最大symbol rate=$2B\,symbol/s$]</p><blockquote><p>每秒采样2B次，也就是采样了2B个电平信号</p><p>也就是采样了2BlogV个bits</p></blockquote><p>事实上，要想重构出信号，每秒2B次采样是不够的，要多一些才够。</p><center><img src="9FC21EC72573A17040AD0FCD3C37A790.png" srcset="/img/loading.gif" alt="9FC21EC72573A17040AD0FCD3C37A790" style="zoom:10%;" /></center><p><br/></p><h4 id="接下来考虑如果存在随机噪声"><a href="#接下来考虑如果存在随机噪声" class="headerlink" title="接下来考虑如果存在随机噪声"></a>接下来考虑如果存在随机噪声</h4><script type="math/tex; mode=display">信噪比(SNR)=\frac{信号功率}{噪声功率}=\frac{S}{N}</script><p>通常将其写成对数形式$10log_{10}\frac{S}{N}$,单位为分贝. </p><p>香农得出：对于一条带宽为B赫兹，噪声比是$\frac{S}{N}$的有噪声通道，他的最大数据传输速率是. </p><script type="math/tex; mode=display">最大比特率=Blog_2{(1+\frac{S}{N})}</script><h2 id="2-引导性传输介质-有线传输"><a href="#2-引导性传输介质-有线传输" class="headerlink" title="2 引导性传输介质[有线传输]"></a>2 引导性传输介质[有线传输]</h2><p>物理层的作用是将bit从一条机器传输到另一台机器。传输所用的物理介质会在传输带宽、延迟、成本等方面产生差别。</p><p>可以将介质分为</p><ul><li>引导性介质：如铜线、光纤</li><li>非引导性介质：如卫星、激光</li></ul><p><br/></p><h3 id="2-1-磁介质"><a href="#2-1-磁介质" class="headerlink" title="2.1 磁介质"></a>2.1 磁介质</h3><p>Never underestimate the bandwidth of station wagon full of tapes hurtling down the highway.</p><h3 id="2-2-双绞线"><a href="#2-2-双绞线" class="headerlink" title="2.2 双绞线"></a>2.2 双绞线</h3><p>构成</p><blockquote><p>双绞线由两根铜线以螺旋状的形式紧紧地绞在一起。</p></blockquote><p>之所以要绞在一起，是因为这样不同电线产生的干扰波会相互抵消，显著降低电线的辐射。</p><p>并且，信号以两根电线的电压差来承载，这样对外部噪声有更好的免疫力，因为噪声对两根电线的干扰是相同的，因此电压差不会改变。</p><p><br/></p><p>双绞线既可以传输模拟信号，也可以传输数字信号。</p><p>传输方向：</p><ul><li>全双工链路[full-duplex]：可以双向同时使用的链路</li><li>半双工链路half-duplex]：可以双向使用但一次只能使用一个方向</li><li>单工链路[simplex]：只允许一个方向上传输</li></ul><p>双绞线的type:</p><blockquote><p>– Category 5 [100Mbps, 1Gbps]<br>– Category 6 [10Gbps]<br>– Category 7 [Shielded Twisted Pair]</p></blockquote><center><img src="image-20191007125121828.png" srcset="/img/loading.gif" alt="image-20191007125121828" style="zoom:33%;" /></center><p>双绞线的缺点是：</p><p>传输距离远的话，信号衰减很厉害，需要使用中继器</p><h3 id="2-3-同轴电缆-coaxial-cable"><a href="#2-3-同轴电缆-coaxial-cable" class="headerlink" title="2.3 同轴电缆[coaxial cable]"></a>2.3 同轴电缆[coaxial cable]</h3><p>构成：</p><blockquote><p>硬的铜芯，外面包上一层绝缘材料，绝缘材料的外面是网状圆柱导体，外层导体再覆盖上一层保护塑料外套</p></blockquote><center><img src="image-20191007133601513.png" srcset="/img/loading.gif" alt="image-20191007133601513" style="zoom: 33%;" /></center><p>特点：</p><blockquote><p>同轴电缆的结构和屏蔽性使得它既有很高的带宽，又有很好的抗噪性。</p><p>这点比双绞线更优秀，因此也比双绞线传的远</p></blockquote><h3 id="2-4-电力线-power-line"><a href="#2-4-电力线-power-line" class="headerlink" title="2.4 电力线[power line]"></a>2.4 电力线[power line]</h3><center><img src="image-20191007133946196.png" srcset="/img/loading.gif" alt="image-20191007133946196" style="zoom: 33%;" /></center><h3 id="2-5-Fiber-optics"><a href="#2-5-Fiber-optics" class="headerlink" title="2.5 Fiber optics"></a>2.5 Fiber optics</h3><center><img src="page40image34686176.png" srcset="/img/loading.gif" alt="page40image34686176.jpg" style="zoom:33%;" /></center><p>Types:</p><blockquote><p>Multimode多模：many different rays</p><p>Unimode单模：single rays, longer distance</p></blockquote><p>Transmission of light through fiber:</p><blockquote><p>-Attenuation [衰减] of light through fiber in the infrared region.</p><p>– Three wavelength bands are used for optical communication. They are centered at 0.85, 1.30, and 1.55 micros [微米].</p></blockquote><center><img src="page41image34714624.png" srcset="/img/loading.gif" alt="page41image34714624.jpg" style="zoom: 33%;" /></center><h4 id="光缆："><a href="#光缆：" class="headerlink" title="光缆："></a><u>光缆</u>：</h4><p>构成：</p><blockquote><p>中间core是玻璃芯，光秒冲通过它传播</p><p>玻璃芯外面是一个玻璃覆盖层[cladding]，覆盖层的折射率比玻璃低，这样可以限制所有光都限制在玻璃芯内[全反射]</p><p>最外面是一层塑料封套[jacket],用来保护里面的玻璃包层</p><p>光纤通常被扎捆成束，最外面再加一层保护套</p></blockquote><center><img src="page42image34731632.png" srcset="/img/loading.gif" alt="page42image34731632.jpg" style="zoom:35%;" /></center><p>信号源一半有两种光源：发光LED和半导体激光</p><center><img src="page44image34725184.png" srcset="/img/loading.gif" alt="page44image34725184.jpg" style="zoom:33%;" /></center><h4 id="光纤和铜线的比较"><a href="#光纤和铜线的比较" class="headerlink" title="光纤和铜线的比较"></a><u>光纤和铜线的比较</u></h4><p>– Advantages</p><ul><li>Higher bandwidths and Low attenuation.</li><li>Not being affected by power surges, electromagnetic interference, or power failures.</li><li>Not affected by corrosive chemicals in the air.</li><li>Thin and lightweight.</li><li>Fibers do not leak light and quite difficult to tap.</li></ul><p>– Disadvantages</p><ul><li><p>Less familiar technology.</p><p>要求较高的操作技能，光纤被过度弯曲容易折断</p></li><li><p>Fiber interfaces more expensive.</p></li></ul><p>– Conclusion: For new routes [longer ones], fiber win</p><h1 id="3-无线传输"><a href="#3-无线传输" class="headerlink" title="3 无线传输"></a>3 无线传输</h1><h2 id="3-1电磁频谱"><a href="#3-1电磁频谱" class="headerlink" title="3.1电磁频谱"></a>3.1电磁频谱</h2><center><img src="image-20191007140913262.png" srcset="/img/loading.gif" alt="image-20191007140913262" style="zoom:30%;" /></center><p>由香农定理我们知道一个电磁波的信号能够携带的信息量与带宽成正比，从图中可以看到光纤带宽是多么宽</p><p>Some spread its frequency over a <em>wide frequency band</em>[spread spectrum, 扩频].</p><p>– Frequency hopping spread spectrum [military, 802.11, Bluetooth]</p><p>– Direct sequence spread spectrum [3G mobile phones]</p><p>– UWB [UltraWideBand]</p><center><img src="page49image35151168.png" srcset="/img/loading.gif" alt="page49image35151168.jpg" style="zoom:33%;" /></center><h3 id="3-2-Radar"><a href="#3-2-Radar" class="headerlink" title="3.2 Radar"></a>3.2 Radar</h3><h3 id="3-3-Radio-transmission"><a href="#3-3-Radio-transmission" class="headerlink" title="3.3 Radio transmission"></a>3.3 Radio transmission</h3><p>[a] In the VLF, LF, and MF bands, radio waves follow the curvature of the earth.</p><p>[b] In the HF band, they bounce off the ionosphere [电离层].</p><center><img src="page52image35155536.png" srcset="/img/loading.gif" alt="page52image35155536.jpg" style="zoom:33%;" /></center><h3 id="3-4-Microwave-transmission"><a href="#3-4-Microwave-transmission" class="headerlink" title="3.4 Microwave transmission"></a>3.4 Microwave transmission</h3><h1 id="4-数字调制与多路复用"><a href="#4-数字调制与多路复用" class="headerlink" title="4 数字调制与多路复用"></a>4 数字调制与多路复用</h1><h4 id="什么是数字调制？"><a href="#什么是数字调制？" class="headerlink" title="什么是数字调制？"></a>什么是数字调制？</h4><blockquote><p>比特与代表他们的信号之间的转换过程称为<strong>数字调制</strong></p></blockquote><p><br/></p><p>我们首先来看如何把<strong>比特直接转换成信号</strong>的方案，这些方案导致了<strong>基带传输</strong></p><blockquote><p>基带传输是指：信号的传输占有传输介质上从0到最大值之间的全部频率</p></blockquote><p>然后我们看通过调节载波信号的幅值、相位或者频率来运载比特的模式，这些方案导致了<strong>通带传输</strong></p><blockquote><p>通带传输是指：信号占据了以载波信号频率为中心的一段频带</p></blockquote><p><br/></p><p>信道通常被多个信号共享，这种信道的共享形式称为<strong>多路复用技术</strong></p><p>多路复用技术可以通过：时分复用、频分复用、码分复用 实现</p><h2 id="4-1-基带传输"><a href="#4-1-基带传输" class="headerlink" title="4.1 基带传输"></a>4.1 基带传输</h2><center><img src="image-20200101212239647.png" srcset="/img/loading.gif" alt="image-20200101212239647" style="zoom:50%;" /></center><h3 id="NRZ"><a href="#NRZ" class="headerlink" title="NRZ"></a>NRZ</h3><p>翻转代表1，不翻转代表0</p><p>一旦NRZ信号被发出去，它沿线缆传播。另一端的接收器以一定周期对信号采样，然后把采样信号转换成比特。</p><p>Problem:</p><blockquote><p>a long run of 0s or 1s leaves the signal unchanged. </p><p>After a while it is hard to tell the bits apart, as 15 zeros look much like 16 zeros unless you have a very accurate clock.</p></blockquote><p>Accurate clock: </p><blockquote><p> For all schemes that encode bits into symbols, the receiver must know <strong>when one symbol ends and the next symbol begins</strong> to correctly decode the bits.</p></blockquote><p>一般来说，accurate clock是很难做到的，那么我们该怎么办呢？</p><h4 id="Clock-Recovery"><a href="#Clock-Recovery" class="headerlink" title="Clock Recovery"></a><u>Clock Recovery</u></h4><ul><li><p>一种方法，额外拉一根时钟线，给接收器发送单独的时钟信号</p><p>这个方法不好，因为这很浪费，用一根额外的线来发送时钟，还不如用它来发送数据呢</p></li></ul><ul><li>A clever trick is to mix the clock signal with the data signal by XORing them together so that no extra line is needed.→<strong><u>Manchester Encoding</u></strong></li></ul><p>  <strong><u>Manchester Encoding</u></strong>的方法是，时钟的频率是比特率的两倍，也就是在一个bit 时间内，时钟会产生一次跳变。时钟XOR bit，产生输出</p><p>  如上图所示</p><blockquote><p> 第一个bit时间t内，传输的bit是1，时钟在[0,t/2]内是0，与bit 1异或，编码成1; </p><p> 在[t/2, t]内时钟跳变到1，与bit 0异或，编码成0.</p><p> 因此我们在第一个bit时间看到的编码先是1后翻转到0</p></blockquote><p>  问题：需要两倍于NRZ的带宽，一个bit时间他要传输两个信号</p><ul><li>As a step in the right direction, we can simplify the situation by encoding a 1 as a transition and a 0 as no transition, or vice versa.→<strong><u>NRZI</u></strong> [Non-Return-to- Zero Inverted,不归零倒相制, Used in USB]</li></ul><p>  <strong><u>NRZI</u></strong>方法是：编码有跳变表示1，编码无跳变表示0</p><p>  这样，再长的一串1都不会产生时钟恢复问题；但是一长串的0仍然有问题</p><ul><li><p>Problem: long runs of 0s?→<strong><u>4B/5B</u></strong></p><p><strong><u>4B/5B</u></strong>的方法是：每4个bits被映射成一个5bits的模式，映射按照一张固定的转换表进行，5bits的选择使得映射结果永远不会出现连续3个0</p><center><img src="page63image36690640.png" srcset="/img/loading.gif" alt="page63image36690640.png" style="zoom:33%;" /></center><p>问题：增加了25%的带宽</p></li></ul><p><br/></p><h2 id="4-2-通带传输"><a href="#4-2-通带传输" class="headerlink" title="4.2 通带传输"></a>4.2 通带传输</h2><p>一般情况下，我们在一个信道上发送信息使用的频率范围并不是从0开始的。对于无线信道来说，发送非常低频率的信号不切实际，因为天线的大小与信号的波长成比例，低频信号需要很大的天线。</p><p>发射频率一般是由监管约束和避免干扰的需要决定的</p><h3 id="4-2-1-数字调试"><a href="#4-2-1-数字调试" class="headerlink" title="4.2.1 数字调试"></a>4.2.1 数字调试</h3><center><img src="image-20191007153614734.png" srcset="/img/loading.gif" alt="image-20191007153614734" style="zoom:50%;" /></center><h4 id="A-幅移键控-ASK-Amplitude-Shift-Keying"><a href="#A-幅移键控-ASK-Amplitude-Shift-Keying" class="headerlink" title="A 幅移键控[ASK, Amplitude Shift Keying]"></a>A 幅移键控[ASK, Amplitude Shift Keying]</h4><p>通过采用不同的振幅表示0和1</p><blockquote><p>如上图(b)所示，这里采用非零幅值和一个零幅值</p></blockquote><h4 id="B-频移键控-FSK-Frequency-Shift-Keying"><a href="#B-频移键控-FSK-Frequency-Shift-Keying" class="headerlink" title="B 频移键控[FSK, Frequency Shift Keying]"></a>B 频移键控[FSK, Frequency Shift Keying]</h4><p>采用两个或更多的频率</p><blockquote><p>如上图[c]所示，使用两个频率表示0和1</p></blockquote><h4 id="C-相移键控-PSK-Phase-Shift-Keying"><a href="#C-相移键控-PSK-Phase-Shift-Keying" class="headerlink" title="C 相移键控[PSK, Phase Shift Keying]"></a>C 相移键控[PSK, Phase Shift Keying]</h4><p>在每个符号的周期中，系统把载波波形偏移0度或者180度。由于只有两个相位，这种调制方法称为二进制相移键控[BPSK]，这里的二进制表示的是两个符号</p><blockquote><p>如上图[d]所示，使用两种相位量表示0和1</p></blockquote><p>当然，我们可以用更多数量的偏移。比如用4个偏移，45，135，225，315，那么每个符号可以表示2bit。这种称为正交相移键控[QPSK, Quadrature]</p><h4 id="D-集大成者"><a href="#D-集大成者" class="headerlink" title="D 集大成者"></a>D 集大成者</h4><p>我们可以综合以上调制方式，使得每个符号表示更多的bit.</p><p>我们选择综合振幅和相位。为什么不考虑频率呢？因为频率和相位有关</p><p><br/></p><p>我们给出星座图</p><blockquote><p> 一个点的相位是以他为起点到原点的线与x轴正方向的夹角</p><p> 一个点的振幅是他到原点的距离</p></blockquote><center><img src="image-20191007154637608.png" srcset="/img/loading.gif" alt="image-20191007154637608" style="zoom: 33%;" /></center><blockquote><p>如图[b], QAM-16：</p><p>一共有16个符号，16个符号可以表示出4bits的所有组合</p><p>因此一个符号可以传输4个比特</p><p>同样，如图[c], QAM-64</p><p>一共有64个符号，一个符号可以传输6bits [..$2^6=64$]</p></blockquote><h2 id="4-3-Multiplexing"><a href="#4-3-Multiplexing" class="headerlink" title="4.3 Multiplexing"></a>4.3 Multiplexing</h2><h3 id="4-3-1-频分复用-FDM-Frequency-Division-Multiplexing"><a href="#4-3-1-频分复用-FDM-Frequency-Division-Multiplexing" class="headerlink" title="4.3.1 频分复用[FDM,Frequency Division Multiplexing]"></a>4.3.1 频分复用[FDM,Frequency Division Multiplexing]</h3><p>利用通带传输的优势使多个用户共享一个信道。</p><p>FDM将频谱分成几个频段，每个用户完全拥有其中一个频段来发送自己的信号</p><center><img src="image-20191005234836200.png" srcset="/img/loading.gif" alt="image-20191005234836200" style="zoom: 40%;" /></center><h4 id="正交频分复用-OFDM-orthogonal"><a href="#正交频分复用-OFDM-orthogonal" class="headerlink" title="正交频分复用[OFDM,orthogonal]"></a>正交频分复用[OFDM,orthogonal]</h4><p>信道带宽被分成许多独立发送数据的子载波，每个子载波之间频率的间隔是$\Delta f$</p><p>每个子载波发出的信号虽然可以扩散到相邻子载波，但是每个子载波的频率响应被设计成在相邻子载波的中心为0。因此，可以在子载波中心频率采样而不会收到其邻居的干扰</p><center><img src="image-20191007160446233.png" srcset="/img/loading.gif" alt="image-20191007160446233" style="zoom:40%;" /></center><h3 id="4-3-2-时分复用"><a href="#4-3-2-时分复用" class="headerlink" title="4.3.2 时分复用"></a>4.3.2 时分复用</h3><p>用户以循环的方式轮流工作。每个用户周期性获得整个带宽非常短的一个时间</p><center><img src="image-20191005234914576.png" srcset="/img/loading.gif" alt="image-20191005234914576" style="zoom:40%;" /></center><h3 id="4-3-3-码分复用"><a href="#4-3-3-码分复用" class="headerlink" title="4.3.3 码分复用"></a>4.3.3 码分复用</h3><p>传输一个bit的时间被划分成m个更短的时间间隔，称这个时间间隔为<u>码片</u>[chip]。每个站分配得到唯一的m位码，称为 <u>码片序列</u></p><p>如果要发送bit 1,站就发送分配给他的码片序列；如果要发送bit 0,站就发送分配给他的码片序列的反码。</p><blockquote><p>m=8,即一个bit时间传输的码片序列是8位的。</p><p>如果A站分配到的码片序列为[-1-1-1+1+1-1+1+1]</p><p>那么如果A想发送bit 1，就发送码片序列[-1-1-1+1+1-1+1+1]</p><p>如果A想发送 bit 0, 就发送码片序列[+1+1+1-1-1+1-1-1]</p></blockquote><p>码片序列的要求：</p><blockquote><p> 所有的码片序列都要两两正交</p></blockquote><center><img src="image-20191006000007082.png" srcset="/img/loading.gif" alt="image-20191006000007082" style="zoom:35%;" /></center><p>A,B,C,D 是发送信号的4个station，他们的码片序列两两正交。</p><p>S1,S2,…S6是6个例子,S6表示这个比特时间A,B,D发送了bit 1，C发送了bit 0。但是我们收到的是S6这个不同站的信号都混淆在一起的整体。怎么把C站发送的比特提取出来呢？</p><p>方法是S6与C做归一化内积。即$S_6\cdot C=[2-2+0-2+0-2-4+0]/8=-1$</p><p>因此我们知道在S6所处的这个比特时间内，C站传输了bit 0。</p><blockquote><p>内积结果</p><p>=1 说明该站发送了 bit 1</p><p>=-1说明该站发送了bit 0</p><p>=0 说明该站没有发送数据</p></blockquote><h1 id="5-公共电话交换网络"><a href="#5-公共电话交换网络" class="headerlink" title="5 公共电话交换网络"></a>5 公共电话交换网络</h1><p>How to connect computers?</p><blockquote><p>For small number of computers and a local area</p><ul><li>LAN </li></ul><p>For a large number of computers or a wide area or lacking right of way</p><ul><li>PSTN [Public Switched Telephone Network]</li></ul></blockquote><h2 id="5-1-Structure-of-the-Telephone-System"><a href="#5-1-Structure-of-the-Telephone-System" class="headerlink" title="5.1 Structure of the Telephone System"></a>5.1 Structure of the Telephone System</h2><p>电话网络的变迁</p><center><img src="image-20191007161859322.png" srcset="/img/loading.gif" alt="image-20191007161859322" style="zoom:40%;" /></center><p>Bell system model</p><p>Levels:</p><ul><li>End office 本地局</li><li>toll office 长途局</li><li>primary office 初级局</li><li>Sectional office 地区局</li><li>Regional office 区域局</li></ul><p>Major components </p><ul><li><p>Local loops [本地回路]: 进入家庭和公司的模拟双绞线</p></li><li><p>Trunks [干线]: 连接交换局的数字光纤</p></li><li><p>Switching offices [交换局]:电话呼叫在这里从一条中继线被接入另一条中继线</p></li></ul><center><img src="image-2019100742053.png" srcset="/img/loading.gif" alt="屏幕快照 2019-10-07 下午4.20.53" style="zoom:50%;" /></center><h2 id="5-1-本地回路：调制解调器、ADSL、光纤"><a href="#5-1-本地回路：调制解调器、ADSL、光纤" class="headerlink" title="5.1 本地回路：调制解调器、ADSL、光纤"></a>5.1 本地回路：调制解调器、ADSL、光纤</h2><h3 id="A-电话调制解调器"><a href="#A-电话调制解调器" class="headerlink" title="A 电话调制解调器"></a>A 电话调制解调器</h3><p>要在物理信道上发送比特，必须把比特转换为可以在信道上传输的模拟信号。这个方式我们在上一节已经学过。</p><p>在信号的另一端，模拟信号要被还原成比特</p><p><br/></p><p><strong><u>调制解调器</u></strong></p><p>是什么</p><blockquote><p>执行数字比特流和模拟信号流之间转换的设备就是调制解调器[modem]</p><p>调制解调器是调制器[modulator]和解调器[demodulator]的缩写</p></blockquote><center><img src="page102image35767104.png" srcset="/img/loading.gif" alt="page102image35767104.png" style="zoom:70%;" /> </center>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CA - Instruction Set</title>
    <link href="/2019/09/08/ComputerArchitecture/instructionSet/"/>
    <url>/2019/09/08/ComputerArchitecture/instructionSet/</url>
    
    <content type="html"><![CDATA[<h1 id="附录A-指令集基本原理"><a href="#附录A-指令集基本原理" class="headerlink" title="附录A 指令集基本原理 "></a><a name="ISA">附录A 指令集基本原理 </a></h1><h1 id="1-What-is-ISA"><a href="#1-What-is-ISA" class="headerlink" title="1 What is ISA?"></a>1 What is ISA?</h1><p>ISA: Instruction Set Architecture</p><p><img src="image-20190930101228492.png" srcset="/img/loading.gif" alt="image-20190930101228492" style="zoom:50%;" /></p><h1 id="2-What-types-of-ISA"><a href="#2-What-types-of-ISA" class="headerlink" title="2 What types of ISA?"></a>2 What types of ISA?</h1><h3 id="2-1-Basis"><a href="#2-1-Basis" class="headerlink" title="2.1 Basis"></a>2.1 Basis</h3><ul><li>type of internal storage</li></ul><blockquote><p>stack</p><p>accumulator</p><p>Register-memory</p><p>Register-register/load-store</p></blockquote><p><br/></p><p>先来解释一下implicit operand和explicit operand</p><ul><li>explicit operand</li></ul><p>明确到哪个地方去取的操作数，比如到某一个由指令确定的<strong><em>寄存器</em></strong>，或者内存中一个由指令确定的<strong><em>存储器地址</em></strong></p><ul><li>implicit operand</li></ul><p>不明确的取值位置，但是系统默认了。比如stack architecture就是默认到stack头部去取，accumulator architecture就是默认到accumulator中去取。</p><p><br/></p><p><img src="image-20191218224444341.png" srcset="/img/loading.gif" alt="image-20191218224444341" style="zoom:50%;" /></p><p>C=A+B的代码示例</p><p><img src="image-20191218224500000.png" srcset="/img/loading.gif" alt="image-20191218224500000" style="zoom:50%;" /></p><p>example problem</p><p><img src="image-20191218224924929.png" srcset="/img/loading.gif" alt="image-20191218224924929" style="zoom:50%;" /></p><h4 id="2-1-1-Stack-Architecture"><a href="#2-1-1-Stack-Architecture" class="headerlink" title="2.1.1 Stack Architecture"></a>2.1.1 Stack Architecture</h4><p><strong><em><u>operand</u></em></strong>:</p><blockquote><p> 2 <strong><em><u>implicit</u></em></strong> operands on the top of the stack(<strong><em>TOS</em></strong>)</p></blockquote><p>用图来看一下以下操作的过程</p><div class="hljs"><pre><code class="hljs armasm">C = A + <span class="hljs-keyword">B </span>(memory locations)<span class="hljs-keyword">Push </span>A<span class="hljs-keyword">Push </span><span class="hljs-keyword">B</span><span class="hljs-keyword">Add </span><span class="hljs-keyword">Pop </span>C</code></pre></div> <table>   <tr>     <td>       <img src="image-20190930102555608.png" srcset="/img/loading.gif" alt="image-20190930102555608" title="original"/>     </td>     <td>  <img src="image-20190930102855084.png" srcset="/img/loading.gif" alt="image-20190930102855084" title="push A"/>     </td>     <td>  <img src="image-20190930103000391.png" srcset="/img/loading.gif" alt="image-20190930103000391" title="push B"  />     </td>     <td>  <img src="image-20190930103037853.png" srcset="/img/loading.gif" alt="image-20190930103037853" title="Add"  />     </td>     <td>  <img src="image-20190930103101742.png" srcset="/img/loading.gif" alt="image-20190930103101742" title="pop C" />     </td>   </tr> </table><h4 id="2-1-2-Accumulator-Architecture"><a href="#2-1-2-Accumulator-Architecture" class="headerlink" title="2.1.2 Accumulator Architecture"></a>2.1.2 Accumulator Architecture</h4><p><strong><em><u>operand</u></em></strong></p><blockquote><p>one implicit operand: accumulator</p><p>one explicit operand: mem location</p></blockquote><p>看一下以下操作的过程</p><div class="hljs"><pre><code class="hljs fortran">C = A + BLoad AAdd BStore Caccumulator is both an <span class="hljs-keyword">implicit</span> input operand and a result</code></pre></div><table>  <tr>    <td>      <img src="image-20190930115553486.png" srcset="/img/loading.gif" alt="image-20190930115553486" title="original"/>    </td>    <td>  <img src="image-20190930115635931.png" srcset="/img/loading.gif" alt="image-20190930115635931" title="load A"/>    </td>      <td>  <img src="image-20190930115734010.png" srcset="/img/loading.gif" alt="image-20190930115734010" title="add B"/>    </td>    <td>  <img src="image-20190930115804883.png" srcset="/img/loading.gif" alt="image-20190930115804883" title="store C"/>    </td>  </tr></table><h1 id="3-存储器寻址"><a href="#3-存储器寻址" class="headerlink" title="3. 存储器寻址"></a>3. 存储器寻址</h1><h2 id="3-1-解释存储器地址"><a href="#3-1-解释存储器地址" class="headerlink" title="3.1 解释存储器地址"></a>3.1 解释存储器地址</h2><p>i. 关于如何对一个较大对象中的字节排序：</p><ul><li>Little Endian : store least significant byte in the smallest address</li></ul><p><img src="image-20191014101250484.png" srcset="/img/loading.gif" alt="image-20191014101250484" style="zoom:40%;" /></p><ul><li>Big Endian : store most significant byte in the smallest address</li></ul><p><img src="image-20191014101429477.png" srcset="/img/loading.gif" alt="image-20191014101429477" style="zoom:40%;" /></p><p>ii. 字节对齐</p><p>大小为s bytes的对象，字节地址为A, 如果$A\; mod\;s = 0$ , 那么是字节对齐的</p><p><img src="image-20191014101703881.png" srcset="/img/loading.gif" alt="image-20191014101703881" style="zoom:40%;" /></p><p>为什么要对齐</p><blockquote><p>When well aligned, requires only one memory access to read one object;</p><p>If address is not well aligned, each misaligned object requires two memory accesses to fetch.</p></blockquote><h2 id="3-2-Addressing-modes"><a href="#3-2-Addressing-modes" class="headerlink" title="3.2  Addressing modes"></a>3.2  Addressing modes</h2><p><img src="image-20191014102744097-6809392.png" srcset="/img/loading.gif" alt="image-20191014102744097-6809392" style="zoom:50%;" /></p><p>References:  </p><p>[1]计算机体系结构 量化研究方法</p>]]></content>
    
    
    <categories>
      
      <category>Computer Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>classification and clustering</title>
    <link href="/2019/08/25/classification/"/>
    <url>/2019/08/25/classification/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><h3 id="什么是聚类"><a href="#什么是聚类" class="headerlink" title="什么是聚类"></a>什么是聚类</h3><p>一类数据点的集合</p><ul><li>类内相似性</li><li>类间差异性</li></ul><h2 id="衡量聚类好坏的标准"><a href="#衡量聚类好坏的标准" class="headerlink" title="衡量聚类好坏的标准"></a>衡量聚类好坏的标准</h2><ul><li>最大化类间距离</li><li>最小化类内距离</li></ul><p><br></p><p>数值闵可夫斯基距离</p><script type="math/tex; mode=display">d(X,Y)=\Vert{X-Y}\Vert_p=(\sum_{i=1}^n\vert{x_i-y_i}\vert^p)^{\frac{1}{p}}</script><ul><li><p>L1曼哈顿距离</p><script type="math/tex; mode=display">d(X,Y)=\vert{X-Y}\vert</script></li><li><p>L2欧几里得距离</p><script type="math/tex; mode=display">d(X,Y)=\sqrt{(x_1-y_1)^2+(x_2-y_2)^2}</script></li><li><p>切比雪夫距离</p><script type="math/tex; mode=display">d(X,Y)=\underset{p->\infty}{lim}(\sum_{i=1}^{n}\vert{x_i-y_i}\vert^p)^{\frac{1}{p}}=\underset{i}{max}\vert{x_i-y_i}\vert</script></li><li><p>向量-余弦相似度</p><script type="math/tex; mode=display">cos(d_1,d_2)=\frac{d_1\cdot d_2}{\Vert{d_1}\Vert\cdot \Vert{d2}\Vert}</script><p>余弦相似性是通过测量两个向量的夹角的余弦值来度量他们之间的相似性</p></li></ul><h2 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h2><p>已知观测集$(x<em>{1},x</em>{2},…,x<em>{n})$，其中每个观测都是一个d-维实向量，<em>k</em>-平均聚类要把这n个观测划分到<em>k</em>个集合中(k≤n),使得组内平方和（WCSS within-cluster sum of squares）最小。换句话说，它的目标是找到使得下式满足的聚类$S</em>{i}$</p><script type="math/tex; mode=display">arg\underset{s}{min}\underset{i=1}{\overset{k}{\sum}}\underset{x\in S_i}{\sum}\Vert{\mathbf{x}-\mathbf{u_i}}\Vert^2</script><p>其中$\mu <em>{i}$是$S</em>{i}$中所有点的均值</p><p><strong>总之：思想是最小化类内距离平方之和</strong></p><p><br></p><p>方法</p><p>随机选取k个聚类质心点，$u_1,u_2,\cdots,u_k\in\mathbb{R}^n$</p><p>重复下面过程直到收敛</p><p>​    对每一个样例i,计算其应该属于的类</p><p>​    $c^{(i)}:=arg\,\underset{\mathbf{j}}min\Vert{x^{(i)}-u_j}\Vert^2$</p><p>​    对每一个类j,重新计算该类的质心</p><p>​    $u_j:=\frac{1}{n_j}\underset{x_j\in c^{(j)}}\sum x_j$</p><p><br/></p><p><code>pseudocode</code></p><center><img src="image-20190930204646360.png" srcset="/img/loading.gif" alt="image-20190930204646360" style="zoom:50%;" /></center><p><br/></p><p><strong>特点</strong>：</p><ul><li>简单快速</li><li>聚类结果容易收到起始点影响</li><li>聚类结果在向量空间为球状[凸集]</li><li>聚类结果容易收到噪声[脏数据]影响</li></ul><center><img src="image-20190822091651085.png" srcset="/img/loading.gif" alt="image-20190822091651085" style="zoom:50%;" /></center><p>k-means是做不到第二种聚类效果的</p><p><br/></p><h2 id="K-medoids"><a href="#K-medoids" class="headerlink" title="K-medoids"></a>K-medoids</h2><p>Mean:聚类的中心</p><script type="math/tex; mode=display">u_i=\frac{1}{n_i}\sum_{x_j\in c_i}x_j</script><p>Medoid:聚类的中心数据点[到类内每个数据点到距离之和最小]</p><p><br></p><p><strong>算法</strong>：</p><p>1、把所有数据划分为k个非空子集</p><p>2、计算每个子集的中心点[mean]</p><p>3、把离中心最近的数据点[medoid]作为该子集的实际中心点</p><p>4、把所有数据点重新划分[划分到离该数据点最近的中心点]</p><p>5、重复步骤2，直到中心点不发生变化</p><center><img src="image-20190822092021862.png" srcset="/img/loading.gif" alt="image-20190822092021862" style="zoom:50%;" /></center><p><br/></p><h2 id="谱聚类"><a href="#谱聚类" class="headerlink" title="谱聚类"></a>谱聚类</h2><p>思想：把数据集看作带权无向图，将图切分成多个不相交的子图，使子图内相似度较高，子图间相似度较低</p><ul><li>$找到最小切分min\,cut(A,B)$</li></ul><p>&emsp;$cut(A,B)=\underset{i\in A,j\in B}\sum w_{ij}$</p><p>&emsp;A与B两类之间相连边的权重</p><ul><li>最大化类内连接相似度 $max(assoc(A,A)+assoc(B,B))$</li></ul><p>&emsp;$assoc(A,A)=\underset{i\in A,j\in A}\sum w_{ij}$</p><p>&emsp;A类内相连边的权重</p><ul><li>Normalized-cut</li></ul><p>&emsp;$Ncut(A,B)=\frac{cut(A,B)}{assoc(A,V)}+\frac{cut(A,B)}{assoc(B,V)}$</p><p>&emsp;要使类间相似度最小，也就是分子最小</p><p>&emsp;要使类内相似度最大，也就是（分母-分子）越大</p><p>&emsp;目标 $min\,Ncut(A,B)$</p><p><br/></p><p><strong>开始化简</strong></p><p>$cut(A,B)=assoc(A,V)-assoc(A,A)=assoc(B,V)-assoc(B,B)$</p><p>$Ncut(A,B)=\frac{cut(A,B)}{assoc(A,V)}+\frac{cut(A,B)}{assoc(B,V)}$</p><p>$=\frac{assoc(A,V)-assoc(A,A)}{assoc(A,V)}+\frac{assoc(B,V)-assoc(B,B)}{assoc(B,V)}$</p><p>$=2-(\frac{assoc(A,A)}{assoc(A,V)}+\frac{assoc(B,B)}{assoc(B,V)})$</p><p>$=2-Nassoc(A,B)$    （Nassoc(A,B)跟Ncut很像）</p><p><br/></p><p>为了化简，使用一些技巧</p><p>$\mathbf{x}\in {1,-1}^n$</p><p>$if\quad i\in A, x_i=1$   $else\quad if\quad i\in B,x_i=-1$  即在A类，x=1; 在B类，x=-1</p><p>$d<em>i=\sum_j w</em>{ij}$  也就是与i相连边的权重之和</p><p>我们的目标函数就可以变成</p><script type="math/tex; mode=display">Ncut(A,B)=\frac{cut(A,B)}{assoc(A,V)}+\frac{cut(A,B)}{assoc(B,V)}</script><p>&emsp;<script type="math/tex">=\frac{\sum_{x_i>0,x_j<0}-w_{ij}x_i x_j}{\sum_{x_i>0}d_i}+\frac{\sum_{x_i<0,x_j>0}-w_{ij}x_ix_j}{\sum_{x_i<0d_i}}</script></p><p>cut(A,B)在A类x为+1，B类为-1，要计算权重和也就变成了 $\sum<em>{x_i&gt;0,x_j&lt;0}-w\</em>{ij}x_i x_j$</p><p>assoc(A,V)计算与A中的点相连的边的权重之和，在A中的点x=+1，他上面连的边的权重 $\sum_{x_i&gt;0}d_i$</p><p><br/></p><p>继续化简</p><p>先提出两个矩阵</p><p>$W\in R^{n\times n} \, formed \, by\,w_{ij}$</p><p>$D\in R^{n\times n}\, formed\, by\,d_i$</p><script type="math/tex; mode=display">W=\left[\begin{matrix}0&w_{12}&w_{13}\\  w_{21}&0&w_{23}\\ w_{31}&w_{32}&0\end{matrix}\right]</script><script type="math/tex; mode=display">D=\left[\begin{matrix}d_1&0&0\\ 0&d_2&0\\ 0&0&d_3\end{matrix}\right]</script><p>提出一个系数</p><p>$k=\frac{\sum_{x_i&gt;0}d_i}{\sum_i d_i}$也就是与第i个点相连的边的顶点在A中的权重所占所有边权重的比例</p><p><br/></p><p>推导</p><script type="math/tex; mode=display">D-W=\left[\begin{matrix}d_1&-w_{12}&-w_{13}\\  -w_{21}&d_2&-w_{23}\\ -w_{31}&-w_{32}&d_3\end{matrix}\right]</script><p>$(1-x)$在A中x为0，在B中x为2</p><p>$(1+x)$在A中x为2，在B中x为0</p><p>$\mathbf{1}$全为1的向量</p><p><br/></p><p>先来证明</p><script type="math/tex; mode=display">4\frac{\sum_{x_i>0,x_j<0}-w_{ij}x_i x_j}{\sum_{x_i>0}d_i}=(1-\mathbf{x})^T(D-W)(1+\mathbf{x})</script><script type="math/tex; mode=display">\left[\begin{matrix}1-x_1&1-x_2&\cdots&1-x_n\end{matrix}\right]\left[\begin{matrix}d_1&-w_{12}&-w_{13}\\ -w_{21}&d_2&-w_{23}\\-w_{31}&-w_{32}&d_3\end{matrix}\right]\left[\begin{matrix}1+x_1\\1+x_2\\\cdots\\1+x_n\end{matrix}\right]</script><script type="math/tex; mode=display">=\left[\begin{matrix}(1-x_1)d_1-(1-x_2)w_{21}-\cdots -(1-x_n)w_{31}&-(1-x_1)w_{12}+(1-x_2)d_2-(1-x_3)W_{32}-\cdots -(1-x_n)w_{n2}&\cdots\end{matrix}\right] \left[\begin{matrix}1+x_1\\1+x_2\\\cdots\\1+x_n\end{matrix}\right]</script><script type="math/tex; mode=display">=(1-x_1^2)d_1-(1-x_2)(1+x_1)w_{21}-(1-x_3)(1+x_1)w_{31}-\cdots +(x_2的部分)+(\cdots)+(x_n的部分)</script><p><br/></p><p>首先可知的是</p><p>$(1-x_i^2)=0$,所以 $d_i$系数都是0，我们可以不考虑</p><p>然后 $w_{ij}$的系数是 $(1-x_i)(1+x_j)$，要使系数不为0，则 $x_i=1$,$x_j=-1$,即i在A类，j在B类</p><p>这里，我们就基本上证明了</p><script type="math/tex; mode=display">4\frac{\sum_{x_i>0,x_j<0}-w_{ij}x_i x_j}{\sum_{x_i>0}d_i}=(1-\mathbf{x})^T(D-W)(1+\mathbf{x})</script><p>再来证明 $\sum_{x_i&gt;0}d_i=k\mathbf{1}^TD\mathbf{1}$</p><script type="math/tex; mode=display">\mathbf{1}^TD\mathbf{1}=\left[\begin{matrix}1&1&\cdots &1\end{matrix}\right]\left[\begin{matrix}d_1&0&0\\0&d_2&0\\0&0&d_3\end{matrix}\right]\left[\begin{matrix}1\\1\\\cdots \end{matrix}\right]=d_1+d_2+\cdots+d_n</script><p><br/></p><p>$4Ncut(A,B)=\frac{(1-\mathbf{x})^T(D-W)(1+\mathbf{x})}{k\mathbf{1}^TD\mathbf{1}}+\frac{(1+\mathbf{x})^T(D-W)(1-\mathbf{x})}{(1-k)\mathbf{1}^TD\mathbf{1}}$</p><p><br/></p><p>继续做化简</p><p>提出另一个系数 $b=\frac{k}{1-k}$这也就是在 $\frac{A中权重}{B中权重}$</p><p>$4Ncut(A,B)=\frac{(1+\mathbf{x})^T(D-W)(1+\mathbf{x})}{k\mathbf{1}^TD\mathbf{1}}+\frac{(1-\mathbf{x})^T(D-W)(1-\mathbf{x})}{(1-k)\mathbf{1}^TD\mathbf{1}}=\frac{[(1+x)-b(1-x)]^T(D-W)[(1+x)-b(1-x)]}{b\mathbf{1}^TD\mathbf{1}}$</p><p> 令 $y=(1+x)-b(1-x)$</p><script type="math/tex; mode=display">y^TD1=\sum_{i=1}^{n}(((1+x_i)-b(1-x_i))d_i)=2\sum_{x_i>0} d_i-2b\sum_{x_i<0}d_i=0</script><script type="math/tex; mode=display">y^TDy=\sum_{i=1}^{n}(((1+x_i)-b(1-x_i))^2d_i)=\sum_{x_i>0}4d_i+\sum_{x_i<0}4b^2d_i</script><p>$\sum_{x_i&gt;0}d_i=b\sum_{x_i&lt;0}d_i$  $(\frac{A中权重}{B中权重}\cdot B中权重=A中权重)$</p><p>$\Rightarrow$ <script type="math/tex">y^TDy=4b(\sum_{x_i<0}d_i+b\sum_{x_i<0}d_i)=4b1^TD1</script></p><p><br/></p><p>综上</p><p>$\underset{x}{min}Ncut(x)=\underset{y}{min}\frac{y^T(D-W)y}{y^TDy}$</p><p>$s.t.\,y\in{2,-2b}^n,y^TD1=0$</p><p>我们放宽对y的限制</p><p>$\underset{y}{min}\frac{y^T(D-W)y}{y^TDy}，y\in R^n,y^TD1=0$</p><p>接下来讨论如何求解y</p><p><br/></p><p><u>瑞丽商</u></p><p>$Rayleigh\,Quotient$</p><p>$\underset{x}{max}\frac{x^TAx}{x^TBx}\Rightarrow \underset{x}{max}x^TAx \quad s.t.x^TBx=1$</p><p>$L(x)=x^TAx+\lambda (x^TBx-1)$</p><script type="math/tex; mode=display">x^TAx=\left[\begin{matrix}\sum_{i=1}^{n}x_iA_{i1}&\cdots\end{matrix}\right]\left[\begin{matrix}x_1\\x_2\\\cdots\\x_n\end{matrix}\right]</script><script type="math/tex; mode=display">=\sum_{s=1}^{n}x_s\sum_{i=1}^{n}x_iA_{is}</script><script type="math/tex; mode=display">\frac{\partial L(x)}{\partial x_j}=\sum_{i=1}^{n}x_iA_{ij}+\sum_{s=1}^{n}x_sA_{js}</script><p><strong>推论</strong></p><p>$f(x)=x^TAx$,则 $\frac{\partial f(x)}{\partial x}=(A+A^T)x$</p><p><br/></p><p>这样就可以推得</p><p>$\frac{\partial L(x)}{\partial x}=0\Rightarrow (A+A^T)x+\lambda(B+B^T)x=0$</p><p>如果A和B是对称矩阵</p><p>$Ax=kBx,k=-\lambda$</p><p><br/></p><p>回到原题的计算</p><p>即求 $(D-W)y=\lambda Dy$</p><p>$D^{-1}(D-W)y=\lambda y$</p><p>即求 $D^{-1}(D-W)的特征向量(舍弃最小的特征值)$</p><p><br/></p><p>插一个矩阵的求导</p><p>对于一个函数 $f: \mathbb{R}^{m\times n}\mapsto\mathbb{R}$ 从一个$m\times n$的矩阵映射到实数，我们定义f对于A的导数为</p><script type="math/tex; mode=display">\nabla_Af(A) = \left[\begin{matrix} \frac{\partial f}{\partial A_{11}} & \cdots & \frac{\partial f}{\partial A_{1n}}\\\vdots & \ddots &  \vdots \\\frac{\partial f}{\partial A_{m1}} &\cdots & \frac{\partial f}{\partial A_{mn}}\\\end{matrix}\right]</script><p>举个例子  </p><script type="math/tex; mode=display">A = \left[ \begin{matrix} A_{11} & A_{12} \\ A_{21} & A{22}\\ \end{matrix} \right]</script><p> 函数 $f:\mathbb{R}^{2\times 2}\mapsto \mathbb{R}$为</p><script type="math/tex; mode=display">f(A)=\frac{3}{2}A_{11}+5A_{12}^2+A_{21}A_{22}</script><p>可以得到</p><script type="math/tex; mode=display">\nabla_Af(A) = \left[\begin{matrix} \frac{3}{2} & 10A_{12}\\A_{22} & A_{21}\\\end{matrix}\right]</script><p><br/></p><p>整体聚类的步骤：</p><ul><li>假设 $y_1,y_2,\cdots,y_k\in R^{n\times k}$是最小的k个特征向量</li><li>令 $Y=[y_1,y_2,\cdots,y_k] \in R^{n\times k}$</li><li>矩阵Y的行可以看作原始数据的k维表示</li><li>利用k-means算法</li></ul><p><br/></p><p>为什么可以用y来做特征进行k-means聚类呢</p><p>首先要问，求出来的y是什么？</p><p>​    $\mathbf{y_i}$是Ncut(A,B)取最小值时对应的一组特征向量，y与x之间存在关系，$\mathbf{y}=(1+\mathbf{x})-b(1-\mathbf{x})$,x代表的是每个点的类别，那么我们可以认为，每个y对应着Ncut(A,B)最小时的一种分类方式  </p><p>我们得到了一个 $n\times k$的矩阵Y</p><script type="math/tex; mode=display">Y=\left[\begin{matrix}y_1^1&y_2^1&\cdots&y_k^1\\ \vdots&\vdots&\vdots&\vdots\\ y_1^n&y_2^n&\cdots&y_k^n\end{matrix}\right]</script><p>我们相当于对 $p_1=\left[\begin{matrix}y_1^1&amp;y_2^1&amp;\cdots&amp;y_k^1\end{matrix}\right]$</p><p>$p_2=\left[\begin{matrix}y_1^2&amp;y_2^2&amp;\cdots&amp;y_k^2\end{matrix}\right]$</p><p>$p_n=\left[\begin{matrix}y_1^n&amp;y_2^n&amp;\cdots&amp;y_k^n\end{matrix}\right]$</p><p>这n个元素做聚类</p><p>$p_i$的意义是在对应着第i个元素最佳的k种分类方式</p><p>对 $p_i$做聚类，也就是找到最相似的 $p_i$们聚到一起，也就是在k种分类方式中，把经常分到一组的聚到一起</p><p><br/></p><h1 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h1><p>什么是分类问题</p><p>从有标签的数据集（训练集）中提取规律，并应用规律对无标签数据集（测试集）进行分类</p><h2 id="衡量分类好坏的标准"><a href="#衡量分类好坏的标准" class="headerlink" title="衡量分类好坏的标准"></a>衡量分类好坏的标准</h2><p>混淆矩阵</p><center><img src="image-20190822101338137.png" srcset="/img/loading.gif" alt="image-20190822101338137" style="zoom:50%;" /></center><p><strong><em>精确度</em></strong></p><p>$prercision=\frac{TP}{TP+FP}$</p><p><strong><em>召回率</em></strong></p><p>$recall=\frac{TP}{TP+FN}$</p><p>$F_1$<strong><em>score</em></strong></p><p>$F_1=\frac{2}{\frac{1}{precision}+\frac{1}{rercall}}$</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>曲线拟合</p><p>泰勒展开</p><script type="math/tex; mode=display">h(x,\mathbf{\theta})=\theta_0+\theta_1x+\theta_2x^2+\cdots+\theta_nx^n=\sum_{i=0}^n\theta_ix^i</script><p>$\mathbf{x}=[1,x,x^2,\cdots,x^M]^T$</p><p>$\mathbf{\theta}=[\theta_0,\theta_1,\theta_2,\cdots,\theta_n]^T$</p><p>$h(x,\mathbf{\theta})=\mathbf{\theta}^T\mathbf{x}$</p><p><br></p><p>分类问题中的线性回归</p><p>$x\in A, h(x,\theta)=0$</p><p>$x\in B,h(x,\theta)=1$</p><p><img src="image-20190823105415045.png" srcset="/img/loading.gif" alt="image-20190823105415045" style="zoom:50%;" /></p><h4 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h4><script type="math/tex; mode=display">MSE(\theta)=\frac{1}{2}\sum_{i=1}^n(y_i-h_{\theta}(x^{(i)}))^2</script><p>目标函数</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^2</script><p>目标是求<script type="math/tex">J(\theta)=\frac{1}{2}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^2</script>取最小值时的$\theta$向量</p><p><br></p><h2 id="迹"><a href="#迹" class="headerlink" title="迹"></a>迹</h2><p>接下来介绍“迹”，“tr”。对于一个$n\times n$的矩阵 A, A的迹是他对角线上的元素之和</p><script type="math/tex; mode=display">trA = \sum_{i=1}^{n}A_{ii}</script><h3 id="迹的一些性质"><a href="#迹的一些性质" class="headerlink" title="迹的一些性质"></a>迹的一些性质</h3><script type="math/tex; mode=display">trAB = trBA</script><p>假设$A是m\times n$矩阵，B是$n\times m$矩阵</p><script type="math/tex; mode=display">A=\left[\begin{matrix}  A_{11} & \cdots &  A_{1n}\\\vdots & \ddots &  \vdots \\A_{m1} &\cdots & A_{mn}\\\end{matrix}\right]</script><script type="math/tex; mode=display">B=\left[\begin{matrix}  B_{11} & \cdots &  B_{1m}\\\vdots & \ddots &  \vdots \\B_{n1} &\cdots & B_{nm}\\\end{matrix}\right]</script><script type="math/tex; mode=display">AB=\left[\begin{matrix}  A_{11} & \cdots &  A_{1n}\\\vdots & \ddots &  \vdots \\A_{m1} &\cdots & A_{mn}\\\end{matrix}\right]\left[\begin{matrix}  B_{11} & \cdots &  B_{1m}\\\vdots & \ddots &  \vdots \\B_{n1} &\cdots & B_{nm}\\\end{matrix}\right]</script><script type="math/tex; mode=display">BA=\left[\begin{matrix}  B_{11} & \cdots &  B_{1m}\\\vdots & \ddots &  \vdots \\B_{n1} &\cdots & B_{nm}\\\end{matrix}\right]\left[\begin{matrix}  A_{11} & \cdots &  A_{1n}\\\vdots & \ddots &  \vdots \\A_{m1} &\cdots & A_{mn}\\\end{matrix}\right]</script><script type="math/tex; mode=display">trAB=\sum_{i=1}^{i=n}A_{1i}B_{i1}+\cdots+\sum_{i=1}^{i=n}A_{mi}B_{im}\\=\sum_{j=1}^{j=m}\sum_{i=1}^{i=n}A_{ji}B_{ij}\\=\sum_{i=1}^{i=n}\sum_{j=1}^{j=m}B_{ij}A_{ji}\\</script><script type="math/tex; mode=display">trBA=\sum_{j=1}^{j=m}B_{1j}A_{j1}+\cdots+\sum_{j=1}^{j=m}B_{nj}A_{jn}=\sum_{i=1}^{i=n}\sum_{j=1}^{j=m}B_{ij}A_{ji}\\</script><p>得到</p><script type="math/tex; mode=display">trAB=trBA</script><p><br/></p><p>易证</p><ul><li>$trA=trA^T$</li><li>$tr(A+B)=trA+trB$</li><li>$traA=atrA$</li></ul><p><br/></p><p>下面是迹微分的一些性质:$\vert A\vert$表示行列式</p><ol><li>$\nabla_AtrAB=B^T$</li><li>$\nabla_{A^T}f(A)=(\nabla_A f(A))^T$</li><li>$\nabla_AtrABA^TC=CAB+C^TAB^T$</li><li>$\nabla_A\vert{A}\vert=\vert{A}\vert(A^{-1})^T$ 非奇异矩阵</li></ol><p><br></p><ul><li>证明1</li></ul><script type="math/tex; mode=display">A=\left[\begin{matrix}  A_{11} & \cdots &  A_{1n}\\\vdots & \ddots &  \vdots \\A_{m1} &\cdots & A_{mn}\\\end{matrix}\right]\quadB=\left[\begin{matrix}  B_{11} & \cdots &  B_{1m}\\\vdots & \ddots &  \vdots \\B_{n1} &\cdots & B_{nm}\\\end{matrix}\right]</script><script type="math/tex; mode=display">trAB=\sum_{j=1}^{j=m}\sum_{i=1}^{i=n}A_{ji}B_{ij}\\\nabla_AtrAB=\nabla_A(\sum_{j=1}^{j=m}\sum_{i=1}^{i=n}A_{ji}B_{ij})=（B^{ij})=B^T</script><ul><li>证明2</li></ul><script type="math/tex; mode=display">左边矩阵的元素a_{ij}=\frac{\partial f}{\partial A_{ji}}\\右边矩阵的元素b_{ij}=\frac{\partial f}{\partial A_{ji}}=a_{ij}\\</script><ul><li>证明3</li></ul><script type="math/tex; mode=display">\nabla_Atr(ABA^TC)=\nabla_Atr(ABXC)\vert_{X=A^T}+\nabla_Atr(YBA^TC)\vert_{Y=A}\quad链式法则求导</script><script type="math/tex; mode=display">\nabla_Atr(ABXC)\vert_{X=A^T}=\nabla_A{A(BXC)}=(BXC)^T=C^TAB^T  \quad性质1</script><script type="math/tex; mode=display">\nabla_Atr(YBA^TC)\vert_{Y=A}=\nabla_A(C^TAB^TY^T)=\nabla_Atr(AB^TA^TC^T) \quad 考虑方阵和迹的性质</script><script type="math/tex; mode=display">\nabla_Atr(A(B^TA^TC^T))=CAB\quad性质1\\</script><ul><li>证明4</li></ul><p>令$C_{ij}$为代数余子式</p><script type="math/tex; mode=display">\vert{A}\vert=A_{1j}C_{1j}+\cdots+A_{nj}C_{nj}\\左边 a_{ij}=\frac{\partial  \vert{A}\vert}{\partial A_{ij}}\\=Cij</script><p>由此可得</p><script type="math/tex; mode=display">A=\left[\begin{matrix} C_{11} & \cdots &  C_{1n}\\\vdots & \ddots &  \vdots \\C_{n1} & \cdots & C_{nn}\\\end{matrix}\right]</script><script type="math/tex; mode=display">A^{-1}=\frac{1}{\vert{A}\vert} A^{*}\\=\frac{1}{\vert{A}\vert}\times\left[\begin{matrix} C_{11} & \cdots &  C_{n1}\\\vdots & \ddots & \vdots \\C_{1n} & \cdots & C_{nn}\\\end{matrix}\right]</script><script type="math/tex; mode=display">右边=\vert{A}\vert(A^{-1})^T=\left[\begin{matrix} C_{11} & \cdots &  C_{1n}\\\vdots & \ddots &  \vdots \\C_{n1} & \cdots & C_{nn}\\\end{matrix}\right]</script><p>解释第一条<br>假设我们有一个矩阵$B\in\mathbb{R}^{n\times m}$<br>我们可以定义一个函数$f:\mathbb{R}^{m\times n}\mapsto\mathbb{R}$<br>$f(A)=trAB$<br>这样的定义是有意义的，因为如果$A\in \mathbb{R}^{m\times n}$,那么$AB$就是一个方阵，可以求迹，因此$f$确实从$\mathbb{R}^{m\times n}$映射到$\mathbb{R}$</p><p>接下来，我们着手找到使$J(\theta)$取到最小值的$\theta$.可以从把$J$写成向量矩阵的形式开始</p><p>对于一个训练集，定义一个设计矩阵X</p><script type="math/tex; mode=display">X=\left[ \begin{matrix}--&(x^{(1)})^T&--\\--&(x^{(2)})^T&--\\&\vdots&\\--&(x^{(m)})^T&--\\\end{matrix}\right]</script><p>同样，$\overrightarrow{y}$是包含了训练集目标值的m维向量</p><script type="math/tex; mode=display">\overrightarrow{y}=\left[\begin{matrix}y^{(1)}\\y^{(2)}\\\vdots\\y^{(m)}\\\end{matrix}\right]</script><p>我们有$h_\theta(x^{(i)})=(x^{(i)})^T\theta$，可以得到</p><script type="math/tex; mode=display">X\theta-\overrightarrow{y} = X=\left[ \begin{matrix}&(x^{(1)})^T\theta&\\&(x^{(2)})^T\theta&\\&\vdots&\\&(x^{(m)})^T\theta&\\\end{matrix}\right]-\left[\begin{matrix}y^{(1)}\\y^{(2)}\\\vdots\\y^{(m)}\\\end{matrix}\right]\\=\left[\begin{matrix}&h_{\theta}(x^{(1)})-y^{(1)}&\\&\vdots&\\&h_{\theta}(x^{(m)})-y^{(m)}&\\\end{matrix}\right]</script><p>对于一个向量$\overrightarrow{z}$,有$\overrightarrow{z}^{T}\overrightarrow{z} = \sum_{i}z_{i}^{2}$</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^2\\=\frac{1}{2}(X\theta-\overrightarrow{y})^T(X\theta-\overrightarrow{y})</script><p>为了得到$J(\theta)$的最小值，对$\theta$微分</p><p>用上面的性质2，3<br>$\nabla_{A^T}f(A)=\nabla_A f(A)^T$<br>$\nabla_AtrABA^TC=CAB+C^TAB^T$<br>可以得到  </p><ol><li>$\nabla_{A^T}trABA^TC=\nabla_A(trABA^TC)^T=B^TA^TC^T+BA^TC$</li></ol><p><br/></p><p>计算得出</p><script type="math/tex; mode=display">\nabla_{\theta}J(\theta)=\nabla_{\theta}\frac{1}{2}(X\theta-\overrightarrow{y})^T(X\theta-\overrightarrow{y})</script><script type="math/tex; mode=display">=\frac{1}{2}\nabla_{\theta}(\theta^TX^TX\theta-\theta^TX^T\overrightarrow{y}-\overrightarrow{y}^{T}X\theta+\overrightarrow{y}^T\overrightarrow{y})\quad因为\nabla_{\theta}J(\theta)是实数，实数的迹是他本身</script><script type="math/tex; mode=display">=\frac{1}{2}\nabla_{\theta}tr(\theta^TX^TX\theta-\theta^TX^T\overrightarrow{y}-\overrightarrow{y}^{T}X\theta+\overrightarrow{y}^T\overrightarrow{y})</script><script type="math/tex; mode=display">=\frac{1}{2}\nabla_{\theta}(tr\theta^TX^TX\theta-2tr\overrightarrow{y}^{T}X\theta)</script><script type="math/tex; mode=display">=\frac{1}{2}(X^TX\theta+X^TX\theta-2X^T\overrightarrow{y})\quad 利用性质5,A^T=\theta,B=B^T=X^TX,C=I</script><script type="math/tex; mode=display">=X^TX\theta-X^T\overrightarrow{y}\quad利用性质1</script><p>为了得到$J(\theta)$的最小值，使$\nabla_{\theta}J(\theta)=0$, 可以得到<strong>正规方程</strong></p><script type="math/tex; mode=display">X^T X\theta=X^T\overrightarrow{y}</script><script type="math/tex; mode=display">\theta=(X^TX)^{-1}X^T\overrightarrow{y}</script><p><br/></p><h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><p><img src="image-20190823112326455.png" srcset="/img/loading.gif" alt="image-20190823112326455" style="zoom: 33%;" /></p><p>容易看到，这两种分类方法，第二种是更优的，我们可以认为在不同的分界线中，离数据点远点线是更优的</p><p>令我们需要拟合的直线为 $w^Tx+b$</p><p><br/></p><h4 id="函数间隔和几何间隔"><a href="#函数间隔和几何间隔" class="headerlink" title="函数间隔和几何间隔"></a>函数间隔和几何间隔</h4><p>给定一个训练样本 $(x^{(i)},y^{(i)})$,其中x是特征,y是结果 标签</p><p>定义函数间隔如下:</p><p>$\hat{\gamma}^{(i)} = y^{(i)}(w^Tx^{(i)} + b)$</p><p>当$y^{(i)}=1$时,$\hat{\gamma}^{(i)}$应该hi是个大整数，$y^{(i)}=-1时$ 是个大负数</p><p>函数间隔越大，我们对分类结果越确信</p><p>定义全局样本上的函数间隔为</p><p>$\hat{\gamma}=\underset{i=1,\cdots,m}{min}\hat{\gamma}^{(i)}$</p><p><br/></p><p>定义几何间隔如下</p><center><img src="image-20190825154844249.png" srcset="/img/loading.gif" alt="image-20190825154844249" style="zoom:33%;" /></center><p>B在 $w^Tx+b=0$上，A到分割面的距离用 $\gamma^{(i)}$表示，B是A在分割面上的投影</p><p>向量 $\overrightarrow{BA}$的方向就是w的方向</p><center><img src="image-20190825162137589.png" srcset="/img/loading.gif" width="300"></center><p>​        这个地方产生了问题是因为没有想清楚 $y=w^Tx+b$如上图所示，两个坐标轴应该是     $x_1, x_2$,$y$是标圈和叉的那个维度，图为二维实则三维，所以是个分割面</p><p><br/></p><p>A的坐标是 $(x^{(i)}, y^{(i)})$，所以B的坐标应该是 $x=x^{(i)}-\gamma^{(i)}\frac{w}{\Vert{w}\Vert}$（这里做的是向量减法)</p><p>带入 $w^Tx+b=0$</p><p>​    $w^T(x^{(i)}-\gamma^{(i)}\frac{w}{\Vert{w}\Vert}) + b=0$    </p><p>​    解得$\gamma^{(i)}=\frac{w^Tx_i+b}{\Vert{w}\Vert}=(\frac{w}{\Vert{w}\Vert})^Tx^{(i)}+\frac{b}{\Vert{w}\Vert}$</p><p>通常，我们会将几何间隔定义为</p><p>$\gamma^{(i)}=y^{(i)}(\frac{w}{\Vert{w}\Vert})^Tx^{(i)}+\frac{b}{\Vert{w}\Vert}$</p><p>我们可以看到 当$\Vert{w}\Vert=1$时，$\gamma^{(i)}=y^{(i)}(w^Tx^{(i)}+b)=\hat{y}$，即几何间隔等于函数间隔</p><p>定义全局的几何间隔 $\gamma=\underset{i=1,\cdots,m}{min}\gamma^{(i)}$</p><p><br/></p><h4 id="最优间隔分类器"><a href="#最优间隔分类器" class="headerlink" title="最优间隔分类器"></a>最优间隔分类器</h4><p>我们要做的就是寻找一个分割面，使得离分割面最近的点和分割面的距离最大，距离越大我们就对一个样本分到正确的类越有信心</p><p>我们要使$\gamma=\underset{i=1,\cdots,m}{min}\gamma^{(i)}$取到最大值，即</p><p>$max_{\gamma,w,b}\gamma\quad s.t.\,\, y^{(i)}(\frac{w}{\Vert{w}\Vert})^Tx^{(i)}+\frac{b}{\Vert{w}\Vert}\geq\gamma\,\,\,\, i=1,\cdots,m\quad \Vert{w}\Vert=1$</p><p>这里将 $\Vert{w}\Vert$规约为1，因为几何间隔中  $\Vert{w}\Vert$ 变成2，那么所有几何间隔缩小为原来的一半，对大小的比较不产生影响</p><p><br/></p><p>但是  $\Vert{w}\Vert$不是一个凸集，无法带入优化软件计算，我们考虑几何间隔与函数间隔 $\hat{y}$之间d 关系后得到</p><p>$max_{\gamma,w,b}\frac{\hat{\gamma}}{\Vert{w}\Vert} \quad s.t.\,\, y^{(i)}(w^Tx^{(i)}+b)\geq\hat{\gamma}\,\,\,\, i=1,\cdots,m$</p><p>这里的 w就不受$\Vert{w}\Vert=1$的限制了</p><p><br/></p><p>但是目标函数依然不是凸函数，我们对 $\hat{\gamma}$做限制，取 $\hat{\gamma}=1$，那么离分割面最近的距离为 $\frac{1}{\Vert{w}\Vert}$，求 $\frac{1}{\Vert{w}\Vert}$的最大值相当于求 $\frac{1}{2}\Vert{w}\Vert^2$的最小值，最后得到</p><p>$min_{\gamma,w,b}\frac{1}{2}\Vert{w}\Vert^2\quad s.t.\,\,\,\, y^{(i)}(w^Tx^{(i)}+b)\geq 1\quad i=1,\cdots,m$</p><p>这是个二次规划问题，可以带入软件求解</p><p><br/></p><p>补充凸优化</p><p>为什么要凸优化？<br>这种优化是一定可以找到全局最优的，因为不存在局部最优，只有一个最优点<br>所以对于梯度下降或其他的最优化算法而言，在非凸的情况下，很可能找到的只是个局部最优</p><p>什么是凸集？</p><p>集合中任意两点的连线都在集合中 </p><table>  <tr>    <td>       <img src="image-20190930210429006.png" srcset="/img/loading.gif" alt="301934503929624" style="zoom: 50%;" />    </td>    <td>      <img src="image-20190930210452992.png" srcset="/img/loading.gif" alt="image-20190930210452992" style="zoom:50%;" />    </td>  </tr></table><p>凸优化问题的定义</p><p>在凸集上寻找凸函数的全局最值的过程称为凸优化<br>即，目标函数(objective function)是凸函数，可行集(feasible set)为凸集</p><p>为何目标函数需要是凸函数？<br>这个比较容易理解，不是凸函数会有多个局部最优，如下图，不一定可以找到全局最优 </p><center><img src="image-20190930210310272.png" srcset="/img/loading.gif" alt="image-20190930210310272" style="zoom:50%;" /></center><p>为何可行集需要为凸集？<br>稍微难理解一些，看下图<br>虽然目标函数为凸函数，但是如果可行集非凸集，一样无法找到全局最优 </p><center><img src="image-20190930210206404.png" srcset="/img/loading.gif" alt="image-20190930210206404" style="zoom:50%;" /></center><p><br/></p><p><br/></p><p>References:  </p><p>[1] 吴恩达机器学习</p>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
