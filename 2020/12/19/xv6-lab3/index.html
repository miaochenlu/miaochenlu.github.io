<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>page tables [os lab3] | Explorer</title><meta name="keywords" content="Operating System,xv6"><meta name="author" content="Chenlu Miao"><meta name="copyright" content="Chenlu Miao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Print a page table To help you learn about RISC-V page tables, and perhaps to aid future debugging, your first task is to write a function that prints the contents of a page table. Define a function c">
<meta property="og:type" content="article">
<meta property="og:title" content="page tables [os lab3]">
<meta property="og:url" content="https://miaochenlu.github.io/2020/12/19/xv6-lab3/index.html">
<meta property="og:site_name" content="Explorer">
<meta property="og:description" content="Print a page table To help you learn about RISC-V page tables, and perhaps to aid future debugging, your first task is to write a function that prints the contents of a page table. Define a function c">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://miaochenlu.github.io/img/xv6lab.jpg">
<meta property="article:published_time" content="2020-12-19T13:22:11.000Z">
<meta property="article:modified_time" content="2021-11-15T03:29:22.795Z">
<meta property="article:author" content="Chenlu Miao">
<meta property="article:tag" content="Operating System">
<meta property="article:tag" content="xv6">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://miaochenlu.github.io/img/xv6lab.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://miaochenlu.github.io/2020/12/19/xv6-lab3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'page tables [os lab3]',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-15 11:29:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Explorer" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fas fa-music"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="https://miaochenlu.github.io/about"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://jonesm.gitbook.io/coding/"><i class="fa-fw Coding"></i><span> Coding</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://jonesm.gitbook.io/research/"><i class="fa-fw Research"></i><span> Research</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/xv6lab.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Explorer</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fas fa-music"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="https://miaochenlu.github.io/about"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://jonesm.gitbook.io/coding/"><i class="fa-fw Coding"></i><span> Coding</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://jonesm.gitbook.io/research/"><i class="fa-fw Research"></i><span> Research</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">page tables [os lab3]</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-19T13:22:11.000Z" title="发表于 2020-12-19 21:22:11">2020-12-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-15T03:29:22.795Z" title="更新于 2021-11-15 11:29:22">2021-11-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Operating-System/">Operating System</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="page tables [os lab3]"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>Print a page table</h1>
<p>To help you learn about RISC-V page tables, and perhaps to aid future debugging, your first task is to write a function that prints the contents of a page table.</p>
<div class="note primary flat"><p>Define a function called <code>vmprint()</code>. It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process’s page table. You receive full credit for this assignment if you pass the <code>pte printout</code> test of <code>make grade</code>.</p>
</div>
<p>Now when you start xv6 it should print output like this, describing the page table of the first process at the point when it has just finished <code>exec()</code>ing <code>init</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">page table 0x0000000087f6e000</span><br><span class="line">..0: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line">.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line">.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line">.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line">.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line">..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line">.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line">.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000</span><br><span class="line">.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>The first line displays the argument to <code>vmprint</code>. After that there is a line for each PTE, including PTEs that refer to page-table pages deeper in the tree. Each PTE line is indented by a number of <code>&quot; ..&quot;</code> that indicates its depth in the tree. Each PTE line shows the PTE index in its page-table page, the pte bits, and the physical address extracted from the PTE. Don’t print PTEs that are not valid. In the above example, the top-level page-table page has mappings for entries 0 and 255. The next level down for entry 0 has only index 0 mapped, and the bottom-level for that index 0 has entries 0, 1, and 2 mapped.</p>
<p>Your code might emit different physical addresses than those shown above. The number of entries and the virtual addresses should be the same.</p>
<h2 id="Some-hints">Some hints</h2>
<div class="note success flat"><ul>
<li>You can put <code>vmprint()</code> in <code>kernel/vm.c</code>.</li>
</ul>
</div>
<div class="note success flat"><ul>
<li>Use the macros at the end of the file <code>kernel/riscv.h</code>.</li>
</ul>
</div>
<div class="note success flat"><ul>
<li>The function <code>freewalk</code> may be inspirational.</li>
</ul>
</div>
<p>这个函数展示了如何去recursively访问page table</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freewalk</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note success flat"><ul>
<li>Define the prototype for <code>vmprint</code> in <code>kernel/defs.h</code> so that you can call it from <code>exec.c</code>.</li>
</ul>
</div>
<img src="/2020/12/19/xv6-lab3/image-20201219212505432.png" alt="image-20201219212505432" style="zoom:80%;">
<div class="note success flat"><ul>
<li>Use <code>%p</code> in your printf calls to print out full 64-bit hex PTEs and addresses as shown in the example.</li>
</ul>
</div>
<h2 id="Final-Code">Final Code</h2>
<p>想法比较自然，写一个递归函数<code>vmprintRecursive</code>去深度遍历page table, 因为打印<code>.. </code>的原因，还提供了一个函数参数level</p>
<p>这个深度遍历函数的逻辑是: 从0-511去查看page table entry</p>
<p>如果查到了pte并且他是valid的, 就通过<code>PTE2PA</code>获取指向的physical address。这个时候打印题目所要求的内容</p>
<p>更进一步，如果这个pte不是PTE_R, PTE_W, PTE_X没有被置位，说明这个pte指向了下一层page table的physical address, 递归去访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprintRecursive</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V) &#123;</span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= level; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(i != level) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)</span><br><span class="line">          vmprintRecursive((<span class="keyword">pagetable_t</span>)child, level + <span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  vmprintRecursive(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>A kernel page table per process</h1>
<div class="note primary flat"><p>Xv6 has a single kernel page table that’s used whenever it executes in the kernel. The kernel page table is a direct mapping to physical addresses, so that kernel virtual address <em>x</em> maps to physical address <em>x</em>. Xv6 also has a separate page table for each process’s user address space, containing only mappings for that process’s user memory, starting at virtual address zero. Because the kernel page table doesn’t contain these mappings, user addresses are not valid in the kernel. Thus, when the kernel needs to use a user pointer passed in a system call (e.g., the buffer pointer passed to <code>write()</code>), the kernel must first translate the pointer to a physical address. The goal of this section and the next is to allow the kernel to directly dereference user pointers.</p>
<p>Xv6 has a single kernel page table that’s used whenever it executes in the kernel. The kernel page table is a direct mapping to physical addresses, so that kernel virtual address <em>x</em> maps to physical address <em>x</em>. Xv6 also has a separate page table for each process’s user address space, containing only mappings for that process’s user memory, starting at virtual address zero. Because the kernel page table doesn’t contain these mappings, user addresses are not valid in the kernel. Thus, when the kernel needs to use a user pointer passed in a system call (e.g., the buffer pointer passed to <code>write()</code>), the kernel must first translate the pointer to a physical address. The goal of this section and the next is to allow the kernel to directly dereference user pointers.</p>
</div>
<p>这个实验中修改的部分有<code>vm.c, proc.h, proc.c, defs.h</code></p>
<h2 id="Some-hints-2">Some hints</h2>
<div class="note success flat"><ul>
<li>Add a field to <code>struct proc</code> for the process’s kernel page table.</li>
</ul>
</div>
<img src="/2020/12/19/xv6-lab3/image-20201222200731803.png" alt="image-20201222200731803" style="zoom: 50%;">
<div class="note success flat"><ul>
<li>A reasonable way to produce a kernel page table for a new process is to implement a modified version of <code>kvminit</code> that makes a new page table instead of modifying <code>kernel_pagetable</code>. You’ll want to call this function from <code>allocproc</code>.</li>
</ul>
</div>
<p><code>allocproc</code>函数分配并且初始化struct proc, 因为我们在struct proc中增加了kernel page table, 因此需要在这里进行初始化。</p>
<p>在<code>kernel/vm.c</code>中<code>kvminit</code>函数创建了direct-map kernel page table。在<code>kernel/proc.c</code>中仿照<code>kvminit</code>函数新写一个<code>proc_kpagetable</code>函数来创建process中的kernel page table</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pagetable_t</span></span></span><br><span class="line"><span class="function"><span class="title">proc_kpagetable</span><span class="params">(struct proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> kpagetable;</span><br><span class="line"></span><br><span class="line">  kpagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span> (kpagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Fill in the process&#x27;s kernel page table, the same as kernel_pagetable</span></span><br><span class="line">  ukvmmap(kpagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(kpagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(kpagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(kpagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  ukvmmap(kpagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(kpagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  ukvmmap(kpagetable, TRAPFRAME, (uint64)(p-&gt;trapframe), PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="keyword">return</span> kpagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>kernel/proc.c</code>的<code>allocproc</code>函数中调用<code>proc_kpagetable</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An empty user page table.</span></span><br><span class="line">p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;kpagetable = proc_kpagetable(p);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;kpagetable == <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note success flat"><ul>
<li>Make sure that each process’s kernel page table has a mapping for that process’s kernel stack. In unmodified xv6, all the kernel stacks are set up in <code>procinit</code>. You will need to move some or all of this functionality to <code>allocproc</code>.</li>
</ul>
</div>
<p>修改<code>kernel/proc.c</code>中的<code>procinit</code>函数, 注释掉分配kernel stack的部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">procinit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">      <span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line">      <span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line">      <span class="comment">// guard page.</span></span><br><span class="line">      <span class="comment">//char *pa = kalloc();</span></span><br><span class="line">      <span class="comment">//if(pa == 0)</span></span><br><span class="line">      <span class="comment">//    panic(&quot;kalloc&quot;);</span></span><br><span class="line">      <span class="comment">//uint64 va = KSTACK((int) (p - proc));</span></span><br><span class="line">      <span class="comment">//kvmmap(p-&gt;kpagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span></span><br><span class="line">      <span class="comment">//p-&gt;kstack = va;</span></span><br><span class="line">  &#125;</span><br><span class="line">  kvminithart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将这部分代码移动到<code>allocproc</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line"><span class="comment">// guard page.</span></span><br><span class="line"><span class="keyword">char</span> *pa = kalloc();</span><br><span class="line"><span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">  panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">uint64 va = KSTACK((<span class="keyword">int</span>) (p - proc));</span><br><span class="line">ukvmmap(p-&gt;kpagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br></pre></td></tr></table></figure>
<p>注意: 这里将<code>kvmmap</code>函数改成了<code>ukvmmap</code>函数, <code>kvmmap</code>函数默认操作<code>kernel_pagetable</code>, 而这里我们想要在process的<code>kpagetable</code>中进行映射， 因此增加了一个<code>ukvmmap</code>函数，多提供了一个<code>pagetable</code>的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kvmmap</span><span class="params">(uint64 va, uint64 pa, uint64 sz, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kernel_pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ukvmmap</span><span class="params">(<span class="keyword">pagetable_t</span> kpagetable, uint64 va, uint64 pa, uint64 sz, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;ukvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note success flat"><ul>
<li>Modify <code>scheduler()</code> to load the process’s kernel page table into the core’s <code>satp</code> register (see <code>kvminithart</code> for inspiration). Don’t forget to call <code>sfence_vma()</code> after calling <code>w_satp()</code>.</li>
</ul>
</div>
<img src="/2020/12/19/xv6-lab3/image-20201222202345524.png" alt="image-20201222202345524" style="zoom:50%;">
<div class="note success flat"><ul>
<li><code>scheduler()</code> should use <code>kernel_pagetable</code> when no process is running.</li>
</ul>
</div>
<img src="/2020/12/19/xv6-lab3/image-20201222202559087.png" alt="image-20201222202559087" style="zoom:50%;">
<div class="note warning flat"><p>注意, 在<code>kernel/vm.c</code>中，<code>kvmpa</code>函数会在进程执行期间调用，这个函数不应调用全局kernel page table, 而应调用进程对应的kernel page table</p>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// translate a kernel virtual address to</span></span><br><span class="line"><span class="comment">// a physical address. only needed for</span></span><br><span class="line"><span class="comment">// addresses on the stack.</span></span><br><span class="line"><span class="comment">// assumes va is page aligned.</span></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">kvmpa</span><span class="params">(uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 off = va % PGSIZE;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  </span><br><span class="line">  pte = walk(myproc()-&gt;kpagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa+off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用<code>myproc()</code>函数 ，还需要在头文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;proc.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<div class="note success flat"><ul>
<li>Free a process’s kernel page table in <code>freeproc</code>.</li>
<li>You’ll need a way to free a page table without also freeing the leaf physical memory pages.</li>
</ul>
</div>
<p>修改<code>kernel/proc.c</code>中的<code>freeproc</code>函数。free kernel stack, free kernel page table</p>
<ul>
<li>free kstack是通过kpage table去查找kstack对应的物理地址，然后free</li>
<li>free kernel page table是通过<code>kernel/proc.c</code>中一个新写的函数<code>proc_freekpagetable</code>来实现的。这个函数借鉴<code>kernel/vm.c</code>中的<code>freewalk</code>函数 。注意这里只free kernel page table, 不能把page table指向的地址free掉，也就是不能free leaves</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_freekpagetable</span><span class="params">(<span class="keyword">pagetable_t</span> kpagetable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = kpagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V) &#123;</span><br><span class="line">      kpagetable[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>) &#123;</span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        proc_freekpagetable((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span>*)kpagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freeproc</span><span class="params">(struct proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="keyword">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// free kernel stack</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kstack) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span>* pte = walk(p-&gt;kpagetable, p-&gt;kstack, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;freeproc: walk&quot;</span>);</span><br><span class="line">    kfree((<span class="keyword">void</span>*)PTE2PA(*pte));</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kpagetable)</span><br><span class="line">    proc_freekpagetable(p-&gt;kpagetable);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;kpagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里要先free kstack。如果先free pagetable, 再free kstack, 则会出现error</p>
<div class="note success flat"><ul>
<li><code>vmprint</code> may come in handy to debug page tables.</li>
</ul>
</div>
<div class="note success flat"><ul>
<li>It’s OK to modify xv6 functions or add new functions; you’ll probably need to do this in at least <code>kernel/vm.c</code> and <code>kernel/proc.c</code>. (But, don’t modify <code>kernel/vmcopyin.c</code>, <code>kernel/stats.c</code>, <code>user/usertests.c</code>, and <code>user/stats.c</code>.)</li>
</ul>
</div>
<div class="note success flat"><ul>
<li>A missing page table mapping will likely cause the kernel to encounter a page fault. It will print an error that includes <code>sepc=0x00000000XXXXXXXX</code>. You can find out where the fault occurred by searching for <code>XXXXXXXX</code> in <code>kernel/kernel.asm</code>.</li>
</ul>
</div>
<h2 id="Final-Code-2">Final Code</h2>
<ul>
<li>
<p>在<code>kernel/defs.h</code>中补上一些函数的声明</p>
<img src="/2020/12/19/xv6-lab3/image-20201222204213555.png" alt="pic1" style="zoom:67%;">
<img src="/2020/12/19/xv6-lab3/image-20201222204251376.png" alt="pic1" style="zoom:67%;">
</li>
<li>
<p><code>kernel/proc.h</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="keyword">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="keyword">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> kpagetable;      <span class="comment">// Kernel page table</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel/vm.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;proc.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ukvmmap</span><span class="params">(<span class="keyword">pagetable_t</span> kpagetable, uint64 va, uint64 pa, uint64 sz, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;ukvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">kvmpa</span><span class="params">(uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 off = va % PGSIZE;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  </span><br><span class="line">  pte = walk(myproc()-&gt;kpagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa+off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel/proc.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> etext[];  <span class="comment">// kernel.ld sets this to end of kernel code.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pagetable_t</span> kernel_pagetable;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">procinit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  kvminithart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc*</span></span><br><span class="line"><span class="function"><span class="title">allocproc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (struct trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p-&gt;kpagetable = proc_kpagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kpagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line">  <span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line">  <span class="comment">// guard page.</span></span><br><span class="line">  <span class="keyword">char</span> *pa = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">  uint64 va = KSTACK((<span class="keyword">int</span>) (p - proc));</span><br><span class="line">  ukvmmap(p-&gt;kpagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  p-&gt;kstack = va;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freeproc</span><span class="params">(struct proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="keyword">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// free kernel stack</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kstack) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span>* pte = walk(p-&gt;kpagetable, p-&gt;kstack, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;freeproc: walk&quot;</span>);</span><br><span class="line">    kfree((<span class="keyword">void</span>*)PTE2PA(*pte));</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kpagetable)</span><br><span class="line">    proc_freekpagetable(p-&gt;kpagetable);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;kpagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pagetable_t</span></span></span><br><span class="line"><span class="function"><span class="title">proc_kpagetable</span><span class="params">(struct proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> kpagetable;</span><br><span class="line"></span><br><span class="line">  kpagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span> (kpagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Fill in the process&#x27;s kernel page table, the same as kernel_pagetable</span></span><br><span class="line">  ukvmmap(kpagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(kpagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(kpagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(kpagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  ukvmmap(kpagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(kpagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  ukvmmap(kpagetable, TRAPFRAME, (uint64)(p-&gt;trapframe), PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="keyword">return</span> kpagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_freekpagetable</span><span class="params">(<span class="keyword">pagetable_t</span> kpagetable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = kpagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V) &#123;</span><br><span class="line">      kpagetable[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>) &#123;</span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        proc_freekpagetable((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span>*)kpagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">scheduler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load process&#x27;s kernel page table </span></span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;kpagetable));</span><br><span class="line">        sfence_vma();</span><br><span class="line"></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined (LAB_FS)</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">      sfence_vma();</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Simplify <code>copyin/copyinstr</code></h1>
<div class="note primary flat"><p>The kernel’s <code>copyin</code> function reads memory pointed to by user pointers. It does this by translating them to physical addresses, which the kernel can directly dereference. It performs this translation by walking the process page-table in software. Your job in this part of the lab is to add user mappings to each process’s kernel page table (created in the previous section) that allow<code>copyin</code> (and the related string function <code>copyinstr</code>) to directly dereference user pointers.</p>
<p>Replace the body of <code>copyin</code> in <code>kernel/vm.c</code> with a call to <code>copyin_new</code> (defined in <code>kernel/vmcopyin.c</code>); do the same for <code>copyinstr</code> and <code>copyinstr_new</code>. Add mappings for user addresses to each process’s kernel page table so that <code>copyin_new</code> and <code>copyinstr_new</code> work. You pass this assignment if <code>usertests</code>runs correctly and all the <code>make grade</code> tests pass.</p>
<p>This scheme relies on the user virtual address range not overlapping the range of virtual addresses that the kernel uses for its own instructions and data. Xv6 uses virtual addresses that start at zero for user address spaces, and luckily the kernel’s memory starts at higher addresses. However, this scheme does limit the maximum size of a user process to be less than the kernel’s lowest virtual address. After the kernel has booted, that address is <code>0xC000000</code> in xv6, the address of the PLIC registers; see <code>kvminit()</code> in <code>kernel/vm.c</code>, <code>kernel/memlayout.h</code>, and Figure 3-4 in the text. You’ll need to modify xv6 to prevent user processes from growing larger than the PLIC address.</p>
</div>
<p>为了让kernel page table直接能够translate user space address, 需要把user pagetable的信息复制到kernel pagetable中。</p>
<p>这里要回答两个问题</p>
<ul>
<li>怎么将user pagetable的信息复制到kernel page table (通过<code>ukvmcopy</code>函数来解决这个问题)</li>
<li>哪些函数需要生成了/改变了address mapping, 需要将user pagetable的信息复制到kernel page table (<code>userinit</code>, <code>fork</code>, <code>exec</code>, <code>sbrk</code>)</li>
</ul>
<h2 id="Some-hints-3">Some hints</h2>
<div class="note success flat"><ul>
<li>Replace <code>copyin()</code> with a call to <code>copyin_new</code> first, and make it work, before moving on to <code>copyinstr</code>.</li>
</ul>
</div>
<p>修改<code>kernel/vm.c</code>中的<code>copyin</code>和<code>copyin_new</code>函数</p>
<img src="/2020/12/19/xv6-lab3/image-20201227210648285.png" alt="image-20201227210648285" style="zoom:80%;">
<div class="note success flat"><ul>
<li>At each point where the kernel changes a process’s user mappings, change the process’s kernel page table in the same way. Such points include <code>fork()</code>, <code>exec()</code>, and <code>sbrk()</code>.</li>
<li>What permissions do the PTEs for user addresses need in a process’s kernel page table? (A page with <code>PTE_U</code> set cannot be accessed in kernel mode.)</li>
<li>Don’t forget about the above-mentioned PLIC limit</li>
</ul>
</div>
<p>这几个函数都需要将user space中的地址映射拷贝到kernel page table。因此在<code>kernel/vm.c</code>中增加一个函数<code>ukvmcopy</code>来完成这项工作。</p>
<p>从user space的virtual address的起始地址开始，通过<code>walk</code>函数在pagetable中找到地址对应的page table entry, 然后在kernel page table中为这个page分配一个kernel page table entry。要注意对flag的处理，如果PTE_U置位，在kernel mode下是无法访问的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ukvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">pagetable_t</span> kpagetable, uint64 beginsz, uint64 endsz)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *upte, *kpte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  uint flags;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(beginsz &gt; endsz) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span>(uint64 i = beginsz; i &lt; endsz; i += PGSIZE) &#123;</span><br><span class="line">    <span class="keyword">if</span>((upte = walk(pagetable, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;ukvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((kpte = walk(kpagetable, i, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;ukvmcopy: walk fails&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*upte);</span><br><span class="line">    flags = (PTE_FLAGS(*upte) &amp; (~PTE_U));</span><br><span class="line">    *kpte = PA2PTE(pa) | flags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在<code>fork</code>, <code>exec</code>, <code>sbrk</code>的代码使用这个函数，将user page table的信息记录到kernel page table.</p>
<p>对于<code>fork()</code>, 修改<code>kernel/proc.c</code>中的<code>fork</code>函数</p>
<img src="/2020/12/19/xv6-lab3/image-20201227203900952.png" alt="image-20201227203900952" style="zoom:80%;">
<p>对于<code>exec</code>, 修改<code>kernel/exec.c</code>中的<code>exec</code>函数</p>
<p><img src="/2020/12/19/xv6-lab3/image-20201227205027041.png" alt="image-20201227205027041" style="zoom:80%;"></p>
<p>对于<code>sbrk</code></p>
<p><code>kernel/sysproc.c</code>中的<code>sys_sbrk</code>是这样定义的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sbrk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要工作是在<code>kernel/proc.c</code>的<code>growproc</code>函数中完成的， 因此把代码加在<code>growproc</code>中</p>
<p><code>growproc</code>函数在扩张的时候要注意不能超过PLIC。</p>
<p>使用<code>ukvmcopy</code>的时候要注意这里的<code>sz</code>是扩张或者收缩n bytes之后的<code>sz</code></p>
<img src="/2020/12/19/xv6-lab3/image-20201227210053052.png" alt="image-20201227210053052" style="zoom:80%;">
<div class="note success flat"><ul>
<li>Don’t forget that to include the first process’s user page table in its kernel page table in <code>userinit</code>.</li>
</ul>
</div>
<p>在创建第一个user process的时候就要将user page table复制到kernel page table中</p>
<img src="/2020/12/19/xv6-lab3/image-20201227210335814.png" alt="image-20201227210335814" style="zoom:80%;">
<p>对了！不要忘记在<code>kernel/defs.h</code>中声明<code>ukvmcopy</code>, <code>copyin_new</code>, <code>copyinstr_new</code>函数</p>
<img src="/2020/12/19/xv6-lab3/image-20201227211533018.png" alt="image-20201227211533018" style="zoom:80%;">
<h1>Reference</h1>
<p>[1]<a target="_blank" rel="noopener" href="https://github.com/gaofanfei/xv6-riscv-fall20/tree/pgtbl">https://github.com/gaofanfei/xv6-riscv-fall20/tree/pgtbl</a></p>
<p>[2]<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013577996/article/details/109582932">https://blog.csdn.net/u013577996/article/details/109582932</a></p>
<p>[3]<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/336091300">https://zhuanlan.zhihu.com/p/336091300</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Chenlu Miao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://miaochenlu.github.io/2020/12/19/xv6-lab3/">https://miaochenlu.github.io/2020/12/19/xv6-lab3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://miaochenlu.github.io" target="_blank">Explorer</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Operating-System/">Operating System</a><a class="post-meta__tags" href="/tags/xv6/">xv6</a></div><div class="post_share"><div class="social-share" data-image="/img/xv6lab.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/23/scientificWriting/"><img class="prev-cover" src="/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">科研写作</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/16/xv6-lab2/"><img class="next-cover" src="/img/xv6lab.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">System calls [os lab2]</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/12/07/startXv6/" title="启动xv6创建第一个进程"><img class="cover" src="/img/operatingsystem.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-07</div><div class="title">启动xv6创建第一个进程</div></div></a></div><div><a href="/2020/12/03/xv6-lab1/" title="Xv6 and Unix utilities [OS lab1]"><img class="cover" src="/img/xv6lab.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-03</div><div class="title">Xv6 and Unix utilities [OS lab1]</div></div></a></div><div><a href="/2020/12/16/xv6-lab2/" title="System calls [os lab2]"><img class="cover" src="/img/xv6lab.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-16</div><div class="title">System calls [os lab2]</div></div></a></div><div><a href="/2020/11/27/OSInterfaces/" title="操作系统接口"><img class="cover" src="/img/operatingsystem.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-27</div><div class="title">操作系统接口</div></div></a></div><div><a href="/2021/11/27/bootloader/" title="操作系统也是程序 (调试Firmware和Bootloader)"><img class="cover" src="/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-27</div><div class="title">操作系统也是程序 (调试Firmware和Bootloader)</div></div></a></div><div><a href="/2021/10/19/jyyos1/" title="操作系统上的程序 - NJUOS"><img class="cover" src="/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-19</div><div class="title">操作系统上的程序 - NJUOS</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Chenlu Miao</div><div class="author-info__description">多务实 少务虚</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/miaochenlu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/miaochenlu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:clmiao@zju.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Print a page table</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Some-hints"><span class="toc-number">1.1.</span> <span class="toc-text">Some hints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final-Code"><span class="toc-number">1.2.</span> <span class="toc-text">Final Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">A kernel page table per process</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Some-hints-2"><span class="toc-number">2.1.</span> <span class="toc-text">Some hints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final-Code-2"><span class="toc-number">2.2.</span> <span class="toc-text">Final Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Simplify copyin&#x2F;copyinstr</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Some-hints-3"><span class="toc-number">3.1.</span> <span class="toc-text">Some hints</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Reference</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/30/cuckoo-filter/" title="🐦 Cuckoo Filter"><img src="/img/cuckoo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="🐦 Cuckoo Filter"/></a><div class="content"><a class="title" href="/2022/04/30/cuckoo-filter/" title="🐦 Cuckoo Filter">🐦 Cuckoo Filter</a><time datetime="2022-04-30T03:51:29.000Z" title="发表于 2022-04-30 11:51:29">2022-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/29/bloom-filter/" title="Bloom Filter"><img src="/img/bloom_filter.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Bloom Filter"/></a><div class="content"><a class="title" href="/2022/04/29/bloom-filter/" title="Bloom Filter">Bloom Filter</a><time datetime="2022-04-29T13:24:55.000Z" title="发表于 2022-04-29 21:24:55">2022-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/09/hotupdate/" title="C++文件热更新设计"><img src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++文件热更新设计"/></a><div class="content"><a class="title" href="/2021/12/09/hotupdate/" title="C++文件热更新设计">C++文件热更新设计</a><time datetime="2021-12-09T06:45:30.000Z" title="发表于 2021-12-09 14:45:30">2021-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/27/bootloader/" title="操作系统也是程序 (调试Firmware和Bootloader)"><img src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统也是程序 (调试Firmware和Bootloader)"/></a><div class="content"><a class="title" href="/2021/11/27/bootloader/" title="操作系统也是程序 (调试Firmware和Bootloader)">操作系统也是程序 (调试Firmware和Bootloader)</a><time datetime="2021-11-27T15:20:01.000Z" title="发表于 2021-11-27 23:20:01">2021-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/19/jyyos1/" title="操作系统上的程序 - NJUOS"><img src="/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统上的程序 - NJUOS"/></a><div class="content"><a class="title" href="/2021/10/19/jyyos1/" title="操作系统上的程序 - NJUOS">操作系统上的程序 - NJUOS</a><time datetime="2021-10-19T03:32:54.000Z" title="发表于 2021-10-19 11:32:54">2021-10-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Chenlu Miao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>